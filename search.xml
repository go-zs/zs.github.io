<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PlantUML上手</title>
      <link href="2021/05/24/plantuml/"/>
      <url>2021/05/24/plantuml/</url>
      
        <content type="html"><![CDATA[<p>工作中经常需要画<code>UML</code>，<code>draw.io</code>是个非常好的可视化工具，对程序员来说<code>PlantUML</code>用编程的方式来画<code>UML</code>也是一个非常不错的选择。</p><a id="more"></a><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>我们来实现一个简单的用户登录token校验的时序图。参与者是不用显示声明的，<code>用户 -&gt; 认证中心: 登录操作</code>，就表示<code>用户</code>向<code>认证中心</code>发起了<code>登录操作</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">skinparam responseMessageBelowArrow true &#x2F;&#39; response在箭头下方 &#39;&#x2F;</span><br><span class="line">用户 -&gt; 认证中心: 登录操作</span><br><span class="line">activate 认证中心</span><br><span class="line"></span><br><span class="line">认证中心 -&gt; 认证中心: 账户校验 &#x2F;&#39; 给自己发消息，用\n换行 &#39;&#x2F;</span><br><span class="line">认证中心 --&gt; 用户: 校验失败</span><br><span class="line">note right #FFAAAA: 账户信息校验失败</span><br><span class="line"></span><br><span class="line">认证中心 -&gt; 缓存: 存放token</span><br><span class="line">note over 认证中心, 缓存: 账户信息校验成功</span><br><span class="line"></span><br><span class="line">认证中心 -&gt; 用户: 返回token</span><br><span class="line">deactivate 认证中心</span><br><span class="line"></span><br><span class="line">用户 -&gt; 认证中心: 携带token再次访问</span><br><span class="line">认证中心 -&gt; 缓存: 获取用户token</span><br><span class="line">缓存 -&gt; 认证中心: 返回token</span><br><span class="line">|||  &#x2F;&#39; 空间 &#39;&#x2F;</span><br><span class="line">认证中心 -&gt; 业务服务: 校验token成功跳转其它业务服务</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>生成的<code>UML</code>图如下</p><p><img src="https://pic.hupai.pro/img/20210524114506.png" alt></p><p>可以用<code>participant</code>关键字声明参与者，声明也可以控制参与者的图标、颜色以及参与者之间顺序。</p><p>···planuml<br>@startuml<br>actor Bob #red<br>‘ actor 和 participant 只在外观上有区别<br>participant Alice<br>participant “很长很长很长\n的名字” as L #99FF99</p><p>Alice-&gt;Bob: 认证请求<br>Bob-&gt;Alice: 认证响应<br>Bob-&gt;L: 记录事务日志<br>@enduml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;pic.hupai.pro&#x2F;img&#x2F;20210524115854.png)</span><br><span class="line"></span><br><span class="line">箭头还支持下面的设置</span><br><span class="line"></span><br><span class="line">* -&gt;,&lt;-- 传递消息</span><br><span class="line">* --&gt;, &lt;-- 虚线箭头</span><br><span class="line">* -[#red]&gt; 红色箭头</span><br><span class="line">* -&gt;x 打X</span><br><span class="line">* x-&gt;o </span><br><span class="line">* &lt;-&gt; 双向信息</span><br><span class="line"></span><br><span class="line">## 流程图</span><br><span class="line"></span><br><span class="line">流程图支持常见的 &#96;switch&#96;、&#96;if-else&#96; 、&#96;while&#96;等逻辑处理。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;plantuml</span><br><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">:&quot;发起请求&quot;;</span><br><span class="line">-[#black,dotted]-&gt; 服务端处理;   &#x2F;&#39; 可以在箭头上加文字  &#39;&#x2F;</span><br><span class="line">:&quot;接收请求&quot;;</span><br><span class="line">if (&quot;校验账户信息&quot;) then (true)</span><br><span class="line">    :条件1成立时执行的动作;</span><br><span class="line">    if (&quot;校验用户名失败&quot;) then (no)</span><br><span class="line">        -[#blue]-&gt; </span><br><span class="line">        :&quot;返回登录错误&quot;;</span><br><span class="line">    else</span><br><span class="line">        if (&quot;校验密码&quot;) then (yes)</span><br><span class="line">            :&quot;认证成功&quot;;</span><br><span class="line">            partition 权限校验 &#123;</span><br><span class="line">              switch ( 判断用户角色 )</span><br><span class="line">              case ( 管理员 )</span><br><span class="line">                :&quot;登录成功&quot;;</span><br><span class="line">              case ( 普通用户 )</span><br><span class="line">                :&quot;登录失败&quot;;</span><br><span class="line">              endswitch</span><br><span class="line">            &#125;</span><br><span class="line">        else (no)</span><br><span class="line">            -[#blue]-&gt;</span><br><span class="line">            :&quot;登录失败&quot;;</span><br><span class="line">            note right</span><br><span class="line">              密码错误</span><br><span class="line">            end note</span><br><span class="line">        endif</span><br><span class="line">      endif</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="https://pic.hupai.pro/img/20210524202724.png" alt></p><p>可以使用关键字fork，fork again和end fork表示并行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">if (multiprocessor?) then (yes)</span><br><span class="line">  fork</span><br><span class="line">    :Treatment 1;</span><br><span class="line">  fork again</span><br><span class="line">    :Treatment 2;</span><br><span class="line">  end fork</span><br><span class="line">else (monoproc)</span><br><span class="line">  :Treatment 1;</span><br><span class="line">  :Treatment 2;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="https://pic.hupai.pro/img/20210524202853.png" alt></p><h2 id="泳道-Swimlanes"><a href="#泳道-Swimlanes" class="headerlink" title="泳道(Swimlanes)"></a>泳道(Swimlanes)</h2><p>泳道图是一种特殊的流程图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">|Swimlane1|</span><br><span class="line">start</span><br><span class="line">:foo1;</span><br><span class="line">|#Orange|Swimlane2|</span><br><span class="line">:foo2;</span><br><span class="line">:foo3;</span><br><span class="line">|Swimlane1|</span><br><span class="line">:foo4;</span><br><span class="line">|Swimlane2|</span><br><span class="line">#red:foo5;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>可以前往<a href="https://github.com/future-architect/puml-themes" target="_blank" rel="noopener">PlantUML主题</a>挑选一些喜欢的主题，使用也非常简单，在<code>startuml</code>之后添加一行即可。</p><blockquote><p>!include <a href="https://raw.githubusercontent.com/bschwarz/puml-themes/master/themes/bluegray/puml-theme-bluegray.puml" target="_blank" rel="noopener">https://raw.githubusercontent.com/bschwarz/puml-themes/master/themes/bluegray/puml-theme-bluegray.puml</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gomonkey</title>
      <link href="2021/04/26/gomonkey/"/>
      <url>2021/04/26/gomonkey/</url>
      
        <content type="html"><![CDATA[<p><code>gomonkey</code>是通过打桩的方式修改函数、方法或者全局变量，来完成单元测试的<code>mock</code>。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/agiledragon/gomonkey/v2</span><br></pre></td></tr></table></figure><h2 id="原理打桩"><a href="#原理打桩" class="headerlink" title="原理打桩"></a>原理打桩</h2><p>运行时打桩是对内存的应用，我们知道程序的函数是在代码段中存储，一个函数的操作对应一个栈帧的存储地址，如果在调用函数时，在一旦访问这个栈帧，我们就使它跳转到我们需要的桩函数去，那么也就实现了函数的打桩。 这种方法要复杂一点，但是不需要对原有的代码进行修改，而是额外增加了打桩和还原的操作，在进行单元测试时也常用。</p><h2 id="Mock函数"><a href="#Mock函数" class="headerlink" title="Mock函数"></a>Mock函数</h2><p>很多时候我们需要获得当前时间戳，我们有<code>GetCurrentTime</code>这样一个函数，我们要<code>mock</code>单元测试，怎么控制这个函数的输出呢？比较方便的做法就是给获取时间戳的函数打桩。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m.go</span></span><br><span class="line"><span class="keyword">package</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentTime</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Now().Unix()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>gomonkey</code>的单元测试</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/agiledragon/gomonkey/v2"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetTime</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">p := gomonkey.ApplyFunc(GetCurrentTime, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> <span class="number">15</span> &#125;)</span><br><span class="line"><span class="keyword">defer</span> p.Reset()</span><br><span class="line"></span><br><span class="line">require.EqualValues(t, <span class="number">15</span>, GetCurrentTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mock全局变量"><a href="#Mock全局变量" class="headerlink" title="Mock全局变量"></a>Mock全局变量</h2><p><code>const</code>是不可取地址的，所以需要用变量定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/agiledragon/gomonkey/v2"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">A = <span class="number">15</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGlobal</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"normal"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">p := gomonkey.ApplyGlobalVar(&amp;A, <span class="number">150</span>)</span><br><span class="line"><span class="keyword">defer</span> p.Reset()</span><br><span class="line">require.Equal(t, A, <span class="number">150</span>)</span><br><span class="line">&#125;)</span><br><span class="line">t.Run(<span class="string">"normal"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">require.Equal(t, A, <span class="number">15</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mock方法"><a href="#Mock方法" class="headerlink" title="Mock方法"></a>Mock方法</h2><p>编写下面的示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/agiledragon/gomonkey/v2"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">B <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGlobal</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b *B</span><br><span class="line">p := gomonkey.ApplyMethod(reflect.TypeOf(b), <span class="string">"Pop"</span>, <span class="function"><span class="keyword">func</span><span class="params">(_ *B)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">defer</span> p.Reset()</span><br><span class="line">fmt.Println(b)</span><br><span class="line">require.Equal(t, <span class="number">0</span>, b.Pop())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go test -v ./...</code>，我们会发现测试失效了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -v ./...             </span><br><span class="line">=== RUN   TestGlobal</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    g_test.<span class="keyword">go</span>:<span class="number">25</span>: </span><br><span class="line">                Error Trace:    g_test.<span class="keyword">go</span>:<span class="number">25</span></span><br><span class="line">                Error:          Not equal: </span><br><span class="line">                                expected: <span class="number">0</span></span><br><span class="line">                                actual  : <span class="number">100</span></span><br><span class="line">                Test:           TestGlobal</span><br><span class="line">--- FAIL: TestGlobal (<span class="number">0.00</span>s)</span><br><span class="line">=== RUN   TestGetTime</span><br><span class="line">--- PASS: TestGetTime (<span class="number">0.00</span>s)</span><br><span class="line">FAIL</span><br><span class="line">FAIL    monkey  <span class="number">0.495</span>s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure><p>原因是<code>gomonkey</code>无法<code>mock</code>内联函数，需要禁用内联命令.</p><p>执行<code>go test -v -gcflags=all=-l  ./...</code>，测试通过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v -gcflags&#x3D;all&#x3D;-l  .&#x2F;...</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestGlobal</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">--- PASS: TestGlobal (0.00s)</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestGetTime</span><br><span class="line">--- PASS: TestGetTime (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      monkey  0.762s</span><br></pre></td></tr></table></figure><p>由于<code>method mock</code>使用的是反射，而私有方法是无法通过反射找到的，所以私有方法无法<code>mock</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> unittest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="2021/04/23/Makefile/"/>
      <url>2021/04/23/Makefile/</url>
      
        <content type="html"><![CDATA[<p>总结下<code>Makefile</code>的常见用法。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>Makefile</code>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;  # prerequisites前置条件</span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们要执行下面的<code>Makefile</code>，运行<code>make name</code>，此时<code>name</code>就是命令执行的目标，它是一个命令的名字，并不是文件，所以它是一个伪目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">name:</span></span><br><span class="line">    echo <span class="string">"z"</span></span><br></pre></td></tr></table></figure><p>当当前路径下刚好有一个<code>name</code>的文件或文件夹时，命令不会执行，并且输出以下的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: &#96;name&#39; is up to date.</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>.PONY</code>声明<code>name</code>是一个伪目标，这样就可以顺利执行了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: name</span></span><br><span class="line"></span><br><span class="line"><span class="section">name:</span></span><br><span class="line">    echo <span class="string">"z"</span></span><br></pre></td></tr></table></figure><p>如果<code>make</code>命令没有附带任何目标，它会自动执行<code>Makefile</code>第一个目标。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>我们给<code>name</code>加上一个<code>prev</code>的前置条件，执行<code>make name</code>，可以发现<code>prev</code>会在执行<code>name</code>之前优先被自动执行。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: name</span></span><br><span class="line"></span><br><span class="line"><span class="section">name: prev</span></span><br><span class="line">echo <span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="section">prev:</span></span><br><span class="line">echo <span class="string">"prev"</span></span><br></pre></td></tr></table></figure><h2 id="常见符号"><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h2><h3 id><a href="#" class="headerlink" title="@"></a>@</h3><p>前面我们执行<code>make</code>的时候会发现执行的命令被自动打印出来了，如果我们不希望打印命令，可以在命令前加上<code>@</code>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: name</span></span><br><span class="line"></span><br><span class="line"><span class="section">name: prev</span></span><br><span class="line">@echo <span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="section">prev:</span></span><br><span class="line">@echo <span class="string">"prev"</span></span><br></pre></td></tr></table></figure><p>这时候就不会输出命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">prev</span><br><span class="line">z</span><br></pre></td></tr></table></figure><h3 id="？通配符"><a href="#？通配符" class="headerlink" title="*,？通配符"></a>*,？通配符</h3><p>通配符用法同<code>shell</code>脚本，常见于文件的匹配。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.pyc</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="% 模式匹配"></a>% 模式匹配</h3><p><code>make</code>通过模式来匹配目标</p><p>下面是一个最简单的示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.c:</span></span><br><span class="line">touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>执行<code>make test.c</code>，会创建<code>test.c</code>文件。</p><p><code>%.o:%.c</code>这种模式能匹配到类似<code>1.o:1.c</code>这种。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><h4 id="指当前目标，make-name中-指的就是name"><a href="#指当前目标，make-name中-指的就是name" class="headerlink" title="$@ 指当前目标，make name中$@指的就是name"></a>$@ 指当前目标，<code>make name</code>中<code>$@</code>指的就是<code>name</code></h4><h4 id="lt-指代第一个前置条件，如make-name中-lt-指的就是prev"><a href="#lt-指代第一个前置条件，如make-name中-lt-指的就是prev" class="headerlink" title="$&lt; 指代第一个前置条件，如make name中$&lt;指的就是prev"></a>$&lt; 指代第一个前置条件，如<code>make name</code>中<code>$&lt;</code>指的就是<code>prev</code></h4><h4 id="指所有前置条件"><a href="#指所有前置条件" class="headerlink" title="$^ 指所有前置条件"></a>$^ 指所有前置条件</h4><h4 id="指向-匹配的部分，如make-test-c中-指的就是test"><a href="#指向-匹配的部分，如make-test-c中-指的就是test" class="headerlink" title="$* 指向%匹配的部分，如make test.c中$*指的就是test"></a>$* 指向%匹配的部分，如<code>make test.c</code>中<code>$*</code>指的就是<code>test</code></h4><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><p>经常编写一个Makefile，粘贴过来，运行就会如下的错误。这个是因为<code>Makefile</code>换行只能用<code>tab</code>，而不能用空格。如果用<code>vim</code>，我们可能配置了<code>:set expandtab</code>，<code>tab</code>自动转换成空格，这时候需要输入命令<code>:set noexpandtab</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Makefile:2: *** missing separator.  Stop.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的官方mock工具——gomock</title>
      <link href="2021/04/20/mockgen/"/>
      <url>2021/04/20/mockgen/</url>
      
        <content type="html"><![CDATA[<p>线上业务的单元测试是非常必要的，自己写接口<code>mock</code>方法多的时候非常麻烦，而<code>mock</code>包是官方提供的接口测试工具，通过<code>generate</code>代码生成的方式非常方便的实现接口的<code>mock</code>测试。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/golang/mock/gomock</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们定义一个最简单的接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate mockgen -package=demo -destination=gen.go gen Demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">interface</span> &#123;</span><br><span class="line">Create(key <span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>go generatge</code> 或者 <code>mockgen -package=demo -destination=gen.go gen Demo</code>。</p><p>执行成功后，会生成<code>gen.go</code>这个文件。</p><p>可以发现，它自动生成了<code>MockDemo</code>这个对象实现了<code>Demo</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MockDemo is a mock of Demo interface.</span></span><br><span class="line"><span class="keyword">type</span> MockDemo <span class="keyword">struct</span> &#123;</span><br><span class="line">ctrl     *gomock.Controller</span><br><span class="line">recorder *MockDemoMockRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h2><p>我们要用<code>MockDemo</code>替换实际的接口，就需要用依赖注入的方式来实现接口的替换。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(d Demo, key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.Create(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建<code>demo_test.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">. <span class="string">"github.com/golang/mock/gomock"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctrl := NewController(t)</span><br><span class="line"><span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line">    <span class="comment">// 新建的mockDemo接口</span></span><br><span class="line">mockDemo := NewMockDemo(ctrl)</span><br><span class="line">testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name        <span class="keyword">string</span></span><br><span class="line">msg         <span class="keyword">string</span></span><br><span class="line">expectedErr error</span><br><span class="line">expectedRes <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name:        <span class="string">"1"</span>,</span><br><span class="line">msg:         <span class="string">"a1"</span>,</span><br><span class="line">expectedErr: <span class="literal">nil</span>,</span><br><span class="line">expectedRes: <span class="string">"a1"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:        <span class="string">"2"</span>,</span><br><span class="line">msg:         <span class="string">"a2"</span>,</span><br><span class="line">expectedErr: <span class="literal">nil</span>,</span><br><span class="line">expectedRes: <span class="string">"a2"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 指定Mock接口Create方法返回值</span></span><br><span class="line">mockDemo.EXPECT().Create(tt.msg).Return(tt.msg, <span class="literal">nil</span>)</span><br><span class="line">r, err := Get(mockDemo, tt.msg)</span><br><span class="line">require.Equal(t, tt.expectedErr, err)</span><br><span class="line">require.Equal(t, tt.expectedRes, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gogoproto</title>
      <link href="2021/03/20/gogoproto/"/>
      <url>2021/03/20/gogoproto/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(36)--etcd源码阅读-raft</title>
      <link href="2021/03/13/etcd-3/"/>
      <url>2021/03/13/etcd-3/</url>
      
        <content type="html"><![CDATA[<p><code>raft</code>是近年来最流行的一致性算法,好好研究一下<code>raft</code>在<code>etcd</code>中是如何实现的。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> etcd </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(35)--etcd源码阅读-mvcc</title>
      <link href="2021/02/05/etcd-2/"/>
      <url>2021/02/05/etcd-2/</url>
      
        <content type="html"><![CDATA[<p>数据库通常运行在高并发环境下，通常解决冲突的办法有悲观锁和乐观锁，<code>MVCC（Multi-version Cocurrent Control 多版本并发控制)</code>是一个比较常见的乐观锁实现机制。<code>etcd</code>正是通过<code>mvcc</code>来实现事务管理中数据隔离。</p><a id="more"></a><h2 id="revision"><a href="#revision" class="headerlink" title="revision"></a>revision</h2><p><code>revision</code>就是<code>etcd</code>中的版本，每次<code>key-value</code>的操作都会有一个相应的 <code>revision</code>。</p><p><code>revision</code>由<code>main</code>和<code>sub</code>两部分<code>int64</code>字段组成。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A revision indicates modification of the key-value space.</span></span><br><span class="line"><span class="comment">// The set of changes that share same main revision changes the key-value space atomically.</span></span><br><span class="line"><span class="keyword">type</span> revision <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// main is the main revision of a set of changes that happen atomically.</span></span><br><span class="line">main <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sub is the sub revision of a change in a set of changes that happen</span></span><br><span class="line"><span class="comment">// atomically. Each change has different increasing sub revision in that</span></span><br><span class="line"><span class="comment">// set.</span></span><br><span class="line">sub <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>revisions</code>是<code>revision</code>数组，实现了<code>sor.Sorter</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> revisions []revision</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a revisions)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a revisions)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[j].GreaterThan(a[i]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a revisions)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br></pre></td></tr></table></figure><h2 id="keyIndex"><a href="#keyIndex" class="headerlink" title="keyIndex"></a>keyIndex</h2><p><code>keyIndex</code>存储了<code>key</code>的所有版本。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keyIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">key         []<span class="keyword">byte</span></span><br><span class="line">modified    revision <span class="comment">// 最后的版本</span></span><br><span class="line">generations []generation <span class="comment">// 历史版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keyIndex</code>实现了google的<code>btree</code>模块中的<code>Item</code>接口，因此它可以作为<code>B树</code>的节点。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item represents a single object in the tree.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Less tests whether the current item is less than the given argument.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must provide a strict weak ordering.</span></span><br><span class="line"><span class="comment">// If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (i.e. we can only</span></span><br><span class="line"><span class="comment">// hold one of either a or b in the tree).</span></span><br><span class="line">Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *keyIndex)</span> <span class="title">Less</span><span class="params">(b btree.Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.Compare(a.key, b.(*keyIndex).key) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="treeIndex"><a href="#treeIndex" class="headerlink" title="treeIndex"></a>treeIndex</h2><p>首先定义了<code>index</code>这个接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> index <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key []<span class="keyword">byte</span>, atRev <span class="keyword">int64</span>) (rev, created revision, ver <span class="keyword">int64</span>, err error)</span><br><span class="line">Range(key, end []<span class="keyword">byte</span>, atRev <span class="keyword">int64</span>) ([][]<span class="keyword">byte</span>, []revision)</span><br><span class="line">Revisions(key, end []<span class="keyword">byte</span>, atRev <span class="keyword">int64</span>, limit <span class="keyword">int</span>) []revision</span><br><span class="line">CountRevisions(key, end []<span class="keyword">byte</span>, atRev <span class="keyword">int64</span>, limit <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">Put(key []<span class="keyword">byte</span>, rev revision)</span><br><span class="line">Tombstone(key []<span class="keyword">byte</span>, rev revision) error</span><br><span class="line">RangeSince(key, end []<span class="keyword">byte</span>, rev <span class="keyword">int64</span>) []revision</span><br><span class="line">Compact(rev <span class="keyword">int64</span>) <span class="keyword">map</span>[revision]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Keep(rev <span class="keyword">int64</span>) <span class="keyword">map</span>[revision]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Equal(b index) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">Insert(ki *keyIndex)</span><br><span class="line">KeyIndex(ki *keyIndex) *keyIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>treeIndex</code>是<code>index</code>接口的实现，从源码上看，它其实就是一棵<code>B树</code>，树的每个节点就是一个<code>keyIndex</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> treeIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.RWMutex</span><br><span class="line">tree *btree.BTree</span><br><span class="line">lg   *zap.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(35)--etcd源码阅读-lease</title>
      <link href="2021/02/04/etcd-1/"/>
      <url>2021/02/04/etcd-1/</url>
      
        <content type="html"><![CDATA[<p><code>etcd</code>是一种开源的分布式统一键值存储数据库，用于分布式系统或计算机集群的共享配置、服务发现和的调度协调。etcd 有助于促进更加安全的自动更新，协调向主机调度的工作，并帮助设置容器的覆盖网络。它已经广泛用于云原生各大项目中。现在来学习一下它的源码实现。</p><a id="more"></a><p>源码<code>github</code>地址，<a href="https://github.com/etcd-io/etcd。" target="_blank" rel="noopener">https://github.com/etcd-io/etcd。</a></p><p>下载源码后，可以看到<code>etcd</code>项目结构非常清晰。</p><p>首先从<code>server</code>包开始阅读。</p><h2 id="lease"><a href="#lease" class="headerlink" title="lease"></a>lease</h2><p><code>lease</code>包位于<code>etcd\sever</code>目录下。</p><p><code>lease</code>中文是租约，类似于<code>redis</code>中的<code>TTL(Time To Live)</code>，用于实现过期时间。</p><p><code>Lease</code>源码的定义如下,<code>Lease</code>结构体中<code>ID</code>是一个<code>int64</code>的标识，<code>ttl</code>是过期时间，<code>remainingTTL</code>是剩余过期时间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lease <span class="keyword">struct</span> &#123;</span><br><span class="line">ID           LeaseID <span class="comment">// type LeaseID int64</span></span><br><span class="line">ttl          <span class="keyword">int64</span> <span class="comment">// time to live of the lease in seconds</span></span><br><span class="line">remainingTTL <span class="keyword">int64</span> <span class="comment">// remaining time to live in seconds, if zero valued it is considered unset and the full ttl should be used</span></span><br><span class="line"><span class="comment">// expiryMu protects concurrent accesses to expiry</span></span><br><span class="line">expiryMu sync.RWMutex</span><br><span class="line"><span class="comment">// expiry is time when lease should expire. no expiration when expiry.IsZero() is true</span></span><br><span class="line">expiry time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// mu protects concurrent accesses to itemSet</span></span><br><span class="line">mu      sync.RWMutex</span><br><span class="line">itemSet <span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">revokec <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Remaining</code>方法用于计算剩余过期时间，从源码上可以看出，<code>expiry</code>字段用于计算是否过期，当它为零时即永不过期。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remaining returns the remaining time of the lease.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lease)</span> <span class="title">Remaining</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">l.expiryMu.RLock()</span><br><span class="line"><span class="keyword">defer</span> l.expiryMu.RUnlock()</span><br><span class="line"><span class="keyword">if</span> l.expiry.IsZero() &#123;</span><br><span class="line"><span class="keyword">return</span> time.Duration(math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Until(l.expiry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>persistTo</code>是<code>Lease</code>持久化的方法，接收参数<code>b backend.Backend</code>和<code>ci cindex.ConsistentIndexer</code>都是接口，因此<code>Lease</code>能够支持不同的存储。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lease)</span> <span class="title">persistTo</span><span class="params">(b backend.Backend, ci cindex.ConsistentIndexer)</span></span> &#123;</span><br><span class="line">key := int64ToBytes(<span class="keyword">int64</span>(l.ID))</span><br><span class="line"></span><br><span class="line">lpb := leasepb.Lease&#123;ID: <span class="keyword">int64</span>(l.ID), TTL: l.ttl, RemainingTTL: l.remainingTTL&#125;</span><br><span class="line">val, err := lpb.Marshal()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"failed to marshal lease proto item"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.BatchTx().Lock()</span><br><span class="line">b.BatchTx().UnsafePut(leaseBucketName, key, val)</span><br><span class="line"><span class="keyword">if</span> ci != <span class="literal">nil</span> &#123;</span><br><span class="line">ci.UnsafeSave(b.BatchTx())</span><br><span class="line">&#125;</span><br><span class="line">b.BatchTx().Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lessor"><a href="#Lessor" class="headerlink" title="Lessor"></a>Lessor</h2><p><code>Lessor</code>可以理解成房东，它是<code>lease</code>的管理者</p><p><code>Lessor</code>定义是一个接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lessor owns leases. It can grant, revoke, renew and modify leases for lessee.</span></span><br><span class="line"><span class="keyword">type</span> Lessor <span class="keyword">interface</span> &#123;</span><br><span class="line">SetRangeDeleter(rd RangeDeleter)</span><br><span class="line">SetCheckpointer(cp Checkpointer)</span><br><span class="line">Revoke(id LeaseID) error</span><br><span class="line">Checkpoint(id LeaseID, remainingTTL <span class="keyword">int64</span>) error</span><br><span class="line">Attach(id LeaseID, items []LeaseItem) error</span><br><span class="line">GetLease(item LeaseItem) LeaseID</span><br><span class="line">Detach(id LeaseID, items []LeaseItem) error</span><br><span class="line">Promote(extend time.Duration)</span><br><span class="line">Demote()</span><br><span class="line">Renew(id LeaseID) (<span class="keyword">int64</span>, error)</span><br><span class="line">Lookup(id LeaseID) *Lease</span><br><span class="line">Leases() []*Lease</span><br><span class="line">ExpiredLeasesC() &lt;-<span class="keyword">chan</span> []*Lease</span><br><span class="line">Recover(b backend.Backend, rd RangeDeleter)</span><br><span class="line">Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lessor</code>是<code>Lessor</code>接口的实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> lessor <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex</span><br><span class="line"></span><br><span class="line">demotec <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 租约存储</span></span><br><span class="line">  leaseMap             <span class="keyword">map</span>[LeaseID]*Lease</span><br><span class="line">  <span class="comment">// 租约过期通知组件</span></span><br><span class="line">  leaseExpiredNotifier *LeaseExpiredNotifier</span><br><span class="line">  <span class="comment">// LeaseQueue是一个最小堆，用于获取当前过期的租约</span></span><br><span class="line">leaseCheckpointHeap  LeaseQueue</span><br><span class="line">itemMap              <span class="keyword">map</span>[LeaseItem]LeaseID</span><br><span class="line"></span><br><span class="line">rd RangeDeleter</span><br><span class="line">  <span class="comment">// 确保 etcd 集群切换leader 后lease ttl 的准确计算</span></span><br><span class="line">cp Checkpointer</span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">b backend.Backend</span><br><span class="line"></span><br><span class="line">minLeaseTTL <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">expiredC <span class="keyword">chan</span> []*Lease</span><br><span class="line">stopC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">doneC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">lg *zap.Logger</span><br><span class="line"></span><br><span class="line">checkpointInterval time.Duration</span><br><span class="line">expiredLeaseRetryInterval time.Duration</span><br><span class="line">ci                        cindex.ConsistentIndexer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeaseQueue"><a href="#LeaseQueue" class="headerlink" title="LeaseQueue"></a>LeaseQueue</h2><p><code>Lessor</code>管理租约，需要定期清理过期的租约，当租约数量少的时候线性查找性能还不是问题，随着租约规模扩大淘汰过期租约就会成为瓶颈性能，堆这种优先队列是最好的解决办法。</p><p><code>LeaseWithTime</code>是最小堆的元素，结构体中包含了每个租约的过期时间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaseWithTime <span class="keyword">struct</span> &#123;</span><br><span class="line">id    LeaseID</span><br><span class="line">time  time.Time <span class="comment">// 过期时间</span></span><br><span class="line">index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LeaseQueue</code>也是通过实现标准库中<code>container/heap</code>包中的<code>Interface</code>实现堆。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaseQueue []*LeaseWithTime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq LeaseQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq LeaseQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> pq[i].time.Before(pq[j].time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq LeaseQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = i</span><br><span class="line">pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *LeaseQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*LeaseWithTime)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *LeaseQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了堆实现过期查找就非常容易了，只需要不断的检查堆顶元素是否过期即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expireExists returns true if expiry items exist.</span></span><br><span class="line"><span class="comment">// It pops only when expiry item exists.</span></span><br><span class="line"><span class="comment">// "next" is true, to indicate that it may exist in next attempt.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span> <span class="title">expireExists</span><span class="params">()</span> <span class="params">(l *Lease, ok <span class="keyword">bool</span>, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> le.leaseExpiredNotifier.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item := le.leaseExpiredNotifier.Poll()</span><br><span class="line">l = le.leaseMap[item.id]</span><br><span class="line"><span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// lease has expired or been revoked</span></span><br><span class="line"><span class="comment">// no need to revoke (nothing is expiry)</span></span><br><span class="line">le.leaseExpiredNotifier.Unregister() <span class="comment">// O(log N)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="keyword">if</span> now.Before(item.time) <span class="comment">/* item.time: expiration time */</span> &#123;</span><br><span class="line"><span class="comment">// Candidate expirations are caught up, reinsert this item</span></span><br><span class="line"><span class="comment">// and no need to revoke (nothing is expiry)</span></span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recheck if revoke is complete after retry interval</span></span><br><span class="line">item.time = now.Add(le.expiredLeaseRetryInterval)</span><br><span class="line">le.leaseExpiredNotifier.RegisterOrUpdate(item)</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span> <span class="title">findDueScheduledCheckpoints</span><span class="params">(checkpointLimit <span class="keyword">int</span>)</span> []*<span class="title">pb</span>.<span class="title">LeaseCheckpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> le.cp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">cps := []*pb.LeaseCheckpoint&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> le.leaseCheckpointHeap.Len() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(cps) &lt; checkpointLimit &#123;</span><br><span class="line">    <span class="comment">// 检查顶项元素是否过期，过过期直接返回</span></span><br><span class="line">lt := le.leaseCheckpointHeap[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> lt.time.After(now) <span class="comment">/* lt.time: next checkpoint time */</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cps</span><br><span class="line">&#125;</span><br><span class="line">heap.Pop(&amp;le.leaseCheckpointHeap)</span><br><span class="line"><span class="keyword">var</span> l *Lease</span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> l, ok = le.leaseMap[lt.id]; !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !now.Before(l.expiry) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">remainingTTL := <span class="keyword">int64</span>(math.Ceil(l.expiry.Sub(now).Seconds()))</span><br><span class="line"><span class="keyword">if</span> remainingTTL &gt;= l.ttl &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> le.lg != <span class="literal">nil</span> &#123;</span><br><span class="line">le.lg.Debug(<span class="string">"Checkpointing lease"</span>,</span><br><span class="line">zap.Int64(<span class="string">"leaseID"</span>, <span class="keyword">int64</span>(lt.id)),</span><br><span class="line">zap.Int64(<span class="string">"remainingTTL"</span>, remainingTTL),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">cps = <span class="built_in">append</span>(cps, &amp;pb.LeaseCheckpoint&#123;ID: <span class="keyword">int64</span>(lt.id), Remaining_TTL: remainingTTL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeaseExpiredNotifier"><a href="#LeaseExpiredNotifier" class="headerlink" title="LeaseExpiredNotifier"></a>LeaseExpiredNotifier</h2><p><code>LeaseExpiredNotifier</code>是一个租约过期通知组件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaseExpiredNotifier <span class="keyword">struct</span> &#123;</span><br><span class="line">m     <span class="keyword">map</span>[LeaseID]*LeaseWithTime</span><br><span class="line">queue LeaseQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到的<code>expireExists</code>方法即是通过<code>LeaseExpiredNotifier</code>中的堆<code>LeaseQueue</code>来实现的。</p><p><code>LeaseExpiredNotifier</code>的<code>Unregister</code>方法即为堆的<code>Pop</code>，<code>RegisterOrUpdate</code>则完成的是堆的修改或插入。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *LeaseExpiredNotifier)</span> <span class="title">RegisterOrUpdate</span><span class="params">(item *LeaseWithTime)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> old, ok := mq.m[item.id]; ok &#123;</span><br><span class="line">old.time = item.time</span><br><span class="line">heap.Fix(&amp;mq.queue, old.index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">heap.Push(&amp;mq.queue, item)</span><br><span class="line">mq.m[item.id] = item</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *LeaseExpiredNotifier)</span> <span class="title">Unregister</span><span class="params">()</span> *<span class="title">LeaseWithTime</span></span> &#123;</span><br><span class="line">item := heap.Pop(&amp;mq.queue).(*LeaseWithTime)</span><br><span class="line"><span class="built_in">delete</span>(mq.m, item.id)</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p><code>newLessor</code>方法在新建<code>lessor</code>之后会起一个<code>goroutine</code>循环检查租约。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLessor</span><span class="params">(lg *zap.Logger, b backend.Backend, cfg LessorConfig, ci cindex.ConsistentIndexer)</span> *<span class="title">lessor</span></span> &#123;</span><br><span class="line">checkpointInterval := cfg.CheckpointInterval</span><br><span class="line">expiredLeaseRetryInterval := cfg.ExpiredLeasesRetryInterval</span><br><span class="line"><span class="keyword">if</span> checkpointInterval == <span class="number">0</span> &#123;</span><br><span class="line">checkpointInterval = defaultLeaseCheckpointInterval</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> expiredLeaseRetryInterval == <span class="number">0</span> &#123;</span><br><span class="line">expiredLeaseRetryInterval = defaultExpiredleaseRetryInterval</span><br><span class="line">&#125;</span><br><span class="line">l := &amp;lessor&#123;</span><br><span class="line">leaseMap:                  <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseID]*Lease),</span><br><span class="line">itemMap:                   <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]LeaseID),</span><br><span class="line">leaseExpiredNotifier:      newLeaseExpiredNotifier(),</span><br><span class="line">leaseCheckpointHeap:       <span class="built_in">make</span>(LeaseQueue, <span class="number">0</span>),</span><br><span class="line">b:                         b,</span><br><span class="line">minLeaseTTL:               cfg.MinLeaseTTL,</span><br><span class="line">checkpointInterval:        checkpointInterval,</span><br><span class="line">expiredLeaseRetryInterval: expiredLeaseRetryInterval,</span><br><span class="line"><span class="comment">// 收集失效的租约，缓冲长度16，避免堵塞</span></span><br><span class="line">expiredC: <span class="built_in">make</span>(<span class="keyword">chan</span> []*Lease, <span class="number">16</span>),</span><br><span class="line">stopC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">doneC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">lg:       lg,</span><br><span class="line">ci:       ci,</span><br><span class="line">&#125;</span><br><span class="line">l.initAndRecover()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> l.runLoop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>500毫秒一次循环检查并撤销过期租约，最后失效的租约都会写入<code>expiredC</code>这个channel中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span> <span class="title">runLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(le.doneC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">le.revokeExpiredLeases()</span><br><span class="line">le.checkpointScheduledLeases()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line"><span class="keyword">case</span> &lt;-le.stopC:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// revokeExpiredLeases finds all leases past their expiry and sends them to expired channel for</span></span><br><span class="line"><span class="comment">// to be revoked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span> <span class="title">revokeExpiredLeases</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ls []*Lease</span><br><span class="line"></span><br><span class="line"><span class="comment">// rate limit</span></span><br><span class="line">revokeLimit := leaseRevokeRate / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">le.mu.RLock()</span><br><span class="line"><span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">ls = le.findExpiredLeases(revokeLimit)</span><br><span class="line">&#125;</span><br><span class="line">le.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ls) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-le.stopC:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> le.expiredC &lt;- ls:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// the receiver of expiredC is probably busy handling</span></span><br><span class="line"><span class="comment">// other stuff</span></span><br><span class="line"><span class="comment">// let's try this next time after 500ms</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpointScheduledLeases finds all scheduled lease checkpoints that are due and</span></span><br><span class="line"><span class="comment">// submits them to the checkpointer to persist them to the consensus log.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span> <span class="title">checkpointScheduledLeases</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> cps []*pb.LeaseCheckpoint</span><br><span class="line"></span><br><span class="line"><span class="comment">// rate limit</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; leaseCheckpointRate/<span class="number">2</span>; i++ &#123;</span><br><span class="line">le.mu.Lock()</span><br><span class="line"><span class="comment">// 主节点</span></span><br><span class="line"><span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">cps = le.findDueScheduledCheckpoints(maxLeaseCheckpointBatchSize)</span><br><span class="line">&#125;</span><br><span class="line">le.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cps) != <span class="number">0</span> &#123;</span><br><span class="line">le.cp(context.Background(), &amp;pb.LeaseCheckpointRequest&#123;Checkpoints: cps&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cps) &lt; maxLeaseCheckpointBatchSize &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>身份认证器简化使用</title>
      <link href="2021/02/02/google-authenticator/"/>
      <url>2021/02/02/google-authenticator/</url>
      
        <content type="html"><![CDATA[<p>很多网站登录都接入了谷歌身份验证器，手机验证虽然很安全，但是也很麻烦，如果能在电脑上获取就能大大简化登录。</p><a id="more"></a><p>谷歌身份验证器最早是谷歌为了减少 Gmail 邮箱遭受恶意攻击而推出的两步验证方式，后来被很多网站支持。使用谷歌身份验证器，可以避免比如不久前发生的 Coinbase 短信二次验证导致的安全事故。开启谷歌身份验证之后，登录账户，除了输入用户名和密码，还需要输入谷歌验证器上的动态密码。</p><p>谷歌验证器上的动态密码，也称为一次性密码，密码按照时间或使用次数不断动态变化（默认 30 秒变更一次）。它和很多银行发行的动态口令卡类似，可以断网使用，只不过前者是谷歌推出的一个 App，后者是专门的一个硬件。</p><h2 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h2><p>基本上互联网圈都是用的<code>Chrome</code>，我们只需要下载<code>身份认证器</code>这个插件即可。</p><p>打开<code>Chrome</code>商店，搜索<code>身份认证器</code></p><p><img src="https://pic.hupai.pro/img/20210202133142.png" alt></p><p>安装即可。</p><p>安装完成后，在账号绑定界面点击扫码即可。</p><p><img src="https://pic.hupai.pro/img/20210202133252.png" alt></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>我们在绑定时看到的二维码，实际上是这样的一串内容,<code>xx@gmail.com</code>表示账号名，<code>DDD</code>表示的是加密密钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otpauth:&#x2F;&#x2F;totp&#x2F;xx@gmail.com?secret&#x3D;DDD</span><br></pre></td></tr></table></figure><p>客户端每30秒使用密钥『DDD』和时间戳通过一种『算法』生成一个6位数字的一次性密码，如『684060』。</p><p>这个算法叫<code>OTP</code>。</p><ol><li>OTP<br>OTP(One-Time Password)译为一次性密码，也称动态口令。是使用密码技术实现的在客户端和服务器之间通过共享秘密的一种认证技术，是一种强认证技术，是增强目前静态口令认证的一种非常方便技术手段，是一种重要的双因素认证技术。</li></ol><p>1.1 OTP的认证原理<br>动态口令的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值、或者是异步挑战数进行密码算法计算，使用的算法有对称算法、HASH、HMAC，之后比较计算值是否一致进行认证。可以做到一次一个动态口令，使用后作废，口令长度通常为6-8个数字，使用方便，与通常的静态口令认证方式类似.</p><p>1.3 OTP的实现方式<br>时间同步(TOTP)<br>事件同步(HOTP)<br>挑战/应答(OCRA)</p><p>Google身份认证器使用的是<code>HOTP(HMAC-base On-Time Password)</code>译为基于HMAC的一次性密码，也称事件同步的动态密码。</p><p>如之前的插件就是<code>javascript</code>语言的实现。<a href="https://github.com/Authenticator-Extension/Authenticator" target="_blank" rel="noopener">插件地址</a></p><p><code>oath-toolkit</code>这个工具也实现了<code>OTP</code>相关算法，它的<a href="https://www.nongnu.org/oath-toolkit/" target="_blank" rel="noopener">官网</a></p><p><code>mac</code>下安装非常简单，<code>brew install oath-toolkit</code>。</p><p>安装完成后，执行命令<code>oathtool -b --totp &#39;private_key&#39;</code>，注意这个<code>private_key</code>是可以通过手机扫绑定时提供的二维码拿到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 5YTCB6SOBTYDCOG为密钥</span><br><span class="line">$ oathtool --totp -b 5YTCB6SOBTYDCOG</span><br><span class="line">624309</span><br></pre></td></tr></table></figure><p>可以在<code>~/.bashrc</code>里添加<code>alias pd=&#39;echo &quot;$(oathtool --totp -b 5YTCB6SOBTYDCOG)\c&quot; | pbcopy&#39;</code></p><p>然后就可以通过运行<code>pd</code>，直接将生成的<code>code</code>写入系统粘贴板。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python(3)——协程</title>
      <link href="2021/02/01/python-coroutine/"/>
      <url>2021/02/01/python-coroutine/</url>
      
        <content type="html"><![CDATA[<p><code>Python</code>协程已经出了很多个版本了，这篇好好总结一下协程的用法。</p><a id="more"></a><p>首先我们需要知道的是使用了协程，还是用不了多核，它解决了还是<code>IO</code>的问题。</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>通过<code>async/await</code>关键字声明是官方推荐的协程使用方式。</p><p>看一个最简单的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(main())</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># &lt;coroutine object main at 0x103d69c40&gt;</span></span><br><span class="line"><span class="comment"># started at 17:47:49</span></span><br><span class="line"><span class="comment"># /Users/zs/projects/yunzhanghu/python/demo/main.py:17: RuntimeWarning: coroutine 'main' was never awaited</span></span><br><span class="line"><span class="comment">#   print(main())</span></span><br><span class="line"><span class="comment"># RuntimeWarning: Enable tracemalloc to get the object allocation traceback</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># finished at 17:47:52</span></span><br></pre></td></tr></table></figure><p><code>main</code>函数前添加了关键字<code>async</code>，变成了<code>Coroutines</code>对象。因此<code>main</code>函数需要在<code>asyncio.run</code>中才能执行。</p><h2 id="Awaitables"><a href="#Awaitables" class="headerlink" title="Awaitables"></a>Awaitables</h2><p><code>await</code>关键字后面只能跟<code>Awaitables object</code>，有三个主要的类型。</p><h3 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h3><p><code>Coroutines</code>即协程，协程之间是可以相互<code>await</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Nothing happens if we just call "nested()".</span></span><br><span class="line">    <span class="comment"># A coroutine object is created but not awaited,</span></span><br><span class="line">    <span class="comment"># so it *won't run at all*.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's do it differently now and await it:</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())  <span class="comment"># will print "42".</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p><code>Tasks</code>是用于<code>Coroutines</code>调度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with "main()".</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># "task" can now be used to cancel "nested()", or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h3><p> <code>Futures</code>代表的是协程任务的最终结果。</p><p> 通常协程相关的库及相关异步API都会以<code>Futures</code>对象的形式暴露给外界使用。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># this is also valid:</span></span><br><span class="line">   <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">       function_that_returns_a_future_object(),</span><br><span class="line">       some_python_coroutine()</span><br><span class="line">   )</span><br></pre></td></tr></table></figure><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>通常我们使用协程的时候需要<code>Sleep</code>也只是希望当前协程<code>Sleep</code>，这个时候可以用<code>asyncio.sleep</code>这个API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure><h2 id="Running-Tasks-Concurrently"><a href="#Running-Tasks-Concurrently" class="headerlink" title="Running Tasks Concurrently"></a>Running Tasks Concurrently</h2><p>如果我们需要并发跑多个任务，可以用<code>asyncio.gather</code>，这个函数接收多个<code>Awaitables</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure><h2 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><p>我们可以用<code>asyncio.wait_for</code>来给每个异步任务设置一个过期时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h2><p><code>Task</code>是可以<code>cancel</code>的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel_me</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cancel_me(): before sleep'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">'cancel_me(): cancel sleep'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'cancel_me(): after sleep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a "cancel_me" Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">"main(): cancel_me is cancelled now"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment">#  output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure><p><code>shield</code>可以保护<code>aswitable object</code>不被取消。当然它自身也是可能被取消的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保护任务不被取消</span></span><br><span class="line">res = <span class="keyword">await</span> shield(something())</span><br><span class="line"></span><br><span class="line"><span class="comment"># shield 也可能被取消</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    res = <span class="keyword">await</span> shield(something())</span><br><span class="line"><span class="keyword">except</span> CancelledError:</span><br><span class="line">    res = <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(34)--quicktemplate源码分析</title>
      <link href="2021/01/27/go-quick-template/"/>
      <url>2021/01/27/go-quick-template/</url>
      
        <content type="html"><![CDATA[<p>平时工作生活中难免需要用到代码模板，对比标准库，<code>quicktemplate</code>最大优势就是模板被编译为单个二进制文件，因此无需将模板文件复制到服务器。</p><a id="more"></a><h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/valyala/quicktemplate</span><br><span class="line">go get -u github.com/valyala/quicktemplate/qtc</span><br></pre></td></tr></table></figure><p>编写一个模板文件<code>hello.qtpl</code>,放在<code>templates</code>目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">All text outside function templates is treated as comments,</span><br><span class="line">i.e. it is just ignored by quicktemplate compiler (&#96;qtc&#96;). It is for humans.</span><br><span class="line"></span><br><span class="line">Hello is a simple template function.</span><br><span class="line">&#123;% func Hello(name string) %&#125;</span><br><span class="line">Hello, &#123;%s name %&#125;!</span><br><span class="line">&#123;% endfunc %&#125;</span><br></pre></td></tr></table></figure><p>运行<code>qtc</code>，<code>templates</code>目录下会生成一个<code>hello.qtpl.go</code>文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templates</span><br><span class="line"></span><br><span class="line"><span class="comment">//line templates/hello.qtpl:5</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">qtio422016 <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line">qt422016 <span class="string">"github.com/valyala/quicktemplate"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//line templates/hello.qtpl:5</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_ = qtio422016.Copy</span><br><span class="line">_ = qt422016.AcquireByteBuffer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//line templates/hello.qtpl:5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StreamHello</span><span class="params">(qw422016 *qt422016.Writer, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:5</span></span><br><span class="line">qw422016.N().S(<span class="string">`</span></span><br><span class="line"><span class="string">Hello, `</span>)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:6</span></span><br><span class="line">qw422016.E().S(name)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:6</span></span><br><span class="line">qw422016.N().S(<span class="string">`!</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteHello</span><span class="params">(qq422016 qtio422016.Writer, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">qw422016 := qt422016.AcquireWriter(qq422016)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">StreamHello(qw422016, name)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">qt422016.ReleaseWriter(qw422016)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">qb422016 := qt422016.AcquireByteBuffer()</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">WriteHello(qb422016, name)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">qs422016 := <span class="keyword">string</span>(qb422016.B)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">qt422016.ReleaseByteBuffer(qb422016)</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line"><span class="keyword">return</span> qs422016</span><br><span class="line"><span class="comment">//line templates/hello.qtpl:7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接调用<code>templates</code>包中的<code>Hello</code>方法了。</p><h2 id="QWriter"><a href="#QWriter" class="headerlink" title="QWriter"></a>QWriter</h2><p><code>QWriter</code>实现了<code>Writer</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWriter is auxiliary writer used by Writer.</span></span><br><span class="line"><span class="keyword">type</span> QWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">w   io.Writer</span><br><span class="line">err error</span><br><span class="line">b   []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QWriter</code>通过<code>strconv</code>包实现了<code>float</code>、<code>int</code>等类型的高效转换写入，避免了大量的内存分配。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F writes f to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *QWriter)</span> <span class="title">F</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">n := <span class="keyword">int</span>(f)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">float64</span>(n) == f &#123;</span><br><span class="line"><span class="comment">// Fast path - just int.</span></span><br><span class="line">w.D(n)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slow path.</span></span><br><span class="line">w.FPrec(f, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>float64</code>类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FPrec writes f to w using the given floating point precision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *QWriter)</span> <span class="title">FPrec</span><span class="params">(f <span class="keyword">float64</span>, prec <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">bb, ok := w.w.(*ByteBuffer)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">bb.B = strconv.AppendFloat(bb.B, f, <span class="string">'f'</span>, prec, <span class="number">64</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.b = strconv.AppendFloat(w.b[:<span class="number">0</span>], f, <span class="string">'f'</span>, prec, <span class="number">64</span>)</span><br><span class="line">w.Write(w.b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int</code>类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D writes n to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *QWriter)</span> <span class="title">D</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">bb, ok := w.w.(*ByteBuffer)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">bb.B = strconv.AppendInt(bb.B, <span class="keyword">int64</span>(n), <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.b = strconv.AppendInt(w.b[:<span class="number">0</span>], <span class="keyword">int64</span>(n), <span class="number">10</span>)</span><br><span class="line">w.Write(w.b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string与-byte"><a href="#string与-byte" class="headerlink" title="string与[]byte"></a>string与[]byte</h2><p>通过<code>unsafe</code>包实现了,<code>string</code>与<code>[]byte</code>零内存分配的转换。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeStrToBytes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">bh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span><br><span class="line">bh.Data = sh.Data</span><br><span class="line">bh.Len = sh.Len</span><br><span class="line">bh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeBytesToStr</span><span class="params">(z []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;z))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(33)--框架beego源码阅读(2)</title>
      <link href="2021/01/22/golang-beego2/"/>
      <url>2021/01/22/golang-beego2/</url>
      
        <content type="html"><![CDATA[<p>这期看下<code>beego</code>服务及路由相关的源码实现。</p><a id="more"></a><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><code>Server</code>结构体定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">*http.Server  <span class="comment">// 继承标准库的http.Server</span></span><br><span class="line">ln           net.Listener</span><br><span class="line">SignalHooks  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[os.Signal][]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">sigChan      <span class="keyword">chan</span> os.Signal</span><br><span class="line">isChild      <span class="keyword">bool</span></span><br><span class="line">state        <span class="keyword">uint8</span></span><br><span class="line">Network      <span class="keyword">string</span></span><br><span class="line">terminalChan <span class="keyword">chan</span> error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SignalHooks</code>允许自定义处理拦截的信号。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterSignalHook registers a function to be run PreSignal or PostSignal for a given signal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">RegisterSignalHook</span><span class="params">(ppFlag <span class="keyword">int</span>, sig os.Signal, f <span class="keyword">func</span>()</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ppFlag != PreSignal &amp;&amp; ppFlag != PostSignal &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"Invalid ppFlag argument. Must be either grace.PreSignal or grace.PostSignal"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> hookableSignals &#123;</span><br><span class="line"><span class="keyword">if</span> s == sig &#123;</span><br><span class="line">srv.SignalHooks[ppFlag][sig] = <span class="built_in">append</span>(srv.SignalHooks[ppFlag][sig], f)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">err = fmt.Errorf(<span class="string">"Signal '%v' is not supported"</span>, sig)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截系统信号，实现<code>graceful</code>退出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleSignals listens for os Signals and calls any hooked in function that the</span></span><br><span class="line"><span class="comment">// user had registered with the signal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">handleSignals</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sig os.Signal</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听相关信号</span></span><br><span class="line">signal.Notify(</span><br><span class="line">srv.sigChan,</span><br><span class="line">hookableSignals...,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pid := syscall.Getpid()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sig = &lt;-srv.sigChan</span><br><span class="line">    <span class="comment">// 执行退出之前处理操作</span></span><br><span class="line">srv.signalHooks(PreSignal, sig)</span><br><span class="line"><span class="keyword">switch</span> sig &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">log.Println(pid, <span class="string">"Received SIGHUP. forking."</span>)</span><br><span class="line">err := srv.fork()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"Fork err:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGINT:</span><br><span class="line">log.Println(pid, <span class="string">"Received SIGINT."</span>)</span><br><span class="line">srv.shutdown()</span><br><span class="line"><span class="keyword">case</span> syscall.SIGTERM:</span><br><span class="line">log.Println(pid, <span class="string">"Received SIGTERM."</span>)</span><br><span class="line">srv.shutdown()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Printf(<span class="string">"Received %v: nothing i care about...\n"</span>, sig)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行退出后的操作</span></span><br><span class="line">srv.signalHooks(PostSignal, sig)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>路由是由<code>ControllerRegister</code>管理的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ControllerRegister containers registered router rules, controller handlers and filters.</span></span><br><span class="line"><span class="keyword">type</span> ControllerRegister <span class="keyword">struct</span> &#123;</span><br><span class="line">routers      <span class="keyword">map</span>[<span class="keyword">string</span>]*Tree </span><br><span class="line">enablePolicy <span class="keyword">bool</span></span><br><span class="line">policies     <span class="keyword">map</span>[<span class="keyword">string</span>]*Tree</span><br><span class="line">enableFilter <span class="keyword">bool</span></span><br><span class="line">filters      [FinishRouter + <span class="number">1</span>][]*FilterRouter</span><br><span class="line">pool         sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">// the filter created by FilterChain</span></span><br><span class="line">chainRoot *FilterRouter</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep registered chain and build it when serve http</span></span><br><span class="line">filterChains []filterChainConfig</span><br><span class="line"></span><br><span class="line">cfg *Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义路由</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get add get method</span></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">//    Get("/", func(ctx *context.Context)&#123;</span></span><br><span class="line"><span class="comment">//          ctx.Output.Body("hello world")</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, f FilterFunc)</span></span> &#123;</span><br><span class="line">(*web.ControllerRegister)(p).Get(pattern, <span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line">f((*beecontext.Context)(ctx))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由也是用树实现的.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tree has three elements: FixRouter/wildcard/leaves</span></span><br><span class="line"><span class="comment">// fixRouter stores Fixed Router</span></span><br><span class="line"><span class="comment">// wildcard stores params</span></span><br><span class="line"><span class="comment">// leaves store the endpoint information</span></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// prefix set for static router</span></span><br><span class="line">prefix <span class="keyword">string</span></span><br><span class="line"><span class="comment">// search fix route first</span></span><br><span class="line">fixrouters []*Tree</span><br><span class="line"><span class="comment">// if set, failure to match fixrouters search then search wildcard</span></span><br><span class="line">wildcard *Tree</span><br><span class="line"><span class="comment">// if set, failure to match wildcard search</span></span><br><span class="line">leaves []*leafInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加路由的方法.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddTree will add tree to the exist Tree</span></span><br><span class="line"><span class="comment">// prefix should has no params</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">AddTree</span><span class="params">(prefix <span class="keyword">string</span>, tree *Tree)</span></span> &#123;</span><br><span class="line">t.addtree(splitPath(prefix), tree, <span class="literal">nil</span>, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">addtree</span><span class="params">(segments []<span class="keyword">string</span>, tree *Tree, wildcards []<span class="keyword">string</span>, reg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(segments) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"prefix should has path"</span>)</span><br><span class="line">&#125;</span><br><span class="line">seg := segments[<span class="number">0</span>]</span><br><span class="line">iswild, params, regexpStr := splitSegment(seg)</span><br><span class="line"><span class="comment">// if it's ? meaning can igone this, so add one more rule for it</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">0</span> &amp;&amp; params[<span class="number">0</span>] == <span class="string">":"</span> &#123;</span><br><span class="line">params = params[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(segments[<span class="number">1</span>:]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">t.addtree(segments[<span class="number">1</span>:], tree, <span class="built_in">append</span>(wildcards, params...), reg)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">filterTreeWithPrefix(tree, wildcards, reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rule: /login/*/access match /login/2009/11/access</span></span><br><span class="line"><span class="comment">// if already has *, and when loop the access, should as a regexpStr</span></span><br><span class="line"><span class="keyword">if</span> !iswild &amp;&amp; utils.InSlice(<span class="string">":splat"</span>, wildcards) &#123;</span><br><span class="line">iswild = <span class="literal">true</span></span><br><span class="line">regexpStr = seg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rule: /user/:id/*</span></span><br><span class="line"><span class="keyword">if</span> seg == <span class="string">"*"</span> &amp;&amp; <span class="built_in">len</span>(wildcards) &gt; <span class="number">0</span> &amp;&amp; reg == <span class="string">""</span> &#123;</span><br><span class="line">regexpStr = <span class="string">"(.+)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(segments) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> iswild &#123;</span><br><span class="line"><span class="keyword">if</span> regexpStr != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reg == <span class="string">""</span> &#123;</span><br><span class="line">rr := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> wildcards &#123;</span><br><span class="line"><span class="keyword">if</span> w == <span class="string">":splat"</span> &#123;</span><br><span class="line">rr = rr + <span class="string">"(.+)/"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rr = rr + <span class="string">"([^/]+)/"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">regexpStr = rr + regexpStr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">regexpStr = <span class="string">"/"</span> + regexpStr</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reg != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> seg == <span class="string">"*.*"</span> &#123;</span><br><span class="line">regexpStr = <span class="string">"([^.]+).(.+)"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> params &#123;</span><br><span class="line"><span class="keyword">if</span> w == <span class="string">"."</span> || w == <span class="string">":"</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">regexpStr = <span class="string">"([^/]+)/"</span> + regexpStr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reg = strings.Trim(reg+<span class="string">"/"</span>+regexpStr, <span class="string">"/"</span>)</span><br><span class="line">filterTreeWithPrefix(tree, <span class="built_in">append</span>(wildcards, params...), reg)</span><br><span class="line">t.wildcard = tree</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reg = strings.Trim(reg+<span class="string">"/"</span>+regexpStr, <span class="string">"/"</span>)</span><br><span class="line">filterTreeWithPrefix(tree, <span class="built_in">append</span>(wildcards, params...), reg)</span><br><span class="line">tree.prefix = seg</span><br><span class="line">t.fixrouters = <span class="built_in">append</span>(t.fixrouters, tree)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> iswild &#123;</span><br><span class="line"><span class="keyword">if</span> t.wildcard == <span class="literal">nil</span> &#123;</span><br><span class="line">t.wildcard = NewTree()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> regexpStr != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reg == <span class="string">""</span> &#123;</span><br><span class="line">rr := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> wildcards &#123;</span><br><span class="line"><span class="keyword">if</span> w == <span class="string">":splat"</span> &#123;</span><br><span class="line">rr = rr + <span class="string">"(.+)/"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rr = rr + <span class="string">"([^/]+)/"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">regexpStr = rr + regexpStr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">regexpStr = <span class="string">"/"</span> + regexpStr</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reg != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> seg == <span class="string">"*.*"</span> &#123;</span><br><span class="line">regexpStr = <span class="string">"([^.]+).(.+)"</span></span><br><span class="line">params = params[<span class="number">1</span>:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> params &#123;</span><br><span class="line">regexpStr = <span class="string">"([^/]+)/"</span> + regexpStr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> seg == <span class="string">"*.*"</span> &#123;</span><br><span class="line">params = params[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reg = strings.TrimRight(strings.TrimRight(reg, <span class="string">"/"</span>)+<span class="string">"/"</span>+regexpStr, <span class="string">"/"</span>)</span><br><span class="line">t.wildcard.addtree(segments[<span class="number">1</span>:], tree, <span class="built_in">append</span>(wildcards, params...), reg)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">subTree := NewTree()</span><br><span class="line">subTree.prefix = seg</span><br><span class="line">t.fixrouters = <span class="built_in">append</span>(t.fixrouters, subTree)</span><br><span class="line">subTree.addtree(segments[<span class="number">1</span>:], tree, <span class="built_in">append</span>(wildcards, params...), reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(32)--框架beego源码阅读(1)</title>
      <link href="2021/01/14/golang-beego1/"/>
      <url>2021/01/14/golang-beego1/</url>
      
        <content type="html"><![CDATA[<p><code>beego</code>作为国人的出品的<code>web</code>框架，工作中一直也没用过，能获得这么多<code>star</code>必然有过人之处，好好学习一下它的源码。</p><a id="more"></a><p>源码阅读从<code>bee</code>这个脚手架工具开始吧。<a href="https://github.com/beego/bee" target="_blank" rel="noopener">源码地址</a></p><p>执行<code>go get github.com/beego/bee</code>，安装完成后，运行<code>bee</code>，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bee</span></span><br><span class="line">Bee is a Fast and Flexible tool for managing your Beego Web Application.</span><br><span class="line"></span><br><span class="line">USAGE</span><br><span class="line">    bee command [arguments]</span><br><span class="line"></span><br><span class="line">AVAILABLE COMMANDS</span><br><span class="line"></span><br><span class="line">    version     Prints the current Bee version</span><br><span class="line">    migrate     Runs database migrations</span><br><span class="line">    api         Creates a Beego API application</span><br><span class="line">    bale        Transforms non-Go files to Go source files</span><br><span class="line">    fix         Fixes your application by making it compatible with newer versions of Beego</span><br><span class="line">    pro         Source code generator</span><br><span class="line">    dlv         Start a debugging session using Delve</span><br><span class="line">    dockerize   Generates a Dockerfile for your Beego application</span><br><span class="line">    generate    Source code generator</span><br><span class="line">    hprose      Creates an RPC application based on Hprose and Beego frameworks</span><br><span class="line">    new         Creates a Beego application</span><br><span class="line">    pack        Compresses a Beego application into a single file</span><br><span class="line">    rs          Run customized scripts</span><br><span class="line">    run         Run the application by starting a local development server</span><br><span class="line">    server      serving static content over HTTP on port</span><br><span class="line">    update      Update Bee</span><br><span class="line"></span><br><span class="line">Use bee help [command] for more information about a command.</span><br><span class="line"></span><br><span class="line">ADDITIONAL HELP TOPICS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Use bee help [topic] for more information about that topic.</span><br></pre></td></tr></table></figure><p>看下<code>main.go</code>，参数解析用的标准库<code>flag</code>实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">utils.NoticeUpdateBee()</span><br><span class="line">flag.Usage = cmd.Usage</span><br><span class="line">flag.Parse()</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">args := flag.Args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">1</span> &#123;</span><br><span class="line">cmd.Usage()</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args[<span class="number">0</span>] == <span class="string">"help"</span> &#123;</span><br><span class="line">cmd.Help(args[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配命令运行</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> commands.AvailableCommands &#123;</span><br><span class="line"><span class="keyword">if</span> c.Name() == args[<span class="number">0</span>] &amp;&amp; c.Run != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.Usage() &#125;</span><br><span class="line"><span class="keyword">if</span> c.CustomFlags &#123;</span><br><span class="line">args = args[<span class="number">1</span>:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.Flag.Parse(args[<span class="number">1</span>:])</span><br><span class="line">args = c.Flag.Args()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.PreRun != <span class="literal">nil</span> &#123;</span><br><span class="line">c.PreRun(c, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config.LoadConfig()</span><br><span class="line">os.Exit(c.Run(c, args))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utils.PrintErrorAndExit(<span class="string">"Unknown subcommand"</span>, cmd.ErrorTemplate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p><code>Command</code>定义了命令了需要具备的基本属性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Command is the unit of execution</span></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Run runs the command.</span></span><br><span class="line"><span class="comment">// The args are the arguments after the command name.</span></span><br><span class="line">Run <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PreRun performs an operation before running the command</span></span><br><span class="line">PreRun <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UsageLine is the one-line Usage message.</span></span><br><span class="line"><span class="comment">// The first word in the line is taken to be the command name.</span></span><br><span class="line">UsageLine <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Short is the short description shown in the 'go help' output.</span></span><br><span class="line">Short <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Long is the long message shown in the 'go help &lt;this-command&gt;' output.</span></span><br><span class="line">Long <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flag is a set of flags specific to this command.</span></span><br><span class="line">Flag flag.FlagSet</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomFlags indicates that the command will do its own</span></span><br><span class="line"><span class="comment">// flag parsing.</span></span><br><span class="line">CustomFlags <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output out writer if set in SetOutput(w)</span></span><br><span class="line">output *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>Command</code>也很简单。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CmdFix = &amp;commands.Command&#123;</span><br><span class="line">UsageLine: <span class="string">"fix"</span>,</span><br><span class="line">Short:     <span class="string">"Fixes your application by making it compatible with newer versions of Beego"</span>,</span><br><span class="line">Long: <span class="string">`</span></span><br><span class="line"><span class="string">  The command 'fix' will try to solve those issues by upgrading your code base</span></span><br><span class="line"><span class="string">  to be compatible  with Beego old version</span></span><br><span class="line"><span class="string">  -s source version</span></span><br><span class="line"><span class="string">  -t target version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  example: bee fix -s 1 -t 2 means that upgrade Beego version from v1.x to v2.x</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">source, target utils.DocValue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">CmdFix.Run = runFix</span><br><span class="line">CmdFix.PreRun = <span class="function"><span class="keyword">func</span><span class="params">(cmd *commands.Command, args []<span class="keyword">string</span>)</span></span> &#123; version.ShowShortVersionBanner() &#125;</span><br><span class="line">CmdFix.Flag.Var(&amp;source, <span class="string">"s"</span>, <span class="string">"source version"</span>)</span><br><span class="line">CmdFix.Flag.Var(&amp;target, <span class="string">"t"</span>, <span class="string">"target version"</span>)</span><br><span class="line">commands.AvailableCommands = <span class="built_in">append</span>(commands.AvailableCommands, CmdFix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFix</span><span class="params">(cmd *commands.Command, args []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">t := target.String()</span><br><span class="line"><span class="keyword">if</span> t == <span class="string">""</span> || t == <span class="string">"1.6"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fixTo16(cmd, args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.HasPrefix(t, <span class="string">"2"</span>) &#123;</span><br><span class="line"><span class="comment">// upgrade to v2</span></span><br><span class="line"><span class="keyword">return</span> fix1To2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beeLogger.Log.Info(<span class="string">"The target is compatible version, do nothing"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commands</code>文件夹下实现了包括<code>migrate</code>在内的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── cmd</span><br><span class="line">│   ├── bee.go</span><br><span class="line">│   └── commands</span><br><span class="line">│       ├── api</span><br><span class="line">│       │   └── apiapp.go</span><br><span class="line">│       ├── bale</span><br><span class="line">│       │   └── bale.go</span><br><span class="line">│       ├── beefix</span><br><span class="line">│       │   ├── fix.go</span><br><span class="line">│       │   ├── fix1To2.go</span><br><span class="line">│       │   └── fixTo1.6.go</span><br><span class="line">│       ├── beegopro</span><br><span class="line">│       │   └── beegopro.go</span><br><span class="line">│       ├── command.go</span><br><span class="line">│       ├── dev</span><br><span class="line">│       │   ├── cmd.go</span><br><span class="line">│       │   └── githook.go</span><br><span class="line">│       ├── dlv</span><br><span class="line">│       │   ├── dlv.go</span><br><span class="line">│       │   └── dlv_amd64.go</span><br></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code>主要实现都基于模板的字符串替换<code>strings.Replace</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateController</span><span class="params">(cname, currpath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">w := colors.NewColorWriter(os.Stdout)</span><br><span class="line"></span><br><span class="line">p, f := path.Split(cname)</span><br><span class="line">controllerName := strings.Title(f)</span><br><span class="line">packageName := <span class="string">"controllers"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p != <span class="string">""</span> &#123;</span><br><span class="line">i := strings.LastIndex(p[:<span class="built_in">len</span>(p)<span class="number">-1</span>], <span class="string">"/"</span>)</span><br><span class="line">packageName = p[i+<span class="number">1</span> : <span class="built_in">len</span>(p)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beeLogger.Log.Infof(<span class="string">"Using '%s' as controller name"</span>, controllerName)</span><br><span class="line">beeLogger.Log.Infof(<span class="string">"Using '%s' as package name"</span>, packageName)</span><br><span class="line"></span><br><span class="line">fp := path.Join(currpath, <span class="string">"controllers"</span>, p)</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(fp); os.IsNotExist(err) &#123;</span><br><span class="line"><span class="comment">// Create the controller's directory</span></span><br><span class="line"><span class="keyword">if</span> err := os.MkdirAll(fp, <span class="number">0777</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">beeLogger.Log.Fatalf(<span class="string">"Could not create controllers directory: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fpath := path.Join(fp, strings.ToLower(controllerName)+<span class="string">".go"</span>)</span><br><span class="line"><span class="keyword">if</span> f, err := os.OpenFile(fpath, os.O_CREATE|os.O_EXCL|os.O_RDWR, <span class="number">0666</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utils.CloseFile(f)</span><br><span class="line"></span><br><span class="line">modelPath := path.Join(currpath, <span class="string">"models"</span>, strings.ToLower(controllerName)+<span class="string">".go"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> content <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(modelPath); err == <span class="literal">nil</span> &#123;</span><br><span class="line">beeLogger.Log.Infof(<span class="string">"Using matching model '%s'"</span>, controllerName)</span><br><span class="line">content = strings.Replace(controllerModelTpl, <span class="string">"&#123;&#123;packageName&#125;&#125;"</span>, packageName, <span class="number">-1</span>)</span><br><span class="line">pkgPath := getPackagePath(currpath)</span><br><span class="line">content = strings.Replace(content, <span class="string">"&#123;&#123;pkgPath&#125;&#125;"</span>, pkgPath, <span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">content = strings.Replace(controllerTpl, <span class="string">"&#123;&#123;packageName&#125;&#125;"</span>, packageName, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content = strings.Replace(content, <span class="string">"&#123;&#123;controllerName&#125;&#125;"</span>, controllerName, <span class="number">-1</span>)</span><br><span class="line">f.WriteString(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 'gofmt' on the generated source code</span></span><br><span class="line">utils.FormatSourceCode(fpath)</span><br><span class="line">fmt.Fprintf(w, <span class="string">"\t%s%screate%s\t %s%s\n"</span>, <span class="string">"\x1b[32m"</span>, <span class="string">"\x1b[1m"</span>, <span class="string">"\x1b[21m"</span>, fpath, <span class="string">"\x1b[0m"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">beeLogger.Log.Fatalf(<span class="string">"Could not create controller file: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python(2)——构建工具setup.py</title>
      <link href="2021/01/13/python-setup/"/>
      <url>2021/01/13/python-setup/</url>
      
        <content type="html"><![CDATA[<p>通常我们安装依赖都是通过<code>pip</code>安装，那<code>pip</code>是怎么工具的呢，我们要把一个<code>package</code>打包发布又该如何操作呢？</p><a id="more"></a><p>通常我们需要编写一个<code>setup.py</code>文件，文件中需要提供这个<code>package</code>的依赖、版本及环境信息。</p><h2 id="setup-py介绍"><a href="#setup-py介绍" class="headerlink" title="setup.py介绍"></a>setup.py介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">from distutils.core import setup</span><br><span class="line"></span><br><span class="line">setup(name&#x3D;&#39;Distutils&#39;,</span><br><span class="line">      version&#x3D;&#39;1.0&#39;,</span><br><span class="line">      description&#x3D;&#39;Python Distribution Utilities&#39;,</span><br><span class="line">      author&#x3D;&#39;Greg Ward&#39;,</span><br><span class="line">      author_email&#x3D;&#39;gward@python.net&#39;,</span><br><span class="line">      url&#x3D;&#39;https:&#x2F;&#x2F;www.python.org&#x2F;sigs&#x2F;distutils-sig&#x2F;&#39;,</span><br><span class="line">      packages&#x3D;[&#39;distutils&#39;, &#39;distutils.command&#39;],</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><p>基本参数说明：</p><ul><li>–name: 包名称</li><li>version: 当前版本</li><li>license: 许可证，常用的 <code>MIT</code>,<code>GPL</code></li><li>url: 通常指向项目的<code>github</code>仓库</li><li>packages: 需要打包进去的包</li><li>package_dir: 如需要包含全部的可以这样写 <code>package_dir = {&#39;&#39;: &#39;lib&#39;}</code></li><li>install_requires: 需要安装的依赖 </li></ul><h2 id="entry-points"><a href="#entry-points" class="headerlink" title="entry_points"></a>entry_points</h2><p><code>entry_points</code>可生成可执行文件，通常<code>cli</code>工具会使用这个参数与<code>click</code>库配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry_points&#x3D;&#123;</span><br><span class="line">    &#39;console_scripts&#39;: [</span><br><span class="line">        &#39;cursive &#x3D; test.main:main&#39;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，<code>cursive</code>是可执行的命令，<code>cmd:cursive_command</code>表示映射到<code>test</code>包<code>main</code>模块下的<code>main</code>方法上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">├── test</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── main.py</span><br><span class="line">├── setup.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"run"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'test'</span>,</span><br><span class="line">      version=<span class="string">'1.0'</span>,</span><br><span class="line">      description=<span class="string">'Python Distribution Utilities'</span>,</span><br><span class="line">      author=<span class="string">'Greg Ward'</span>,</span><br><span class="line">      author_email=<span class="string">'gward@python.net'</span>,</span><br><span class="line">      url=<span class="string">'https://www.python.org/sigs/distutils-sig/'</span>,</span><br><span class="line">      packages=find_packages(),</span><br><span class="line">      entry_points=&#123;</span><br><span class="line">          <span class="string">'console_scripts'</span>: [</span><br><span class="line">              <span class="string">'qwer = test.main:main'</span>,</span><br><span class="line">          ],</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>执行<code>python setup.py install</code>之后，我们就可以在当前环境下，使用<code>qwer</code>这个命令了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qwer --<span class="built_in">help</span></span></span><br><span class="line">Usage: qwer [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --help  Show this message and exit.</span><br></pre></td></tr></table></figure><h2 id="打包上传至pypi"><a href="#打包上传至pypi" class="headerlink" title="打包上传至pypi"></a>打包上传至pypi</h2><p>写好了<code>setup.py</code>之后，执行打包命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><p>命令执行成功后，查看<code>dist</code>目录，生成了如下打包文件</p><p><img src="https://pic.hupai.pro/img/20210113114708.png" alt="目录"></p><p>如果没有<code>pypi</code>账号，则需要前往官网注册，<a href="https://pypi.org/" target="_blank" rel="noopener">pypi官网</a></p><p>注册之后，需要<code>twine</code>这个上传工具，执行<code>pip install twine</code></p><p>安装完成后，执行<code>twine upload dist/*</code>即可</p><p>发布完成后所有人都可以通过<code>pip install test</code>安装此包</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(31)--hystrix-go源码分析</title>
      <link href="2021/01/12/go-hystrix/"/>
      <url>2021/01/12/go-hystrix/</url>
      
        <content type="html"><![CDATA[<p><code>hystrix</code>是一个用来隔离远程系统调用、第三方库调用、服务调用、提供熔断机制、避免雪崩效应的库， <code>Hystrix</code>的<code>go</code>版本。 注<code>Hystrixs</code>是<code>Netflix</code>开源的一个java库。</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>Go</code>方法接受执行函数及异常函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/afex/hystrix-go/hystrix"</span></span><br><span class="line"></span><br><span class="line">hystrix.Go(<span class="string">"my_command"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// talk to other services</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// do this when services are down</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Go-GoC"><a href="#Go-GoC" class="headerlink" title="Go, GoC"></a>Go, GoC</h2><p><code>Go</code>和<code>GoC</code>函数差别是<code>GoC</code>多了一个待传入的上下文<code>ctx</code>参数，在实现上，<code>Go</code>也是用<code>context.Backgroud()</code>作为默认上下文来调用<code>GoC</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(name <span class="keyword">string</span>, run runFunc, fallback fallbackFunc)</span> <span class="title">chan</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoC</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, run runFuncC, fallback fallbackFuncC)</span> <span class="title">chan</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>重点看下<code>GoC</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GoC runs your function while tracking the health of previous calls to it.</span></span><br><span class="line"><span class="comment">// If your function begins slowing down or failing repeatedly, we will block</span></span><br><span class="line"><span class="comment">// new calls to it for you to give the dependent service time to repair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Define a fallback function if you want to define some code to execute during outages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoC</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, run runFuncC, fallback fallbackFuncC)</span> <span class="title">chan</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 构造成command对象</span></span><br><span class="line">cmd := &amp;command&#123;</span><br><span class="line">run:      run,</span><br><span class="line">fallback: fallback,</span><br><span class="line">start:    time.Now(),</span><br><span class="line">errChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">finished: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circuit, _, err := GetCircuit(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">cmd.errChan &lt;- err</span><br><span class="line"><span class="keyword">return</span> cmd.errChan</span><br><span class="line">&#125;</span><br><span class="line">cmd.circuit = circuit <span class="comment">// 断路器</span></span><br><span class="line">ticketCond := sync.NewCond(cmd)</span><br><span class="line">ticketChecked := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回令牌</span></span><br><span class="line">returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd.Lock()</span><br><span class="line"><span class="comment">// Avoid releasing before a ticket is acquired.</span></span><br><span class="line"><span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">ticketCond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">cmd.circuit.executorPool.Return(cmd.ticket)</span><br><span class="line">cmd.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保证只有先结束的goroutine返回结果</span></span><br><span class="line">returnOnce := &amp;sync.Once&#123;&#125;</span><br><span class="line">reportAllEvent := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := cmd.circuit.ReportEvent(cmd.events, cmd.start, cmd.runDuration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断路 &amp; 限流</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cmd.finished &lt;- <span class="literal">true</span> &#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circuits get opened when recent executions have shown to have a high error rate.</span></span><br><span class="line"><span class="comment">// Rejecting new executions allows backends to recover, and the circuit will allow</span></span><br><span class="line"><span class="comment">// new traffic when it feels a healthly state has returned.</span></span><br><span class="line"><span class="keyword">if</span> !cmd.circuit.AllowRequest() &#123;</span><br><span class="line">cmd.Lock()</span><br><span class="line"><span class="comment">// It's safe for another goroutine to go ahead releasing a nil ticket.</span></span><br><span class="line">ticketChecked = <span class="literal">true</span></span><br><span class="line">ticketCond.Signal()</span><br><span class="line">cmd.Unlock()</span><br><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">returnTicket()</span><br><span class="line">cmd.errorWithFallback(ctx, ErrCircuitOpen)</span><br><span class="line">reportAllEvent()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后端服务响应慢时，降低后端的负载</span></span><br><span class="line">    <span class="comment">// 部分请求直接失败</span></span><br><span class="line">cmd.Lock()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> cmd.ticket = &lt;-circuit.executorPool.Tickets:</span><br><span class="line">ticketChecked = <span class="literal">true</span></span><br><span class="line">ticketCond.Signal()</span><br><span class="line">cmd.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ticketChecked = <span class="literal">true</span></span><br><span class="line">ticketCond.Signal()</span><br><span class="line">cmd.Unlock()</span><br><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">returnTicket()</span><br><span class="line">cmd.errorWithFallback(ctx, ErrMaxConcurrency)</span><br><span class="line">reportAllEvent()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runStart := time.Now()</span><br><span class="line">runErr := run(ctx)</span><br><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> reportAllEvent()</span><br><span class="line">cmd.runDuration = time.Since(runStart)</span><br><span class="line">returnTicket()</span><br><span class="line"><span class="keyword">if</span> runErr != <span class="literal">nil</span> &#123;</span><br><span class="line">cmd.errorWithFallback(ctx, runErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cmd.reportEvent(<span class="string">"success"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时退出</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">timer := time.NewTimer(getSettings(name).Timeout)</span><br><span class="line"><span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cmd.finished:</span><br><span class="line"><span class="comment">// returnOnce has been executed in another goroutine</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">returnTicket()</span><br><span class="line">cmd.errorWithFallback(ctx, ctx.Err())</span><br><span class="line">reportAllEvent()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">returnTicket()</span><br><span class="line">cmd.errorWithFallback(ctx, ErrTimeout)</span><br><span class="line">reportAllEvent()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd.errChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Do-DoC"><a href="#Do-DoC" class="headerlink" title="Do, DoC"></a>Do, DoC</h2><p><code>DoC</code>是同步执行，函数执行完成或者执行出错之前都会堵塞程序执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoC runs your function in a synchronous manner, blocking until either your function succeeds</span></span><br><span class="line"><span class="comment">// or an error is returned, including hystrix circuit errors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoC</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, run runFuncC, fallback fallbackFuncC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := run(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, e error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := fallback(ctx, e)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errChan <span class="keyword">chan</span> error</span><br><span class="line"><span class="keyword">if</span> fallback == <span class="literal">nil</span> &#123;</span><br><span class="line">errChan = GoC(ctx, name, r, <span class="literal">nil</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">errChan = GoC(ctx, name, r, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 堵塞函数直到执行完成或者返回error</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-errChan:</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executorPool"><a href="#executorPool" class="headerlink" title="executorPool"></a>executorPool</h2><p><code>executorPool</code>是一个令牌桶的限流器。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> executorPool <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Metrics *poolMetrics</span><br><span class="line">Max     <span class="keyword">int</span></span><br><span class="line">Tickets <span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newExecutorPool</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">executorPool</span></span> &#123;</span><br><span class="line">p := &amp;executorPool&#123;&#125;</span><br><span class="line">p.Name = name</span><br><span class="line">p.Metrics = newPoolMetrics(name)</span><br><span class="line">p.Max = getSettings(name).MaxConcurrentRequests</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化p.Max个令牌</span></span><br><span class="line">p.Tickets = <span class="built_in">make</span>(<span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125;, p.Max)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.Max; i++ &#123;</span><br><span class="line">p.Tickets &lt;- &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归还令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *executorPool)</span> <span class="title">Return</span><span class="params">(ticket *<span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ticket == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.Metrics.Updates &lt;- poolMetricsUpdate&#123;</span><br><span class="line">activeCount: p.ActiveCount(),</span><br><span class="line">&#125;</span><br><span class="line">p.Tickets &lt;- ticket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *executorPool)</span> <span class="title">ActiveCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.Max - <span class="built_in">len</span>(p.Tickets)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h2><p><code>CircuitBreaker</code>是一个断路器。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CircuitBreaker is created for each ExecutorPool to track whether requests</span></span><br><span class="line"><span class="comment">// should be attempted, or rejected if the Health of the circuit is too low.</span></span><br><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">Name                   <span class="keyword">string</span></span><br><span class="line">open                   <span class="keyword">bool</span></span><br><span class="line">forceOpen              <span class="keyword">bool</span></span><br><span class="line">mutex                  *sync.RWMutex <span class="comment">// 修改状态需要加锁</span></span><br><span class="line">openedOrLastTestedTime <span class="keyword">int64</span></span><br><span class="line"> </span><br><span class="line">executorPool *executorPool    <span class="comment">// 限流器</span></span><br><span class="line">metrics      *metricExchange  <span class="comment">// 监控状态收集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下断路的方法实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务在执行之前都会调用AllowRequest校验状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *CircuitBreaker)</span> <span class="title">AllowRequest</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !circuit.IsOpen() || circuit.allowSingleTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断路器是否打开，True表示打开了，服务不可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *CircuitBreaker)</span> <span class="title">IsOpen</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">circuit.mutex.RLock()</span><br><span class="line">o := circuit.forceOpen || circuit.open</span><br><span class="line">circuit.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> o &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(circuit.metrics.Requests().Sum(time.Now())) &lt; getSettings(circuit.Name).RequestVolumeThreshold &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !circuit.metrics.IsHealthy(time.Now()) &#123;</span><br><span class="line"><span class="comment">// 当前存在大量请求失败，直接断开</span></span><br><span class="line">circuit.setOpen()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *CircuitBreaker)</span> <span class="title">allowSingleTest</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">circuit.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> circuit.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">now := time.Now().UnixNano()</span><br><span class="line">  openedOrLastTestedTime := atomic.LoadInt64(&amp;circuit.openedOrLastTestedTime)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每间隔一个SleepWindows的时间允许通过一个测试请求</span></span><br><span class="line"><span class="keyword">if</span> circuit.open &amp;&amp; now &gt; openedOrLastTestedTime+getSettings(circuit.Name).SleepWindow.Nanoseconds() &#123;</span><br><span class="line">swapped := atomic.CompareAndSwapInt64(&amp;circuit.openedOrLastTestedTime, openedOrLastTestedTime, now)</span><br><span class="line"><span class="keyword">if</span> swapped &#123;</span><br><span class="line">log.Printf(<span class="string">"hystrix-go: allowing single test to possibly close circuit %v"</span>, circuit.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> swapped</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的代码我们可以看到每次处理结果都会上报，这个时候也会检查是否关闭断路器。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportEvent records command metrics for tracking recent error rates and exposing data to the dashboard.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *CircuitBreaker)</span> <span class="title">ReportEvent</span><span class="params">(eventTypes []<span class="keyword">string</span>, start time.Time, runDuration time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(eventTypes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"no event types sent for metrics"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circuit.mutex.RLock()</span><br><span class="line">o := circuit.open</span><br><span class="line">circuit.mutex.RUnlock()</span><br><span class="line"><span class="keyword">if</span> eventTypes[<span class="number">0</span>] == <span class="string">"success"</span> &amp;&amp; o &#123;</span><br><span class="line">circuit.setClose()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrencyInUse <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">if</span> circuit.executorPool.Max &gt; <span class="number">0</span> &#123;</span><br><span class="line">concurrencyInUse = <span class="keyword">float64</span>(circuit.executorPool.ActiveCount()) / <span class="keyword">float64</span>(circuit.executorPool.Max)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录结果</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> circuit.metrics.Updates &lt;- &amp;commandExecution&#123;</span><br><span class="line">Types:            eventTypes,</span><br><span class="line">Start:            start,</span><br><span class="line">RunDuration:      runDuration,</span><br><span class="line">ConcurrencyInUse: concurrencyInUse,</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> CircuitError&#123;Message: fmt.Sprintf(<span class="string">"metrics channel (%v) is at capacity"</span>, circuit.Name)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python SQLAlchemy库——(2)create_engine分析</title>
      <link href="2021/01/09/sqlalchemy-2/"/>
      <url>2021/01/09/sqlalchemy-2/</url>
      
        <content type="html"><![CDATA[<p><code>engine</code>是<code>SQLAlchemy</code>的核心，是<code>SQLAlchemy</code>实现对各种数据库统一操作的基础。</p><a id="more"></a><p><code>create_engine</code>是<code>engine</code>的工厂函数，支持<code>strategy</code>参数使用指定的<code>Strategy类</code>进行构造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default_strategy = <span class="string">"plain"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_engine</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""省略"""</span></span><br><span class="line">    strategy = kwargs.pop(<span class="string">"strategy"</span>, default_strategy)</span><br><span class="line">    strategy = strategies.strategies[strategy]</span><br><span class="line">    <span class="keyword">return</span> strategy.create(*args, **kwargs)</span><br></pre></td></tr></table></figure><p><code>EngineStrategy</code>是定义了<code>Strategy类</code>的行为，需要实现<code>create</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">strategies = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineStrategy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""An adaptor that processes input arguments and produces an Engine.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Provides a ``create`` method that receives input arguments and</span></span><br><span class="line"><span class="string">    produces an instance of base.Engine or a subclass.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        strategies[self.name] = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Given arguments, returns a new Engine instance."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p><code>DefaultEngineStrategy</code>是<code>Strategy类</code>默认基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultEngineStrategy</span><span class="params">(EngineStrategy)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for built-in strategies."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, name_or_url, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 解析uri</span></span><br><span class="line">        u = url.make_url(name_or_url)</span><br><span class="line"></span><br><span class="line">        plugins = u._instantiate_plugins(kwargs)</span><br><span class="line"></span><br><span class="line">        u.query.pop(<span class="string">"plugin"</span>, <span class="literal">None</span>)</span><br><span class="line">        kwargs.pop(<span class="string">"plugins"</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        entrypoint = u._get_entrypoint()</span><br><span class="line">        dialect_cls = entrypoint.get_dialect_cls(u)</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> engine</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_entrypoint</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the "entry point" dialect class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This is normally the dialect itself except in the case when the</span></span><br><span class="line"><span class="string">        returned class implements the get_dialect_cls() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"+"</span> <span class="keyword">not</span> <span class="keyword">in</span> self.drivername:</span><br><span class="line">            name = self.drivername</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name = self.drivername.replace(<span class="string">"+"</span>, <span class="string">"."</span>)</span><br><span class="line">        cls = registry.load(name)</span><br><span class="line">        <span class="comment"># check for legacy dialects that</span></span><br><span class="line">        <span class="comment"># would return a module with 'dialect' as the</span></span><br><span class="line">        <span class="comment"># actual class</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            hasattr(cls, <span class="string">"dialect"</span>)</span><br><span class="line">            <span class="keyword">and</span> isinstance(cls.dialect, type)</span><br><span class="line">            <span class="keyword">and</span> issubclass(cls.dialect, Dialect)</span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> cls.dialect</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure><p><code>make_url</code>使用正则的方式解析<code>uri</code>。</p><p><code>_get_entrypoint</code>是通过数据库类型和驱动类型来注册插件，返回<code>dialect</code>类。这里需要再看下插件是怎么实现的。</p><p>首先<code>registry</code>是一个全局<code>PluginLoader</code>类的实例。<code>load</code>方法用<code>pkg_resources</code>过滤出<code>name</code>匹配的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">registry = util.PluginLoader(<span class="string">"sqlalchemy.dialects"</span>, auto_fn=_auto_fn)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluginLoader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group, auto_fn=None)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.impls = &#123;&#125;</span><br><span class="line">        self.auto_fn = auto_fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.impls.clear()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.impls:</span><br><span class="line">            <span class="keyword">return</span> self.impls[name]()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.auto_fn:</span><br><span class="line">            loader = self.auto_fn(name)</span><br><span class="line">            <span class="keyword">if</span> loader:</span><br><span class="line">                self.impls[name] = loader</span><br><span class="line">                <span class="keyword">return</span> loader()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">import</span> pkg_resources</span><br><span class="line">        <span class="keyword">except</span> ImportError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 搜索所有的package</span></span><br><span class="line">            <span class="keyword">for</span> impl <span class="keyword">in</span> pkg_resources.iter_entry_points(self.group, name):</span><br><span class="line">                self.impls[name] = impl.load</span><br><span class="line">                <span class="keyword">return</span> impl.load()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> exc.NoSuchModuleError(</span><br><span class="line">            <span class="string">"Can't load plugin: %s:%s"</span> % (self.group, name)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, name, modulepath, objname)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">            mod = compat.import_(modulepath)</span><br><span class="line">            <span class="keyword">for</span> token <span class="keyword">in</span> modulepath.split(<span class="string">"."</span>)[<span class="number">1</span>:]:</span><br><span class="line">                mod = getattr(mod, token)</span><br><span class="line">            <span class="keyword">return</span> getattr(mod, objname)</span><br><span class="line"></span><br><span class="line">        self.impls[name] = load</span><br></pre></td></tr></table></figure><p>如果一个插件在<code>setup.py</code>中注册了<code>sqlalchemy.dialects</code>，就能被<code>pkg_resources</code>包找到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clickhouse-sqlalchemy setup.py</span></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">'clickhouse-sqlalchemy'</span>,</span><br><span class="line">    version=read_version(),</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Registering `clickhouse` as dialect. 动态发现服务和插件</span></span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">'sqlalchemy.dialects'</span>: dialects</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>dialect</code>类是一个抽象或者接口（并没有用abc包定义，而是用<code>NotImplementedError</code>方式定义），定义了插件需要实现的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialect</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Define the behavior of a specific database and DB-API combination."""</span></span><br></pre></td></tr></table></figure><p><code>DefaultDialect</code>实现是<code>SQLAlchemy</code>中<code>Dialect</code>类默认的实现，它一般作为第三方数据库扩展的父类存在。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sqlalchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(1)——Typing系统用法总结</title>
      <link href="2021/01/08/python-typing/"/>
      <url>2021/01/08/python-typing/</url>
      
        <content type="html"><![CDATA[<p><code>Python3.9</code>版本发布后再次提升了<code>Typing</code>系统的易用性。下面对当前的<code>Typing</code>做一个用法的总结。</p><a id="more"></a><h2 id="Type-Hint"><a href="#Type-Hint" class="headerlink" title="Type Hint"></a>Type Hint</h2><p>2015年9月 <code>Guido van Rossum</code> 在 Python 3.5 引入了一个类型系统，允许开发者指定变量类型。</p><p>它的主要作用不是把<code>Python</code>变成静态语言，而是为了方便开发，供<code>IDE</code>使用，对代码运行不产生影响，运行时会过滤类型信息。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>变量、函数参数后面都可以按<code>: type</code>的方式添加类型注释，函数的返回值则是以<code>-&gt;</code>的方式添加类型注解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name: str)</span> -&gt; str:</span></span><br><span class="line">    a: str = <span class="string">"x"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello '</span> + name</span><br></pre></td></tr></table></figure><h2 id="Type-aliases"><a href="#Type-aliases" class="headerlink" title="Type aliases"></a>Type aliases</h2><p>类型别名可以以变量赋值的方式创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector = list[float]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale</span><span class="params">(scalar: float, vector: Vector)</span> -&gt; Vector:</span></span><br><span class="line">    <span class="keyword">return</span> [scalar * num <span class="keyword">for</span> num <span class="keyword">in</span> vector]</span><br><span class="line"></span><br><span class="line"><span class="comment"># typechecks; a list of floats qualifies as a Vector.</span></span><br><span class="line">new_vector = scale(<span class="number">2.0</span>, [<span class="number">1.0</span>, <span class="number">-4.2</span>, <span class="number">5.4</span>])</span><br></pre></td></tr></table></figure><h2 id="NewType"><a href="#NewType" class="headerlink" title="NewType"></a>NewType</h2><p>自定义类型，允许将一个类定义成一个新的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NewType</span><br><span class="line"></span><br><span class="line">UserId = NewType(<span class="string">'UserId'</span>, int)</span><br><span class="line">some_id = UserId(<span class="number">524313</span>)</span><br></pre></td></tr></table></figure><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>函数类型可以通过<code>Callable[[Arg1Type, Arg2Type], ReturnType]</code>的方式定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Callable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feeder</span><span class="params">(get_next_item: Callable[[], str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># Body</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_query</span><span class="params">(on_success: Callable[[int], None],</span></span></span><br><span class="line"><span class="function"><span class="params">                on_error: Callable[[int, Exception], None])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># Body</span></span><br></pre></td></tr></table></figure><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>范型可以实现保持入参与出参类型的一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sequence</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)      <span class="comment"># Declare type variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(l: Sequence[T])</span> -&gt; T:</span>   <span class="comment"># Generic function</span></span><br><span class="line">    <span class="keyword">return</span> l[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="Union，组合类型"><a href="#Union，组合类型" class="headerlink" title="Union，组合类型"></a>Union，组合类型</h2><p>联合类型 <code>Union[X, Y]</code>，非X即Y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会过滤冗余</span></span><br><span class="line">Union[int, str, int] == Union[int, str]</span><br></pre></td></tr></table></figure><h2 id="Optinal"><a href="#Optinal" class="headerlink" title="Optinal"></a>Optinal</h2><p> Optional[X] 等价于 Union[X, None]。有默认值的参数本身就是可选参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg: int = <span class="number">0</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg: Optional[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br></pre></td></tr></table></figure><h2 id="typing-Dict-typing-List-typing-Set-typing-Frozenset"><a href="#typing-Dict-typing-List-typing-Set-typing-Frozenset" class="headerlink" title="typing.Dict, typing.List, typing.Set, typing.Frozenset"></a>typing.Dict, typing.List, typing.Set, typing.Frozenset</h2><p>可以定义常用数据容器<code>dict</code>、<code>list</code>和<code>set</code>等的成员类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(text: str)</span> -&gt; Dict[str, int]:</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>, int, float)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vec2</span><span class="params">(x: T, y: T)</span> -&gt; List[T]:</span></span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep_positives</span><span class="params">(vector: Sequence[T])</span> -&gt; List[T]:</span></span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> item <span class="keyword">in</span> vector <span class="keyword">if</span> item &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="typing-TypeDict"><a href="#typing-TypeDict" class="headerlink" title="typing.TypeDict"></a>typing.TypeDict</h2><p>这个可以定义字典的结构，非常好用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span><span class="params">(TypedDict)</span>:</span></span><br><span class="line">    x: int</span><br><span class="line">    y: int</span><br><span class="line">    label: str</span><br><span class="line"></span><br><span class="line">a: Point2D = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'label'</span>: <span class="string">'good'</span>&#125;  <span class="comment"># OK</span></span><br><span class="line">b: Point2D = &#123;<span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'label'</span>: <span class="string">'bad'</span>&#125;           <span class="comment"># Fails type check</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Point2D(x=<span class="number">1</span>, y=<span class="number">2</span>, label=<span class="string">'first'</span>) == dict(x=<span class="number">1</span>, y=<span class="number">2</span>, label=<span class="string">'first'</span>)</span><br></pre></td></tr></table></figure><h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>定义一个指定类型的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_all_vars</span><span class="params">(vars: Iterable[LoggedVar[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vars:</span><br><span class="line">        var.set(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="万能Any"><a href="#万能Any" class="headerlink" title="万能Any"></a>万能Any</h2><p>实在不知道类型怎么写可以用<code>Any</code>临时解决一下。如果都写<code>Any</code>那又何必使用<code>Type Hint</code>呢。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line">a = <span class="literal">None</span>    <span class="comment"># type: Any</span></span><br><span class="line">a = []      <span class="comment"># OK</span></span><br><span class="line">a = <span class="number">2</span>       <span class="comment"># OK</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">''</span>      <span class="comment"># type: str</span></span><br><span class="line">s = a       <span class="comment"># OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(item: Any)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># Typechecks; 'item' could be any type,</span></span><br><span class="line">    <span class="comment"># and that type might have a 'bar' method</span></span><br><span class="line">    item.bar()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>现在<code>Python</code>的类型系统几个版本的迭代已经非常好用了，美中不足的是整个生态上还没有广泛普及。跟<code>TypeScript</code>一样，哪怕只有自己项目上添加类型，已经能够大幅提升工作效率。</p><p>更完整的类型用法可以参考<a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> typing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(1) SQLAlchemy库——连接与基本ORM操作</title>
      <link href="2021/01/07/sqlalchemy-1/"/>
      <url>2021/01/07/sqlalchemy-1/</url>
      
        <content type="html"><![CDATA[<p><code>SQLAlchemy</code>是<code>Python</code>公认最好的<code>ORM</code>库，它同时也是最好的数据库操作库。</p><a id="more"></a><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><code>SQLAlchemy</code>本身是不能直接连接各种数据库的，所以需要安装对应的驱动库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="comment"># pip install python-mysql</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql+mysqldb://user:pwd@localhost/foo'</span>)</span><br><span class="line"><span class="comment"># pip install pymysql </span></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://user:pwd@localhost/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># postgresql</span></span><br><span class="line"><span class="comment"># pip install psycopg2</span></span><br><span class="line">engine = create_engine(<span class="string">'postgresql://user:pwd@localhost/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sqlite</span></span><br><span class="line"><span class="comment"># 自带驱动，db文件路径</span></span><br><span class="line">engine = create_engine(<span class="string">'sqlite:///foo.db'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Microsoft SQL Server</span></span><br><span class="line"><span class="comment"># pip install pyodbc</span></span><br><span class="line">engine = create_engine(<span class="string">'mssql+pyodbc://user:pwd@foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># oracle</span></span><br><span class="line"><span class="comment"># pip install cx_oracle</span></span><br><span class="line">engine = create_engine(<span class="string">'oracle://user:pwd@127.0.0.1:1521/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clickhouse</span></span><br><span class="line"><span class="comment"># pip install clickhouse-sqlalchemy</span></span><br><span class="line"><span class="comment"># pip install clickhouse-driver</span></span><br><span class="line">engine = create_engine(<span class="string">'clickhouse://user:pwd@127.0.0.1:8123/foo)</span></span><br></pre></td></tr></table></figure><h2 id="ORM-Model定义"><a href="#ORM-Model定义" class="headerlink" title="ORM Model定义"></a>ORM Model定义</h2><p>通过继承<code>Base</code>定义的<code>User</code>类与数据库表<code>users</code>完成的<code>Mapping</code>，<code>id</code>对应数据库主键，其余<code>name</code>等字段也与表中的字段一一对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment"># 数据库表名</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span> </span><br><span class="line">    <span class="comment"># 主键</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    name = Column(String)</span><br><span class="line">    fullname = Column(String)</span><br><span class="line">    nickname = Column(String)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&lt;User(name='%s', fullname='%s', nickname='%s')&gt;"</span> % (</span><br><span class="line">                            self.name, self.fullname, self.nickname)</span><br></pre></td></tr></table></figure><h2 id="创建Session"><a href="#创建Session" class="headerlink" title="创建Session"></a>创建Session</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">'sqlite:///:memory:'</span>, echo=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure><h2 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add</span></span><br><span class="line">ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, nickname=<span class="string">'edsnickname'</span>)</span><br><span class="line">session.add(ed_user)</span><br><span class="line"></span><br><span class="line"><span class="comment"># batch add </span></span><br><span class="line">session.add_all([</span><br><span class="line">    User(name=<span class="string">'wendy'</span>, fullname=<span class="string">'Wendy Williams'</span>, nickname=<span class="string">'windy'</span>),</span><br><span class="line">    User(name=<span class="string">'mary'</span>, fullname=<span class="string">'Mary Contrary'</span>, nickname=<span class="string">'mary'</span>),</span><br><span class="line">    User(name=<span class="string">'fred'</span>, fullname=<span class="string">'Fred Flintstone'</span>, nickname=<span class="string">'freddy'</span>)])</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>直接修改<code>user</code>对象的<code>nickname</code>属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.nickname = <span class="string">'eddie'</span></span><br></pre></td></tr></table></figure><p>此时<code>session</code>中记录了变更</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.dirty</span><br><span class="line">IdentitySet([&lt;User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, nickname=<span class="string">'eddie'</span>)&gt;])</span><br></pre></td></tr></table></figure><p>执行提交</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.delete(jack)</span><br><span class="line">SQL&gt;&gt;&gt; session.query(User).filter_by(name=<span class="string">'jack'</span>).count()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>基本查询，<code>filter</code>中写入<code>where</code>条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>our_user = session.query(User).filter_by(name=<span class="string">'ed'</span>).first() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>our_user</span><br><span class="line">&lt;User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, nickname=<span class="string">'edsnickname'</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># __eq__</span></span><br><span class="line">query.filter(User.name == <span class="string">'ed'</span>)</span><br><span class="line"><span class="comment"># ___ne__</span></span><br><span class="line">query.filter(User.name != <span class="string">'ed'</span>)</span><br><span class="line"><span class="comment"># like</span></span><br><span class="line">query.filter(User.name.like(<span class="string">'%ed%'</span>))</span><br><span class="line"><span class="comment"># in</span></span><br><span class="line">query.filter(User.name.in_([<span class="string">'ed'</span>, <span class="string">'wendy'</span>, <span class="string">'jack'</span>]))</span><br><span class="line"><span class="comment"># not in</span></span><br><span class="line">query.filter(~User.name.in_([<span class="string">'ed'</span>, <span class="string">'wendy'</span>, <span class="string">'jack'</span>]))</span><br><span class="line"><span class="comment"># and</span></span><br><span class="line">query.filter(and_(User.name == <span class="string">'ed'</span>, User.fullname == <span class="string">'Ed Jones'</span>))</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">query.filter(or_(User.name == <span class="string">'ed'</span>, User.name == <span class="string">'wendy'</span>))</span><br><span class="line"><span class="comment"># limit offset</span></span><br><span class="line">query(User).order_by(User.id)[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>排序，<code>order_by</code>任意字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instance <span class="keyword">in</span> session.query(User).order_by(User.id):</span><br><span class="line"><span class="meta">... </span>    print(instance.name, instance.fullname)</span><br><span class="line">ed Ed Jones</span><br><span class="line">wendy Wendy Williams</span><br><span class="line">mary Mary Contrary</span><br><span class="line">fred Fred Flintstone</span><br></pre></td></tr></table></figure><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">SQL&gt;&gt;&gt; session.query(func.count(User.name), User.name).group_by(User.name).all()</span><br><span class="line">[(<span class="number">1</span>, <span class="string">u'ed'</span>), (<span class="number">1</span>, <span class="string">u'fred'</span>), (<span class="number">1</span>, <span class="string">u'mary'</span>), (<span class="number">1</span>, <span class="string">u'wendy'</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sqlalchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faiss使用文档（2）—— 基础</title>
      <link href="2021/01/05/faiss-2/"/>
      <url>2021/01/05/faiss-2/</url>
      
        <content type="html"><![CDATA[<p>这篇汇总介绍一下<code>faiss</code>里面用到的算法及概念。</p><a id="more"></a><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>faiss的核心就是索引（index）概念，它封装了一组向量，并且可以选择是否进行预处理，帮忙高效的检索向量。 faiss中由多种类型的索引，我们可以是呀最简单的索引类型：indexFlatL2，这就是暴力检索L2距离（欧式距离）。 不管建立什么类型的索引，我们都必须先知道向量的维度。</p><h3 id="IndexFlatL2"><a href="#IndexFlatL2" class="headerlink" title="IndexFlatL2"></a>IndexFlatL2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    d = <span class="number">3</span>  <span class="comment"># 向量维度</span></span><br><span class="line">    nb = <span class="number">100000</span>  <span class="comment"># 向量集大小</span></span><br><span class="line">    nq = <span class="number">10000</span>  <span class="comment"># 查询次数</span></span><br><span class="line">    np.random.seed(<span class="number">1234</span>)  <span class="comment"># 随机种子,使结果可复现</span></span><br><span class="line">    xb = np.random.random((nb, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xb[:, <span class="number">0</span>] += np.arange(nb) / <span class="number">1000.</span>  <span class="comment"># 每一项增加了一个等差数列的对应项数</span></span><br><span class="line">    xq = np.random.random((nq, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xq[:, <span class="number">0</span>] += np.arange(nq) / <span class="number">1000.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> faiss</span><br><span class="line">    index = faiss.IndexFlatL2(d)  <span class="comment"># 构建FlatL2索引</span></span><br><span class="line">    print(index.is_trained)</span><br><span class="line">    index.add(xb)  <span class="comment"># 向索引中添加向量</span></span><br><span class="line">    print(index.ntotal)</span><br><span class="line">    </span><br><span class="line">    k = <span class="number">4</span>  <span class="comment"># k=4的 k近邻搜索</span></span><br><span class="line">    D, I = index.search(xb[:<span class="number">5</span>], k)  <span class="comment"># 测试</span></span><br><span class="line">    print(I)</span><br><span class="line">    print(D)</span><br><span class="line">    D, I = index.search(xq, k)  <span class="comment"># 执行搜索</span></span><br><span class="line">    print(I[:<span class="number">5</span>])  <span class="comment"># 最初五次查询的结果</span></span><br><span class="line">    print(I[<span class="number">-5</span>:])  <span class="comment"># 最后五次查询的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="IndexIVFFlat"><a href="#IndexIVFFlat" class="headerlink" title="IndexIVFFlat"></a>IndexIVFFlat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    d = <span class="number">64</span>  <span class="comment"># 向量维度</span></span><br><span class="line">    nb = <span class="number">100000</span>  <span class="comment"># 向量集大小</span></span><br><span class="line">    nq = <span class="number">10000</span>  <span class="comment"># 查询次数</span></span><br><span class="line">    np.random.seed(<span class="number">1234</span>)  <span class="comment"># 随机种子,使结果可复现</span></span><br><span class="line">    xb = np.random.random((nb, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xb[:, <span class="number">0</span>] += np.arange(nb) / <span class="number">1000.</span></span><br><span class="line">    xq = np.random.random((nq, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xq[:, <span class="number">0</span>] += np.arange(nq) / <span class="number">1000.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> faiss</span><br><span class="line">    </span><br><span class="line">    nlist = <span class="number">100</span></span><br><span class="line">    k = <span class="number">4</span></span><br><span class="line">    quantizer = faiss.IndexFlatL2(d)  <span class="comment"># the other index</span></span><br><span class="line">    index = faiss.IndexIVFFlat(quantizer, d, nlist, faiss.METRIC_L2)</span><br><span class="line">    <span class="comment"># here we specify METRIC_L2, by default it performs inner-product search</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> index.is_trained</span><br><span class="line">    index.train(xb)</span><br><span class="line">    <span class="keyword">assert</span> index.is_trained</span><br><span class="line">    </span><br><span class="line">    index.add(xb)  <span class="comment"># 添加索引可能会有一点慢</span></span><br><span class="line">    D, I = index.search(xq, k)  <span class="comment"># 搜索</span></span><br><span class="line">    print(I[<span class="number">-5</span>:])  <span class="comment"># 最初五次查询的结果</span></span><br><span class="line">    index.nprobe = <span class="number">10</span>  <span class="comment"># 默认 nprobe 是1 ,可以设置的大一些试试</span></span><br><span class="line">    D, I = index.search(xq, k)</span><br><span class="line">    print(I[<span class="number">-5</span>:])  <span class="comment"># 最后五次查询的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="IndexIVFPQ"><a href="#IndexIVFPQ" class="headerlink" title="IndexIVFPQ"></a>IndexIVFPQ</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    d = <span class="number">64</span>  <span class="comment"># 向量维度</span></span><br><span class="line">    nb = <span class="number">100000</span>  <span class="comment"># 向量集大小</span></span><br><span class="line">    nq = <span class="number">10000</span>  <span class="comment"># 查询次数</span></span><br><span class="line">    np.random.seed(<span class="number">1234</span>)  <span class="comment"># 随机种子,使结果可复现</span></span><br><span class="line">    xb = np.random.random((nb, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xb[:, <span class="number">0</span>] += np.arange(nb) / <span class="number">1000.</span></span><br><span class="line">    xq = np.random.random((nq, d)).astype(<span class="string">'float32'</span>)</span><br><span class="line">    xq[:, <span class="number">0</span>] += np.arange(nq) / <span class="number">1000.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> faiss</span><br><span class="line">    </span><br><span class="line">    nlist = <span class="number">100</span></span><br><span class="line">    m = <span class="number">8</span></span><br><span class="line">    k = <span class="number">4</span></span><br><span class="line">    quantizer = faiss.IndexFlatL2(d)  <span class="comment"># 内部的索引方式依然不变</span></span><br><span class="line">    index = faiss.IndexIVFPQ(quantizer, d, nlist, m, <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 每个向量都被编码为8个字节大小</span></span><br><span class="line">    index.train(xb)</span><br><span class="line">    index.add(xb)</span><br><span class="line">    D, I = index.search(xb[:<span class="number">5</span>], k)  <span class="comment"># 测试</span></span><br><span class="line">    print(I)</span><br><span class="line">    print(D)</span><br><span class="line">    index.nprobe = <span class="number">10</span>  <span class="comment"># 与以前的方法相比</span></span><br><span class="line">    D, I = index.search(xq, k)  <span class="comment"># 检索</span></span><br><span class="line">    print(I[<span class="number">-5</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="k-means聚类"><a href="#k-means聚类" class="headerlink" title="k-means聚类"></a>k-means聚类</h2><p>聚类算法有很多种，<code>K-Means</code> 是聚类算法中的最常用的一种，算法最大的特点是简单，好理解，运算速度快，但是只能应用于连续型的数据，并且一定要在聚类前需要手工指定要分成几类。</p><h2 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h2><p>PCA（Principal Component Analysis） 是一种常见的数据分析方式，常用于高维数据的降维，可用于提取数据的主要特征分量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eg:</span></span><br><span class="line"><span class="comment"># IndexIVFPQ索引应该设定为256维，而不是2048维   </span></span><br><span class="line">coarse_quantizer = faiss.IndexFlatL2(<span class="number">256</span>) </span><br><span class="line">sub_index = faiss.IndexIVFPQ(coarse_quantizer, <span class="number">256</span>, ncoarse, <span class="number">16</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># PCA 2048-&gt;256   </span></span><br><span class="line"><span class="comment"># 在降维后进行了随机旋转(第四个参数)   </span></span><br><span class="line">pca_matrix = faiss.PCAMatrix(<span class="number">2048</span>, <span class="number">256</span>, <span class="number">0</span>, <span class="literal">True</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装索引   </span></span><br><span class="line">index = faiss.IndexPreTransform(pca_matrix, sub_index)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 也需要对PCA进行训练   </span></span><br><span class="line">index.train(...)</span><br><span class="line"><span class="comment"># PCA要比添加操作更早执行   </span></span><br><span class="line">index.add(...)</span><br></pre></td></tr></table></figure><h2 id="乘积量化-Product-Quantizer-，PQ解码"><a href="#乘积量化-Product-Quantizer-，PQ解码" class="headerlink" title="乘积量化(Product Quantizer)，PQ解码"></a>乘积量化(Product Quantizer)，PQ解码</h2><p> 为了扩展到非常大的数据集，Faiss提供了基于产品量化器的有损压缩来压缩存储的向量的变体。压缩的方法基于乘积量化(<code>Product Quantizer</code>)。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> faiss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python强大的数据分析利器——Pandas(2)</title>
      <link href="2021/01/05/pandas-2/"/>
      <url>2021/01/05/pandas-2/</url>
      
        <content type="html"><![CDATA[<p>这篇主要总结下<code>Pandas</code>数据分析相关操作。</p><a id="more"></a><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># series</span></span><br><span class="line">np.random.seed(<span class="number">1234</span>)</span><br><span class="line">d1 = pd.Series(<span class="number">2</span>*np.random.normal(size = <span class="number">100</span>)+<span class="number">3</span>)</span><br><span class="line">d2 = np.random.f(<span class="number">2</span>,<span class="number">4</span>,size = <span class="number">100</span>)</span><br><span class="line">d3 = np.random.randint(<span class="number">1</span>,<span class="number">100</span>,size = <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">d1.count()          <span class="comment">#非空元素计算</span></span><br><span class="line">d1.min()            <span class="comment">#最小值</span></span><br><span class="line">d1.max()            <span class="comment">#最大值</span></span><br><span class="line">d1.idxmin()         <span class="comment">#最小值的位置，类似于R中的which.min函数</span></span><br><span class="line">d1.idxmax()         <span class="comment">#最大值的位置，类似于R中的which.max函数</span></span><br><span class="line">d1.quantile(<span class="number">0.1</span>)    <span class="comment">#10%分位数</span></span><br><span class="line">d1.sum()            <span class="comment">#求和</span></span><br><span class="line">d1.mean()           <span class="comment">#均值</span></span><br><span class="line">d1.median()         <span class="comment">#中位数</span></span><br><span class="line">d1.mode()           <span class="comment">#众数</span></span><br><span class="line">d1.var()            <span class="comment">#方差</span></span><br><span class="line">d1.std()            <span class="comment">#标准差</span></span><br><span class="line">d1.mad()            <span class="comment">#平均绝对偏差</span></span><br><span class="line">d1.skew()           <span class="comment">#偏度</span></span><br><span class="line">d1.kurt()           <span class="comment">#峰度</span></span><br><span class="line">d1.describe()       <span class="comment">#一次性输出多个描述性统计指标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrame</span></span><br><span class="line">In [<span class="number">45</span>]: df = pd.DataFrame(np.array([d1,d2,d3]).T, columns=[<span class="string">'x1'</span>,<span class="string">'x2'</span>,<span class="string">'x3'</span>])</span><br><span class="line">In [<span class="number">47</span>]: df.describe()</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">               x1          x2          x3</span><br><span class="line">count  <span class="number">100.000000</span>  <span class="number">100.000000</span>  <span class="number">100.000000</span></span><br><span class="line">mean     <span class="number">3.070225</span>    <span class="number">2.028608</span>   <span class="number">51.490000</span></span><br><span class="line">std      <span class="number">2.001402</span>    <span class="number">3.194753</span>   <span class="number">27.930106</span></span><br><span class="line">min     <span class="number">-4.127033</span>    <span class="number">0.014330</span>    <span class="number">3.000000</span></span><br><span class="line"><span class="number">25</span>%      <span class="number">2.040101</span>    <span class="number">0.249580</span>   <span class="number">25.000000</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">3.204555</span>    <span class="number">1.000613</span>   <span class="number">54.500000</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">4.434788</span>    <span class="number">2.101581</span>   <span class="number">73.000000</span></span><br><span class="line">max      <span class="number">7.781921</span>   <span class="number">18.791565</span>   <span class="number">98.000000</span></span><br></pre></td></tr></table></figure><h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: s = pd.Series([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'Aaba'</span>, <span class="string">'Baca'</span>, np.nan, <span class="string">'CABA'</span>, <span class="string">'dog'</span>, <span class="string">'cat'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: s.str.lower()</span><br><span class="line">Out[<span class="number">2</span>]: </span><br><span class="line"><span class="number">0</span>       a</span><br><span class="line"><span class="number">1</span>       b</span><br><span class="line"><span class="number">2</span>       c</span><br><span class="line"><span class="number">3</span>    aaba</span><br><span class="line"><span class="number">4</span>    baca</span><br><span class="line"><span class="number">5</span>     NaN</span><br><span class="line"><span class="number">6</span>    caba</span><br><span class="line"><span class="number">7</span>     dog</span><br><span class="line"><span class="number">8</span>     cat</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: s.str.upper()</span><br><span class="line">Out[<span class="number">3</span>]: </span><br><span class="line"><span class="number">0</span>       A</span><br><span class="line"><span class="number">1</span>       B</span><br><span class="line"><span class="number">2</span>       C</span><br><span class="line"><span class="number">3</span>    AABA</span><br><span class="line"><span class="number">4</span>    BACA</span><br><span class="line"><span class="number">5</span>     NaN</span><br><span class="line"><span class="number">6</span>    CABA</span><br><span class="line"><span class="number">7</span>     DOG</span><br><span class="line"><span class="number">8</span>     CAT</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s.str.len()</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    NaN</span><br><span class="line"><span class="number">6</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">7</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">8</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>类似SQL的<code>join</code></p><p>默认是内连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: student = &#123;<span class="string">'Name'</span>:[<span class="string">'Bob'</span>,<span class="string">'Alice'</span>,<span class="string">'Carol'</span>,<span class="string">'Henry'</span>,<span class="string">'Judy'</span>,<span class="string">'Robert'</span>,<span class="string">'William'</span>],</span><br><span class="line">    ...:            <span class="string">'Age'</span>:[<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">24</span>],</span><br><span class="line">    ...:                       <span class="string">'Sex'</span>:[<span class="string">'M'</span>,<span class="string">'F'</span>,<span class="string">'M'</span>,<span class="string">'M'</span>,<span class="string">'F'</span>,<span class="string">'M'</span>,<span class="string">'F'</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: score = &#123;<span class="string">'Name'</span>:[<span class="string">'Bob'</span>,<span class="string">'Alice'</span>,<span class="string">'Carol'</span>,<span class="string">'Henry'</span>,<span class="string">'William'</span>],</span><br><span class="line">    ...:          <span class="string">'Score'</span>:[<span class="number">75</span>,<span class="number">35</span>,<span class="number">87</span>,<span class="number">86</span>,<span class="number">57</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: df_student = pd.DataFrame(student)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: df_score = pd.DataFrame(score)</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: stu_score1 = pd.merge(df_student, df_score, on=<span class="string">'Name'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: stu_score1</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">      Name  Age Sex  Score</span><br><span class="line"><span class="number">0</span>      Bob   <span class="number">12</span>   M     <span class="number">75</span></span><br><span class="line"><span class="number">1</span>    Alice   <span class="number">16</span>   F     <span class="number">35</span></span><br><span class="line"><span class="number">2</span>    Carol   <span class="number">13</span>   M     <span class="number">87</span></span><br><span class="line"><span class="number">3</span>    Henry   <span class="number">11</span>   M     <span class="number">86</span></span><br><span class="line"><span class="number">4</span>  William   <span class="number">24</span>   F     <span class="number">57</span></span><br></pre></td></tr></table></figure><p>还可以左连接、右连接、外连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左连接</span></span><br><span class="line">In [<span class="number">56</span>]: stu_score2 = pd.merge(df_student, df_score, on=<span class="string">'Name'</span>,how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: stu_score2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">      Name  Age Sex  Score</span><br><span class="line"><span class="number">0</span>      Bob   <span class="number">12</span>   M   <span class="number">75.0</span></span><br><span class="line"><span class="number">1</span>    Alice   <span class="number">16</span>   F   <span class="number">35.0</span></span><br><span class="line"><span class="number">2</span>    Carol   <span class="number">13</span>   M   <span class="number">87.0</span></span><br><span class="line"><span class="number">3</span>    Henry   <span class="number">11</span>   M   <span class="number">86.0</span></span><br><span class="line"><span class="number">4</span>     Judy   <span class="number">14</span>   F    NaN</span><br><span class="line"><span class="number">5</span>   Robert   <span class="number">15</span>   M    NaN</span><br><span class="line"><span class="number">6</span>  William   <span class="number">24</span>   F   <span class="number">57.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右连接</span></span><br><span class="line">In [<span class="number">59</span>]: stu_score3 = pd.merge(df_student, df_score, on=<span class="string">'Name'</span>,how=<span class="string">'right'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: stu_score3</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">      Name  Age Sex  Score</span><br><span class="line"><span class="number">0</span>      Bob   <span class="number">12</span>   M     <span class="number">75</span></span><br><span class="line"><span class="number">1</span>    Alice   <span class="number">16</span>   F     <span class="number">35</span></span><br><span class="line"><span class="number">2</span>    Carol   <span class="number">13</span>   M     <span class="number">87</span></span><br><span class="line"><span class="number">3</span>    Henry   <span class="number">11</span>   M     <span class="number">86</span></span><br><span class="line"><span class="number">4</span>  William   <span class="number">24</span>   F     <span class="number">57</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外连接</span></span><br><span class="line">In [<span class="number">63</span>]: stu_score4 = pd.merge(df_student, df_score, on=<span class="string">'Name'</span>,how=<span class="string">'outer'</span>)</span><br><span class="line">In [<span class="number">65</span>]: stu_score4</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">      Name  Age Sex  Score</span><br><span class="line"><span class="number">0</span>      Bob   <span class="number">12</span>   M   <span class="number">75.0</span></span><br><span class="line"><span class="number">1</span>    Alice   <span class="number">16</span>   F   <span class="number">35.0</span></span><br><span class="line"><span class="number">2</span>    Carol   <span class="number">13</span>   M   <span class="number">87.0</span></span><br><span class="line"><span class="number">3</span>    Henry   <span class="number">11</span>   M   <span class="number">86.0</span></span><br><span class="line"><span class="number">4</span>     Judy   <span class="number">14</span>   F    NaN</span><br><span class="line"><span class="number">5</span>   Robert   <span class="number">15</span>   M    NaN</span><br><span class="line"><span class="number">6</span>  William   <span class="number">24</span>   F   <span class="number">57.0</span></span><br></pre></td></tr></table></figure><h2 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: df = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>] * <span class="number">3</span>,</span><br><span class="line">    ...: <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>] * <span class="number">4</span>,</span><br><span class="line">    ...: <span class="string">'C'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>] * <span class="number">2</span>,</span><br><span class="line">    ...: <span class="string">'D'</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">    ...: <span class="string">'E'</span>: np.random.randn(<span class="number">12</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: df</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">        A  B    C         D         E</span><br><span class="line"><span class="number">0</span>     one  A  foo  <span class="number">0.587385</span> <span class="number">-0.631974</span></span><br><span class="line"><span class="number">1</span>     one  B  foo <span class="number">-0.445773</span> <span class="number">-0.933491</span></span><br><span class="line"><span class="number">2</span>     two  C  foo  <span class="number">0.260970</span>  <span class="number">0.549515</span></span><br><span class="line"><span class="number">3</span>   three  A  bar  <span class="number">0.794878</span>  <span class="number">0.712311</span></span><br><span class="line"><span class="number">4</span>     one  B  bar  <span class="number">1.356132</span>  <span class="number">0.196722</span></span><br><span class="line"><span class="number">5</span>     one  C  bar  <span class="number">0.018715</span> <span class="number">-3.491726</span></span><br><span class="line"><span class="number">6</span>     two  A  foo  <span class="number">0.996970</span>  <span class="number">0.905736</span></span><br><span class="line"><span class="number">7</span>   three  B  foo  <span class="number">1.249336</span>  <span class="number">0.199805</span></span><br><span class="line"><span class="number">8</span>     one  C  foo <span class="number">-0.797634</span> <span class="number">-1.270725</span></span><br><span class="line"><span class="number">9</span>     one  A  bar  <span class="number">0.508636</span>  <span class="number">0.393941</span></span><br><span class="line"><span class="number">10</span>    two  B  bar <span class="number">-0.990498</span> <span class="number">-1.230368</span></span><br><span class="line"><span class="number">11</span>  three  C  bar  <span class="number">0.353513</span> <span class="number">-0.263934</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: pd.pivot_table(df, values=<span class="string">'D'</span>, index=[<span class="string">'A'</span>, <span class="string">'B'</span>], columns=[<span class="string">'C'</span>])</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">C             bar       foo</span><br><span class="line">A     B                    </span><br><span class="line">one   A  <span class="number">0.508636</span>  <span class="number">0.587385</span></span><br><span class="line">      B  <span class="number">1.356132</span> <span class="number">-0.445773</span></span><br><span class="line">      C  <span class="number">0.018715</span> <span class="number">-0.797634</span></span><br><span class="line">three A  <span class="number">0.794878</span>       NaN</span><br><span class="line">      B       NaN  <span class="number">1.249336</span></span><br><span class="line">      C  <span class="number">0.353513</span>       NaN</span><br><span class="line">two   A       NaN  <span class="number">0.996970</span></span><br><span class="line">      B <span class="number">-0.990498</span>       NaN</span><br><span class="line">      C       NaN  <span class="number">0.260970</span></span><br></pre></td></tr></table></figure><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>默缺失值会设置成<code>NaN</code>，但是如果需要参与运算需要我们对数据进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">67</span>]: df = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,np.nan],</span><br><span class="line">    ...:                   [<span class="number">12</span>,<span class="number">23</span>,<span class="number">43</span>],[<span class="number">55</span>,np.nan,<span class="number">10</span>],</span><br><span class="line">    ...:                   [np.nan,np.nan,np.nan],[np.nan,<span class="number">1</span>,<span class="number">2</span>]],</span><br><span class="line">    ...:                   columns=[<span class="string">'a1'</span>,<span class="string">'a2'</span>,<span class="string">'a3'</span>])</span><br></pre></td></tr></table></figure><h3 id="删除法"><a href="#删除法" class="headerlink" title="删除法"></a>删除法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: df.dropna()</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">     a1    a2    a3</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">12.0</span>  <span class="number">23.0</span>  <span class="number">43.0</span></span><br></pre></td></tr></table></figure><h3 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 填0值</span></span><br><span class="line">In [<span class="number">69</span>]: df.fillna(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">     a1    a2    a3</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">12.0</span>  <span class="number">23.0</span>  <span class="number">43.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">55.0</span>   <span class="number">0.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用前一个数据填充 df.fillna(method='bfill') 后一个值</span></span><br><span class="line">In [<span class="number">70</span>]: df.fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">     a1    a2    a3</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">12.0</span>  <span class="number">23.0</span>  <span class="number">43.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">55.0</span>  <span class="number">23.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">55.0</span>  <span class="number">23.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">55.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量填充</span></span><br><span class="line">In [<span class="number">71</span>]: df.fillna(&#123;<span class="string">'a1'</span>:<span class="number">100</span>,<span class="string">'a2'</span>:<span class="number">200</span>,<span class="string">'a3'</span>:<span class="number">300</span>&#125;)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      a1     a2     a3</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span>    <span class="number">2.0</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3.0</span>    <span class="number">4.0</span>  <span class="number">300.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">12.0</span>   <span class="number">23.0</span>   <span class="number">43.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">55.0</span>  <span class="number">200.0</span>   <span class="number">10.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">100.0</span>  <span class="number">200.0</span>  <span class="number">300.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">100.0</span>    <span class="number">1.0</span>    <span class="number">2.0</span></span><br></pre></td></tr></table></figure><h2 id="数据打乱"><a href="#数据打乱" class="headerlink" title="数据打乱"></a>数据打乱</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = df.sample(frac=<span class="number">0.3</span>) <span class="comment"># frac 返回的比例 0.3代表30%</span></span><br><span class="line">df.sample(frac=<span class="number">0.1</span>).reset_index(drop=<span class="literal">True</span>) <span class="comment"># 重建索引</span></span><br></pre></td></tr></table></figure><h2 id="按行遍历"><a href="#按行遍历" class="headerlink" title="按行遍历"></a>按行遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于每一行， 可以通过列名name访问对应的元素</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    print(row[<span class="string">'c1'</span>], row[<span class="string">'c2'</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python强大的数据分析利器——Pandas(1)</title>
      <link href="2021/01/04/pandas-1/"/>
      <url>2021/01/04/pandas-1/</url>
      
        <content type="html"><![CDATA[<p><code>Pandas</code>是我最喜欢的<code>python</code>库之一，不只是功能强大，它的<code>API</code>也是非常的优雅。</p><a id="more"></a><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p><code>Series</code>和原生的字典很像，<code>index</code>相当于字典的<code>key</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">8.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p><code>index</code>如果不指定就会默认用<code>0,1,2,3...</code>这个自然序。当然也是可以指定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: index = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: s</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="Dataframe输入"><a href="#Dataframe输入" class="headerlink" title="Dataframe输入"></a>Dataframe输入</h2><p><code>DataFrame</code>是<code>pandas</code>中最重要的数据结构，它有着非常多灵活的创建方式。</p><h3 id="by字典"><a href="#by字典" class="headerlink" title="by字典"></a>by字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series</span></span><br><span class="line">In [<span class="number">9</span>]: d = &#123;<span class="string">'one'</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</span><br><span class="line">   ...:  <span class="string">'two'</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: df</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">d  NaN  <span class="number">4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list</span></span><br><span class="line">In [<span class="number">14</span>]: d = &#123;<span class="string">'one'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: pd.DataFrame(d)</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">   one  two</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4</span>    <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from_dict</span></span><br><span class="line">In [<span class="number">57</span>]: pd.DataFrame.from_dict(dict([(<span class="string">'A'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), (<span class="string">'B'</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])]))</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">   A  B</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="by字典数组"><a href="#by字典数组" class="headerlink" title="by字典数组"></a>by字典数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: l = [&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">6</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">11</span>, <span class="string">'b'</span>: <span class="number">12</span>, <span class="string">'c'</span>: <span class="number">0</span>&#125;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: pd.DataFrame(l)</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">    a   b    c</span><br><span class="line"><span class="number">0</span>   <span class="number">5</span>   <span class="number">6</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h3 id="by多维数组"><a href="#by多维数组" class="headerlink" title="by多维数组"></a>by多维数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: d = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: pd.DataFrame(d)</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="by-SQL"><a href="#by-SQL" class="headerlink" title="by SQL"></a>by SQL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install pymysql</span></span><br><span class="line"><span class="comment"># pip install sqlalchemy</span></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">In [<span class="number">4</span>]: engine = create_engine(<span class="string">'mysql+pymysql://root:test@localhost:3306/spark'</span>)</span><br><span class="line">In [<span class="number">5</span>]: sql = <span class="string">"select * from student"</span></span><br><span class="line">In [<span class="number">6</span>]: df = pd.read_sql_query(sql, engine)</span><br><span class="line">In [<span class="number">7</span>]: df</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">   id      name gender  age</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   Xueqian      F   <span class="number">23</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>  Weiliang      M   <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="by-CSV-EXCEL-HDF"><a href="#by-CSV-EXCEL-HDF" class="headerlink" title="by CSV,EXCEL,HDF"></a>by CSV,EXCEL,HDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># read_excel, read_hdf同理</span></span><br><span class="line">In [<span class="number">10</span>]: df = pd.read_csv(<span class="string">'data.csv'</span>, sep=<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">   name  age</span><br><span class="line"><span class="number">0</span>  jack   <span class="number">18</span></span><br><span class="line"><span class="number">1</span>  lily   <span class="number">20</span></span><br></pre></td></tr></table></figure><p>从上面的示例我们可以发现，<code>pandas</code>自动将缺失值处理成了<code>NaN</code>。</p><h2 id="DataFrame数据输出"><a href="#DataFrame数据输出" class="headerlink" title="DataFrame数据输出"></a>DataFrame数据输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.to_hdf(<span class="string">'foo.h5'</span>, <span class="string">'df'</span>)</span><br><span class="line">df.to_csv(<span class="string">'foo.csv'</span>)</span><br><span class="line">df.to_excel(<span class="string">'foo.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure><h2 id="DataFrame访问数据"><a href="#DataFrame访问数据" class="headerlink" title="DataFrame访问数据"></a>DataFrame访问数据</h2><p>数据初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: dates = pd.date_range(<span class="string">'1/1/2020'</span>, periods=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: df = pd.DataFrame(np.random.randn(<span class="number">8</span>, <span class="number">4</span>),</span><br><span class="line">   ...:                   index=dates, columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: df</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">1.540781</span>  <span class="number">1.056957</span>  <span class="number">2.368582</span> <span class="number">-1.388904</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span> <span class="number">-1.693985</span>  <span class="number">0.605021</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.708602</span>  <span class="number">0.961322</span> <span class="number">-0.210920</span>  <span class="number">0.670033</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.952370</span> <span class="number">-2.306830</span>  <span class="number">0.078056</span> <span class="number">-0.090901</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.143606</span>  <span class="number">1.434278</span>  <span class="number">1.168140</span>  <span class="number">1.079450</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.665699</span> <span class="number">-1.892689</span>  <span class="number">1.632554</span>  <span class="number">0.243764</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-07</span> <span class="number">-0.317191</span>  <span class="number">0.541485</span>  <span class="number">1.037746</span>  <span class="number">0.263215</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-08</span>  <span class="number">0.095929</span>  <span class="number">0.657138</span> <span class="number">-1.048893</span> <span class="number">-0.904121</span></span><br></pre></td></tr></table></figure><h3 id="选择列"><a href="#选择列" class="headerlink" title="选择列"></a>选择列</h3><p>选择单列，产生 Series，与 df.A 等效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: df[<span class="string">'A'</span>]</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>    <span class="number">1.540781</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">0.319485</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span>   <span class="number">-0.708602</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span>   <span class="number">-0.952370</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-05</span>   <span class="number">-0.143606</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">0.665699</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-07</span>   <span class="number">-0.317191</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-08</span>    <span class="number">0.095929</span></span><br><span class="line">Freq: D, Name: A, dtype: float64</span><br></pre></td></tr></table></figure><h3 id="选择行"><a href="#选择行" class="headerlink" title="选择行"></a>选择行</h3><p>类似数组切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: df[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">1.540781</span>  <span class="number">1.056957</span>  <span class="number">2.368582</span> <span class="number">-1.388904</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span> <span class="number">-1.693985</span>  <span class="number">0.605021</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.708602</span>  <span class="number">0.961322</span> <span class="number">-0.210920</span>  <span class="number">0.670033</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: df[<span class="string">'2020-01-02'</span>: <span class="string">'2020-01-04'</span>]</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span> <span class="number">-1.693985</span>  <span class="number">0.605021</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.708602</span>  <span class="number">0.961322</span> <span class="number">-0.210920</span>  <span class="number">0.670033</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.952370</span> <span class="number">-2.306830</span>  <span class="number">0.078056</span> <span class="number">-0.090901</span></span><br></pre></td></tr></table></figure><h3 id="操作符访问"><a href="#操作符访问" class="headerlink" title="操作符访问"></a>操作符访问</h3><p>df支持4种方式访问行列，<code>ix</code>在新版本<code>pandas</code>中已经废弃</p><ul><li>loc  按index标签选择</li><li>at   同loc 只能访问单个元素</li><li>iloc 按索引位置选择</li><li>iat  同iloc 只能访问单个元素</li></ul><h4 id="loc"><a href="#loc" class="headerlink" title="loc"></a>loc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: df.loc[<span class="string">'2020-01-02'</span>:<span class="string">'2020-01-04'</span>, [<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.708602</span>  <span class="number">0.961322</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.952370</span> <span class="number">-2.306830</span></span><br></pre></td></tr></table></figure><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># at</span></span><br><span class="line">In [<span class="number">20</span>]: df.at[<span class="string">'2020-01-02'</span>, <span class="string">'A'</span>]</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">0.3194852199254171</span></span><br></pre></td></tr></table></figure><h4 id="iloc"><a href="#iloc" class="headerlink" title="iloc"></a>iloc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: df.iloc[<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">A   <span class="number">-0.952370</span></span><br><span class="line">B   <span class="number">-2.306830</span></span><br><span class="line">C    <span class="number">0.078056</span></span><br><span class="line">D   <span class="number">-0.090901</span></span><br><span class="line">Name: <span class="number">2020</span><span class="number">-01</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>, dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维切片</span></span><br><span class="line">In [<span class="number">18</span>]: df.iloc[<span class="number">3</span>:<span class="number">5</span>, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.952370</span> <span class="number">-2.306830</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.143606</span>  <span class="number">1.434278</span></span><br></pre></td></tr></table></figure><h4 id="iat"><a href="#iat" class="headerlink" title="iat"></a>iat</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iat</span></span><br><span class="line">In [<span class="number">19</span>]: df.iat[<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">19</span>]: <span class="number">-0.9523699346168295</span></span><br></pre></td></tr></table></figure><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><h4 id="支持多个-amp-运算符"><a href="#支持多个-amp-运算符" class="headerlink" title="支持多个&amp; | 运算符"></a>支持多个<code>&amp; |</code> 运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列选择</span></span><br><span class="line">In [<span class="number">27</span>]: df[df.A &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">1.540781</span>  <span class="number">1.056957</span>  <span class="number">2.368582</span> <span class="number">-1.388904</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span> <span class="number">-1.693985</span>  <span class="number">0.605021</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.665699</span> <span class="number">-1.892689</span>  <span class="number">1.632554</span>  <span class="number">0.243764</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-08</span>  <span class="number">0.095929</span>  <span class="number">0.657138</span> <span class="number">-1.048893</span> <span class="number">-0.904121</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个条件</span></span><br><span class="line">In [<span class="number">28</span>]: df[(df.A &gt; <span class="number">0</span>)&amp;(df.B &lt; <span class="number">0</span>)]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.665699</span> <span class="number">-1.892689</span>  <span class="number">1.632554</span>  <span class="number">0.243764</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个df</span></span><br><span class="line">In [<span class="number">29</span>]: df[df &gt; <span class="number">0</span> ]</span><br><span class="line">Out[<span class="number">29</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">1.540781</span>  <span class="number">1.056957</span>  <span class="number">2.368582</span>       NaN</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span>       NaN  <span class="number">0.605021</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-03</span>       NaN  <span class="number">0.961322</span>       NaN  <span class="number">0.670033</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-04</span>       NaN       NaN  <span class="number">0.078056</span>       NaN</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-05</span>       NaN  <span class="number">1.434278</span>  <span class="number">1.168140</span>  <span class="number">1.079450</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.665699</span>       NaN  <span class="number">1.632554</span>  <span class="number">0.243764</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-07</span>       NaN  <span class="number">0.541485</span>  <span class="number">1.037746</span>  <span class="number">0.263215</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-08</span>  <span class="number">0.095929</span>  <span class="number">0.657138</span>       NaN       NaN</span><br></pre></td></tr></table></figure><h4 id="支持isin函数"><a href="#支持isin函数" class="headerlink" title="支持isin函数"></a>支持isin函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df[<span class="string">'E'</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: df[df[<span class="string">'E'</span>].isin([<span class="number">1</span>, <span class="number">2</span>])]</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">                   A         B         C         D  E</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">1.540781</span>  <span class="number">1.056957</span>  <span class="number">2.368582</span> <span class="number">-1.388904</span>  <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.319485</span>  <span class="number">0.199442</span> <span class="number">-1.693985</span>  <span class="number">0.605021</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faiss使用文档（1）—— 环境搭建</title>
      <link href="2021/01/01/faiss-1/"/>
      <url>2021/01/01/faiss-1/</url>
      
        <content type="html"><![CDATA[<p><code>faiss</code>是<code>Facebook Ai Research</code>开源的一款向量检索工具。这篇介绍一下它的环境搭建。</p><a id="more"></a><p>首先，用<code>pip</code>安装<code>faiss</code>，执行代码时会抛出<code>ModuleNotFoundError: No module named &#39;_swigfaiss&#39;</code>这个<code>Exception</code>，通常科学计算相关的环境搭建更推荐使用<code>conda</code></p><h2 id="安装CPU版本"><a href="#安装CPU版本" class="headerlink" title="安装CPU版本"></a>安装CPU版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#先安装mkl（英特尔数学核心函数库，可以大幅提升CPU训练速度）</span><br><span class="line">conda install mkl</span><br><span class="line">#安装faiss-cpu</span><br><span class="line">conda install faiss-cpu -c pytorch</span><br><span class="line">#测试安装是否成功</span><br><span class="line">python -c &quot;import faiss&quot;</span><br></pre></td></tr></table></figure><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>首先安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update # 更新 apt</span><br><span class="line">sudo apt install gcc g++ make # 安装 gcc g++ make</span><br><span class="line">sudo apt install libglu1-mesa libxi-dev libxmu-dev libglu1-mesa-dev freeglut3-dev # 安装依赖库</span><br></pre></td></tr></table></figure><p>在<a href="https://developer.nvidia.com/zh-cn/cuda-toolkit" target="_blank" rel="noopener">cuda官方下载页面</a>选择合适的版本。</p><p>下载<code>toolkit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run</span><br></pre></td></tr></table></figure><p>执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cuda_10.1.243_418.87.00_linux.run</span><br></pre></td></tr></table></figure><h2 id="安装GPU版本"><a href="#安装GPU版本" class="headerlink" title="安装GPU版本"></a>安装GPU版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 确保已经安装了CUDA，否则会自动安装CPU版本。</span><br><span class="line">conda install faiss-gpu -c pytorch # 默认 For CUDA8.0</span><br><span class="line">conda install faiss-gpu cuda90 -c pytorch # For CUDA9.0</span><br><span class="line">conda install faiss-gpu cuda91 -c pytorch # For CUDA9.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> faiss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门（4）—— UDF</title>
      <link href="2020/12/31/spark-udf/"/>
      <url>2020/12/31/spark-udf/</url>
      
        <content type="html"><![CDATA[<p><code>UDF</code>（User Defined Functions）是用户自定义单行操作的函数。</p><h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><a id="more"></a><p>最简单无参数示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.functions.udf</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.udf</span><br><span class="line">scala&gt; <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">"UDF"</span>).getOrCreate()</span><br><span class="line"><span class="comment">// 定义random函数</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> random = udf(() =&gt; <span class="type">Math</span>.random())</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">scala&gt; spark.udf.register(<span class="string">"random"</span>, random.asNondeterministic())</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">scala&gt; spark.sql(<span class="string">"SELECT random()"</span>).show()</span><br><span class="line">+------------------+</span><br><span class="line">|             <span class="type">UDF</span>()|</span><br><span class="line">+------------------+</span><br><span class="line">|<span class="number">0.9792369214901931</span>|</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>带参数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并注册带参数 x: Int 的UDF</span></span><br><span class="line"><span class="keyword">val</span> plusOne = udf((x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span>)</span><br><span class="line">spark.udf.register(<span class="string">"plusOne"</span>, plusOne)</span><br><span class="line">spark.sql(<span class="string">"SELECT plusOne(5)"</span>).show()</span><br><span class="line"><span class="comment">// +------+</span></span><br><span class="line"><span class="comment">// |UDF(5)|</span></span><br><span class="line"><span class="comment">// +------+</span></span><br><span class="line"><span class="comment">// |     6|</span></span><br><span class="line"><span class="comment">// +------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次定义带两个参数的UDF</span></span><br><span class="line">spark.udf.register(<span class="string">"strLenScala"</span>, (_: <span class="type">String</span>).length + (_: <span class="type">Int</span>))</span><br><span class="line">spark.sql(<span class="string">"SELECT strLenScala('test', 1)"</span>).show()</span><br><span class="line"><span class="comment">// +--------------------+</span></span><br><span class="line"><span class="comment">// |strLenScala(test, 1)|</span></span><br><span class="line"><span class="comment">// +--------------------+</span></span><br><span class="line"><span class="comment">// |                   5|</span></span><br><span class="line"><span class="comment">// +--------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在where条件中使用UDF</span></span><br><span class="line">spark.udf.register(<span class="string">"oneArgFilter"</span>, (n: <span class="type">Int</span>) =&gt; &#123; n &gt; <span class="number">5</span> &#125;)</span><br><span class="line">spark.range(<span class="number">1</span>, <span class="number">10</span>).createOrReplaceTempView(<span class="string">"test"</span>)</span><br><span class="line">spark.sql(<span class="string">"SELECT * FROM test WHERE oneArgFilter(id)"</span>).show()</span><br><span class="line"><span class="comment">// +---+</span></span><br><span class="line"><span class="comment">// | id|</span></span><br><span class="line"><span class="comment">// +---+</span></span><br><span class="line"><span class="comment">// |  6|</span></span><br><span class="line"><span class="comment">// |  7|</span></span><br><span class="line"><span class="comment">// |  8|</span></span><br><span class="line"><span class="comment">// |  9|</span></span><br><span class="line"><span class="comment">// +---+</span></span><br></pre></td></tr></table></figure><h2 id="UDAFs"><a href="#UDAFs" class="headerlink" title="UDAFs"></a>UDAFs</h2><p><code>UDAFs</code>(User Defined Aggregate Functions)是用户自定义聚合操作函数。</p><p>它支持三种聚合器</p><ul><li>IN</li><li>BUF</li><li>OUT</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">Encoder</span>, <span class="type">Encoders</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">Aggregator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, salary: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Average</span>(<span class="params">var sum: <span class="type">Long</span>, var count: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyAverage</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">Employee</span>, <span class="type">Average</span>, <span class="type">Double</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// A zero value for this aggregation. Should satisfy the property that any b + zero = b</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">Average</span> = <span class="type">Average</span>(<span class="number">0</span>L, <span class="number">0</span>L)</span><br><span class="line">  <span class="comment">// Combine two values to produce a new value. For performance, the function may modify `buffer`</span></span><br><span class="line">  <span class="comment">// and return it instead of constructing a new object</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(buffer: <span class="type">Average</span>, employee: <span class="type">Employee</span>): <span class="type">Average</span> = &#123;</span><br><span class="line">    buffer.sum += employee.salary</span><br><span class="line">    buffer.count += <span class="number">1</span></span><br><span class="line">    buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Merge two intermediate values</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">Average</span>, b2: <span class="type">Average</span>): <span class="type">Average</span> = &#123;</span><br><span class="line">    b1.sum += b2.sum</span><br><span class="line">    b1.count += b2.count</span><br><span class="line">    b1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Transform the output of the reduction</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(reduction: <span class="type">Average</span>): <span class="type">Double</span> = reduction.sum.toDouble / reduction.count</span><br><span class="line">  <span class="comment">// Specifies the Encoder for the intermediate value type</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Average</span>] = <span class="type">Encoders</span>.product</span><br><span class="line">  <span class="comment">// Specifies the Encoder for the final output value type</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = spark.read.json(<span class="string">"employees.json"</span>).as[<span class="type">Employee</span>]</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Employee</span>] = [name: string, salary: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; ds.show()</span><br><span class="line">+-------+------+</span><br><span class="line">|   name|salary|</span><br><span class="line">+-------+------+</span><br><span class="line">|<span class="type">Michael</span>|  <span class="number">3000</span>|</span><br><span class="line">|   <span class="type">Jack</span>|  <span class="number">2000</span>|</span><br><span class="line">| <span class="type">Justin</span>|  <span class="number">4500</span>|</span><br><span class="line">|    <span class="type">Ame</span>|  <span class="number">8000</span>|</span><br><span class="line">+-------+------+</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> averageSalary = <span class="type">MyAverage</span>.toColumn.name(<span class="string">"average_salary"</span>)</span><br><span class="line">averageSalary: org.apache.spark.sql.<span class="type">TypedColumn</span>[<span class="type">Employee</span>,<span class="type">Double</span>] = myaverage(knownnotnull(assertnotnull(input[<span class="number">0</span>, <span class="type">Average</span>, <span class="literal">true</span>])).sum <span class="type">AS</span> `sum`, knownnotnull(assertnotnull(input[<span class="number">0</span>, <span class="type">Average</span>, <span class="literal">true</span>])).count <span class="type">AS</span> `count`, newInstance(<span class="class"><span class="keyword">class</span> <span class="title">Average</span>), <span class="title">boundreference</span>(<span class="params"></span>)) <span class="title">AS</span> `<span class="title">average_salary</span>`</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">result</span> </span>= ds.select(averageSalary)</span><br><span class="line">result: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Double</span>] = [average_salary: double]</span><br><span class="line"></span><br><span class="line">scala&gt; result.show()</span><br><span class="line">+--------------+</span><br><span class="line">|average_salary|</span><br><span class="line">+--------------+</span><br><span class="line">|        <span class="number">4375.0</span>|</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门（3）—— SQL&amp;DataFrame</title>
      <link href="2020/12/31/spark-sql/"/>
      <url>2020/12/31/spark-sql/</url>
      
        <content type="html"><![CDATA[<p><code>Spark SQL</code>是Spark生态系统中非常重要的组件，其前身为Shark。Shark是Spark上的数据仓库，最初设计成与Hive兼容，但是该项目于2014年开始停止开发，转向Spark SQL。Spark SQL全面继承了Shark，并进行了优化。</p><a id="more"></a><h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><p>spark SQL是spark的一个模块，主要用于进行结构化数据的处理。它提供的最核心的编程抽象就是DataFrame。</p><p>提供一个编程抽象（DataFrame） 并且作为分布式 SQL 查询引擎</p><p>DataFrame：它可以根据很多源进行构建，包括：结构化的数据文件，hive中的表，外部的关系型数据库，以及RDD</p><p>（1）容易整合</p><p>（2）统一的数据访问方式</p><p>（3）兼容 Hive</p><p>（4）标准的数据连接</p><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p><code>DataFrame</code>是一种以<code>RDD</code>为基础的分布式数据集，类似于传统数据库中的二维表格。<br><code>DataFrame</code>的推出，让<code>Spark</code>具备了处理大规模结构化数据的能力，不仅比原有的<code>RDD</code>转化方式更加简单易用，而且获得了更高的计算性能。<code>Spark</code>能够轻松实现从<code>MySQL</code>到<code>DataFrame</code>的转化，并且支持<code>SQL</code>查询。</p><p>创建一个<code>people.json</code>文件并写入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Michael"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Andy"</span>, <span class="attr">"age"</span>:<span class="number">30</span>&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Justin"</span>, <span class="attr">"age"</span>:<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p>在<code>shell</code>中执行下面语句</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span>  spark=<span class="type">SparkSession</span>.builder().getOrCreate()</span><br><span class="line">spark: org.apache.spark.sql.<span class="type">SparkSession</span> = org.apache.spark.sql.<span class="type">SparkSession</span><span class="meta">@e</span>83d546</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">"file:///usr/local/Cellar/apache-spark/3.0.1/people.json"</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint, name: string]</span><br></pre></td></tr></table></figure><p>然后就可以用生成的<code>df</code>对象执行一系列的操作，这些<code>API</code>和<code>Python</code>中<code>pandas</code>生成的<code>DataFrame</code>非常相似。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印模式信息</span></span><br><span class="line">scala&gt; df.printSchema()</span><br><span class="line">root</span><br><span class="line"> |-- age: long (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- name: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 选择多列</span></span><br><span class="line">scala&gt; df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)+<span class="number">1</span>).show()</span><br><span class="line">+-------+---------+</span><br><span class="line">|   name|(age + <span class="number">1</span>)|</span><br><span class="line">+-------+---------+</span><br><span class="line">|<span class="type">Michael</span>|     <span class="literal">null</span>|</span><br><span class="line">|   <span class="type">Andy</span>|       <span class="number">31</span>|</span><br><span class="line">| <span class="type">Justin</span>|       <span class="number">20</span>|</span><br><span class="line">+-------+---------+</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 条件过滤</span></span><br><span class="line">scala&gt; df.filter(df(<span class="string">"age"</span>) &gt; <span class="number">20</span> ).show()</span><br><span class="line">+---+----+</span><br><span class="line">|age|name|</span><br><span class="line">+---+----+</span><br><span class="line">| <span class="number">30</span>|<span class="type">Andy</span>|</span><br><span class="line">+---+----+</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 分组聚合</span></span><br><span class="line">scala&gt; df.groupBy(<span class="string">"age"</span>).count().show()</span><br><span class="line">+----+-----+</span><br><span class="line">| age|count|</span><br><span class="line">+----+-----+</span><br><span class="line">|  <span class="number">19</span>|    <span class="number">1</span>|</span><br><span class="line">|<span class="literal">null</span>|    <span class="number">1</span>|</span><br><span class="line">|  <span class="number">30</span>|    <span class="number">1</span>|</span><br><span class="line">+----+-----+</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">scala&gt; df.sort(df(<span class="string">"age"</span>).desc).show()</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">+----+-------+</span><br><span class="line"> </span><br><span class="line"><span class="comment">//多列排序</span></span><br><span class="line">scala&gt; df.sort(df(<span class="string">"age"</span>).desc, df(<span class="string">"name"</span>).asc).show()</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">+----+-------+</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对列进行重命名</span></span><br><span class="line">scala&gt; df.select(df(<span class="string">"name"</span>).as(<span class="string">"username"</span>),df(<span class="string">"age"</span>)).show()</span><br><span class="line">+--------+----+</span><br><span class="line">|username| age|</span><br><span class="line">+--------+----+</span><br><span class="line">| <span class="type">Michael</span>|<span class="literal">null</span>|</span><br><span class="line">|    <span class="type">Andy</span>|  <span class="number">30</span>|</span><br><span class="line">|  <span class="type">Justin</span>|  <span class="number">19</span>|</span><br><span class="line">+--------+----+</span><br></pre></td></tr></table></figure><h2 id="RDD转换成DataFrame"><a href="#RDD转换成DataFrame" class="headerlink" title="RDD转换成DataFrame"></a>RDD转换成DataFrame</h2><ol><li>通过<code>case class</code>创建（反射）</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>(<span class="params">var name:<span class="type">String</span>,var age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">TestDataFrame1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"RDDToDataFrame"</span>).setMaster(<span class="string">"local"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> context = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br><span class="line">    <span class="comment">// 将本地的数据读入 RDD， 并将 RDD 与 case class 关联</span></span><br><span class="line">    <span class="keyword">val</span> peopleRDD = sc.textFile(<span class="string">"E:\\666\\people.txt"</span>)</span><br><span class="line">      .map(line =&gt; <span class="type">People</span>(line.split(<span class="string">","</span>)(<span class="number">0</span>), line.split(<span class="string">","</span>)(<span class="number">1</span>).trim.toInt))</span><br><span class="line">    <span class="keyword">import</span> context.implicits._</span><br><span class="line">    <span class="comment">// 将RDD 转换成 DataFrames</span></span><br><span class="line">    <span class="keyword">val</span> df = peopleRDD.toDF</span><br><span class="line">    <span class="comment">//将DataFrames创建成一个临时的视图</span></span><br><span class="line">    df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">    <span class="comment">//使用SQL语句进行查询</span></span><br><span class="line">    context.sql(<span class="string">"select * from people"</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>structType</code>创建（编程接口）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">object TestDataFrame2 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit &#x3D; &#123;</span><br><span class="line">    val conf &#x3D; new SparkConf().setAppName(&quot;TestDataFrame2&quot;).setMaster(&quot;local&quot;)</span><br><span class="line">    val sc &#x3D; new SparkContext(conf)</span><br><span class="line">    val sqlContext &#x3D; new SQLContext(sc)</span><br><span class="line">    val fileRDD &#x3D; sc.textFile(&quot;E:\\666\\people.txt&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将 RDD 数据映射成 Row，需要 import org.apache.spark.sql.Row</span><br><span class="line">    val rowRDD: RDD[Row] &#x3D; fileRDD.map(line &#x3D;&gt; &#123;</span><br><span class="line">      val fields &#x3D; line.split(&quot;,&quot;)</span><br><span class="line">      Row(fields(0), fields(1).trim.toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 创建 StructType 来定义结构</span><br><span class="line">    val structType: StructType &#x3D; StructType(</span><br><span class="line">      &#x2F;&#x2F;字段名，字段类型，是否可以为空</span><br><span class="line">      StructField(&quot;name&quot;, StringType, true) ::</span><br><span class="line">        StructField(&quot;age&quot;, IntegerType, true) :: Nil</span><br><span class="line">    )</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * rows: java.util.List[Row],</span><br><span class="line">      * schema: StructType</span><br><span class="line">      * *&#x2F;</span><br><span class="line">    val df: DataFrame &#x3D; sqlContext.createDataFrame(rowRDD,structType)</span><br><span class="line">    df.createOrReplaceTempView(&quot;people&quot;)</span><br><span class="line">    sqlContext.sql(&quot;select * from people&quot;).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>json</code>文件创建</li></ol><p>参考前面的示例。</p><h2 id="使用SQL"><a href="#使用SQL" class="headerlink" title="使用SQL"></a>使用SQL</h2><p>可以直接使用<code>SQL</code>对<code>DataFrame</code>操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册临时视图</span></span><br><span class="line">scala&gt; df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> sqlDF = spark.sql(<span class="string">"SELECT * FROM people"</span>)</span><br><span class="line">sqlDF: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint, name: string]</span><br><span class="line"></span><br><span class="line">scala&gt; sqlDF.show()</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门（2）—— RDD</title>
      <link href="2020/12/31/spark-RDD/"/>
      <url>2020/12/31/spark-RDD/</url>
      
        <content type="html"><![CDATA[<p><code>RDD</code>是<code>Spark</code>中最基本的数据抽象，初识<code>RDD</code>也是非常难以理解。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在学习Spark运行架构之前，需要先了解几个重要的概念：</p><ul><li>RDD：是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型；</li><li>DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系；</li><li>Executor：是运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据；</li><li>应用：用户编写的Spark应用程序；</li><li>任务：运行在Executor上的工作单元；</li><li>作业：一个作业包含多个RDD及作用于相应RDD上的各种操作；</li><li>阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。</li></ul><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><p><code>RDD（Resilient Distributed Dataset）</code>叫做弹性分布式数据集，是<code>Spark</code>中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。</p><p>下图是以<code>WordCount</code>精图解<code>RDD</code></p><p><img src="https://pic.hupai.pro/img/1228818-20180421133911520-1150689001.png" alt="WordCount"></p><h2 id="RDD创建"><a href="#RDD创建" class="headerlink" title="RDD创建"></a>RDD创建</h2><ol><li>通过文件创建</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> textFile = sc.textFile(<span class="string">"file:///usr/local/Cellar/apache-spark/3.0.1/word.txt"</span>)</span><br><span class="line">textFile: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = file:<span class="comment">///usr/local/Cellar/apache-spark/3.0.1/word.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:24</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过数据集合并行化的方式创建</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"Hadoop"</span>, <span class="string">"Spark"</span>, <span class="string">"Hive"</span>, <span class="string">"Spark"</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="type">Hadoop</span>, <span class="type">Spark</span>, <span class="type">Hive</span>, <span class="type">Spark</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.parallelize(list)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">4</span>] at parallelize at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> pairRDD = rdd.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line">pairRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">5</span>] at map at &lt;console&gt;:<span class="number">25</span></span><br></pre></td></tr></table></figure><ol start="3"><li>其他方式<br>读取数据库、其它<code>RDD</code>转化等方式也可以生成<code>RDD</code></li></ol><h2 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h2><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>常用的键值对转换操作包括reduceByKey()、groupByKey()、sortByKey()、join()、cogroup()等，下面我们通过实例来介绍。</p><p>准备工作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"Hadoop"</span>,<span class="string">"Spark"</span>,<span class="string">"Hive"</span>,<span class="string">"Spark"</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="type">Hadoop</span>, <span class="type">Spark</span>, <span class="type">Hive</span>, <span class="type">Spark</span>)</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.parallelize(list)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">11</span>] at parallelize at &lt;console&gt;:<span class="number">29</span></span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> pairRDD = rdd.map(word =&gt; (word,<span class="number">1</span>))</span><br><span class="line">pairRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">12</span>] at map at &lt;console&gt;:<span class="number">31</span></span><br><span class="line"> </span><br><span class="line">scala&gt; pairRDD.foreach(println)</span><br><span class="line">(<span class="type">Hadoop</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Hive</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>filter(func)<br>筛选出满足函数func的元素</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD1.filter( x =&gt; x._1 == <span class="string">"spark"</span>).foreach(println)</span><br><span class="line">(spark,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>map(func)<br>将每个元素传递到函数func中</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD1.map( x =&gt; x._2 * <span class="number">5</span>).foreach(println)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><blockquote><p>flatMap(func)<br>与map()相似，但每个输入元素都可以映射到0或多个输出结果</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = data.flatMap (line =&gt; line.split(<span class="string">" "</span>) )</span><br></pre></td></tr></table></figure><blockquote><p>reduceByKey(func)<br>reduceByKey(func)的功能是，使用func函数合并具有相同键的值</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.reduceByKey((a,b)=&gt;a+b).foreach(println)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="type">Hive</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Hadoop</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>groupByKey()</p></blockquote><p>groupByKey()的功能是，对具有相同键的值进行分组。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.groupByKey().foreach(println)</span><br><span class="line">(<span class="type">Spark</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="type">Hive</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>))</span><br><span class="line">(<span class="type">Hadoop</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><blockquote><p>keys</p></blockquote><p><code>keys</code>只会把键值对RDD中的key返回形成一个新的RDD。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.keys.foreach(println)</span><br><span class="line"><span class="type">Hadoop</span></span><br><span class="line"><span class="type">Spark</span></span><br><span class="line"><span class="type">Hive</span></span><br><span class="line"><span class="type">Spark</span></span><br></pre></td></tr></table></figure><blockquote><p>values</p></blockquote><p><code>values</code>只会把键值对RDD中的value返回形成一个新的RDD。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.values.foreach(println)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>sortByKey()</p></blockquote><p><code>sortByKey()</code>的功能是返回一个根据键排序的RDD。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.sortByKey().foreach(println)</span><br><span class="line">(<span class="type">Hadoop</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Hive</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>mapValues(func)</p></blockquote><p><code>mapValues(func)</code>对键值对RDD中的每个value都应用一个函数，但是，key不会发生变化。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; pairRDD.mapValues(x =&gt; x*<span class="number">5</span>).foreach(println)</span><br><span class="line">(<span class="type">Hadoop</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="type">Hive</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="type">Spark</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>join</p></blockquote><p>join(连接)操作是键值对常用的操作。“连接”(join)这个概念来自于关系数据库领域，因此，join的类型也和关系数据库中的join一样，包括内连接(join)、左外连接(leftOuterJoin)、右外连接(rightOuterJoin)等。最常用的情形是内连接，所以，join就表示内连接。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> pairRDD1 = sc.parallelize(<span class="type">Array</span>((<span class="string">"spark"</span>,<span class="number">1</span>),(<span class="string">"spark"</span>,<span class="number">2</span>),(<span class="string">"hadoop"</span>,<span class="number">3</span>),(<span class="string">"hadoop"</span>,<span class="number">5</span>)))</span><br><span class="line">pairRDD1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">24</span>] at parallelize at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> pairRDD2 = sc.parallelize(<span class="type">Array</span>((<span class="string">"spark"</span>,<span class="string">"fast"</span>)))</span><br><span class="line">pairRDD2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">25</span>] at parallelize at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"> </span><br><span class="line">scala&gt; pairRDD1.join(pairRDD2)</span><br><span class="line">res9: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">String</span>))] = <span class="type">MapPartitionsRDD</span>[<span class="number">28</span>] at join at &lt;console&gt;:<span class="number">32</span></span><br><span class="line"> </span><br><span class="line">scala&gt; pairRDD1.join(pairRDD2).foreach(println)</span><br><span class="line">(spark,(<span class="number">1</span>,fast))</span><br><span class="line">(spark,(<span class="number">2</span>,fast))</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>Action</code>是真正触发计算的地方。<code>Spark</code>程序执行到行动操作时，才会执行真正的计算，从文件中加载数据，完成一次又一次转换操作，最终，完成行动操作得到结果。<br>下面列出一些常见的行动操作（<code>Action API</code>）:</p><ul><li>count() 返回数据集中的元素个数</li><li>collect() 以数组的形式返回数据集中的所有元素</li><li>first() 返回数据集中的第一个元素</li><li>take(n) 以数组的形式返回数据集中的前n个元素</li><li>reduce(func) 通过函数func（输入两个参数并返回一个值）聚合数据集中的元素</li><li>foreach(func) 将数据集中的每个元素传递到函数func中运行*</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门（1）—— 安装及环境</title>
      <link href="2020/12/31/spark-%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/31/spark-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>最近入了大数据的坑，需要好好系统整理一下知识。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>mac</code>下安装非常容易。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install apache-spark</span><br></pre></td></tr></table></figure><p>其它平台可以登录 <a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">Spark官方下载地址</a>，选择相应的版本下载。</p><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf spark.1.6.tar.gz</span><br></pre></td></tr></table></figure><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/usr/local/spark/spark-2.4.3</span><br><span class="line">export PATH=$PATH:/usr/local/spark/spark-2.4.3/bin:/usr/local/spark/spark-2.4.3/sbin</span><br></pre></td></tr></table></figure><p><code>pyspark</code>可以直接通过<code>pip</code>安装，运行<code>pip install pyspark</code>即可完成安装。</p><h2 id="spark-shell"><a href="#spark-shell" class="headerlink" title="spark-shell"></a>spark-shell</h2><p>我们进到<code>/usr/local/Cellar/apache-spark/3.0.1</code>目录下，执行<code>ls bin/</code>，可以看到下面的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls bin&#x2F;</span><br><span class="line">docker-image-tool.sh load-spark-env.sh    run-example          spark-class          spark-sql            sparkR</span><br><span class="line">find-spark-home      pyspark              spark-beeline        spark-shell          spark-submit</span><br></pre></td></tr></table></figure><p><code>pyspark</code>是<code>python</code>的<code>shell</code>，而<code>spark-shell</code>则是<code>scala</code>的<code>shell</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(30)--sqlx源码分析</title>
      <link href="2020/12/25/go-sqlx/"/>
      <url>2020/12/25/go-sqlx/</url>
      
        <content type="html"><![CDATA[<p><code>sqlx</code>是标准库<code>sql</code>最强的扩展，大大简化了<code>sql</code>操作。</p><a id="more"></a><h2 id="sqlx-DB"><a href="#sqlx-DB" class="headerlink" title="sqlx.DB"></a>sqlx.DB</h2><p>首先它扩展了标准库中的<code>sql.DB</code>对象，源码定义如下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB is a wrapper around sql.DB which keeps track of the driverName upon Open,</span></span><br><span class="line"><span class="comment">// used mostly to automatically bind named queries using the right bindvars.</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">*sql.DB</span><br><span class="line">driverName <span class="keyword">string</span>  <span class="comment">// 驱动 如:mysql</span></span><br><span class="line">unsafe     <span class="keyword">bool</span></span><br><span class="line">Mapper     *reflectx.Mapper <span class="comment">// 字段映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ColScanner-Queryer-Execer"><a href="#ColScanner-Queryer-Execer" class="headerlink" title="ColScanner, Queryer, Execer"></a>ColScanner, Queryer, Execer</h2><p><code>sqlx</code>中定义了下面两种操作接口，<code>ColScanner</code>接口是读取结果，<code>Queryer</code>定义了查询行为。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ColScanner is an interface used by MapScan and SliceScan</span></span><br><span class="line"><span class="keyword">type</span> ColScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">Columns() ([]<span class="keyword">string</span>, error)</span><br><span class="line">Scan(dest ...<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">Err() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queryer is an interface used by Get and Select</span></span><br><span class="line"><span class="keyword">type</span> Queryer <span class="keyword">interface</span> &#123;</span><br><span class="line">Query(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, error)</span><br><span class="line">Queryx(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, error)</span><br><span class="line">QueryRowx(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SliceScan</code>和<code>MapScan</code>方法接收<code>ColScanner</code>作为参数，实现了高扩展性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列到slice上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceScan</span><span class="params">(r ColScanner)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ignore r.started, since we needn't use reflect for anything.</span></span><br><span class="line">columns, err := r.Columns()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</span><br><span class="line">values[i] = <span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = r.Scan(values...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> values, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> columns &#123;</span><br><span class="line">values[i] = *(values[i].(*<span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> values, r.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列目标map上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapScan</span><span class="params">(r ColScanner, dest <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ignore r.started, since we needn't use reflect for anything.</span></span><br><span class="line">columns, err := r.Columns()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</span><br><span class="line">values[i] = <span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = r.Scan(values...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, column := <span class="keyword">range</span> columns &#123;</span><br><span class="line">dest[column] = *(values[i].(*<span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Select</code>和<code>Get</code>方法支持<code>Queryer</code>这个接口作为入参，实现数据的获取。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select executes a query using the provided Queryer, and StructScans each row</span></span><br><span class="line"><span class="comment">// into dest, which must be a slice.  If the slice elements are scannable, then</span></span><br><span class="line"><span class="comment">// the result set must have only one column.  Otherwise, StructScan is used.</span></span><br><span class="line"><span class="comment">// The *sql.Rows are closed automatically.</span></span><br><span class="line"><span class="comment">// Any placeholder parameters are replaced with supplied args.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">(q Queryer, dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rows, err := q.Queryx(query, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if something happens here, we want to make sure the rows are Closed</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">return</span> scanAll(rows, dest, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get does a QueryRow using the provided Queryer, and scans the resulting row</span></span><br><span class="line"><span class="comment">// to dest.  If dest is scannable, the result must only have one column.  Otherwise,</span></span><br><span class="line"><span class="comment">// StructScan is used.  Get will return sql.ErrNoRows like row.Scan would.</span></span><br><span class="line"><span class="comment">// Any placeholder parameters are replaced with supplied args.</span></span><br><span class="line"><span class="comment">// An error is returned if the result set is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(q Queryer, dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">r := q.QueryRowx(query, args...)</span><br><span class="line"><span class="keyword">return</span> r.scanAny(dest, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><p>标准库<code>sql</code>获取查询数据，需要遍历<code>rows</code>，<code>sqlx</code>提供了<code>Get</code>和<code>Select</code>两个方法，可以将查询结果直接映射到传入的结构体上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select using this DB.</span></span><br><span class="line"><span class="comment">// Any placeholder parameters are replaced with supplied args.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Select</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Select(db, dest, query, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Queryx</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span> &#123;</span><br><span class="line">r, err := db.DB.Query(query, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Rows&#123;Rows: r, unsafe: db.unsafe, Mapper: db.Mapper&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">(q Queryer, dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rows, err := q.Queryx(query, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// if something happens here, we want to make sure the rows are Closed</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">return</span> scanAll(rows, dest, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展的<code>Queryx</code>方法，基于标准库查询，返回<code>sqlx.Rows</code>对象，这个<code>sqlx.Rows</code>也是对标准库的中<code>sql.Rows</code>的扩展。</p><h2 id="Rows"><a href="#Rows" class="headerlink" title="Rows"></a>Rows</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rows is a wrapper around sql.Rows which caches costly reflect operations</span></span><br><span class="line"><span class="comment">// during a looped StructScan</span></span><br><span class="line"><span class="keyword">type</span> Rows <span class="keyword">struct</span> &#123;</span><br><span class="line">*sql.Rows</span><br><span class="line">unsafe <span class="keyword">bool</span></span><br><span class="line">Mapper *reflectx.Mapper</span><br><span class="line"><span class="comment">// these fields cache memory use for a rows during iteration w/ structScan</span></span><br><span class="line">started <span class="keyword">bool</span></span><br><span class="line">fields  [][]<span class="keyword">int</span></span><br><span class="line">values  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h2><p><code>Row</code>同样通过组合<code>sql.Rows</code>实现了<code>ColScanner</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Row is a reimplementation of sql.Row in order to gain access to the underlying</span></span><br><span class="line"><span class="comment">// sql.Rows.Columns() data, necessary for StructScan.</span></span><br><span class="line"><span class="keyword">type</span> Row <span class="keyword">struct</span> &#123;</span><br><span class="line">err    error</span><br><span class="line">unsafe <span class="keyword">bool</span></span><br><span class="line">rows   *sql.Rows</span><br><span class="line">Mapper *reflectx.Mapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了sql.Scan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Row)</span> <span class="title">Scan</span><span class="params">(dest ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> r.rows.Close()</span><br><span class="line"><span class="keyword">for</span> _, dp := <span class="keyword">range</span> dest &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := dp.(*sql.RawBytes); ok &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"sql: RawBytes isn't allowed on Row.Scan"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !r.rows.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sql.ErrNoRows</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫瞄结果到dest上</span></span><br><span class="line">err := r.rows.Scan(dest...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make sure the query can be processed to completion with no errors.</span></span><br><span class="line"><span class="keyword">if</span> err := r.rows.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><h2 id="Tx"><a href="#Tx" class="headerlink" title="Tx"></a>Tx</h2><p>与<code>DB</code>相同，<code>Tx</code>对象同样扩展了<code>sql.Tx</code>，因此也通过继承的方式，实现了标准库中<code>stmtConnGrabber</code>和<code>Tx</code>这两个接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> &#123;</span><br><span class="line">*sql.Tx</span><br><span class="line">driverName <span class="keyword">string</span></span><br><span class="line">unsafe     <span class="keyword">bool</span></span><br><span class="line">Mapper     *reflectx.Mapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Select</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Select(tx, dest, query, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get within a transaction.</span></span><br><span class="line"><span class="comment">// Any placeholder parameters are replaced with supplied args.</span></span><br><span class="line"><span class="comment">// An error is returned if the result set is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Get</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Get(tx, dest, query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stmt"><a href="#Stmt" class="headerlink" title="Stmt"></a>Stmt</h2><p><code>Stmt</code>同样被扩展了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stmt is an sqlx wrapper around sql.Stmt with extra functionality</span></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">*sql.Stmt</span><br><span class="line">unsafe <span class="keyword">bool</span></span><br><span class="line">Mapper *reflectx.Mapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Select</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Select(&amp;qStmt&#123;s&#125;, dest, <span class="string">""</span>, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get using the prepared statement.</span></span><br><span class="line"><span class="comment">// Any placeholder parameters are replaced with supplied args.</span></span><br><span class="line"><span class="comment">// An error is returned if the result set is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Get</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Get(&amp;qStmt&#123;s&#125;, dest, <span class="string">""</span>, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(30)--build参数全解析</title>
      <link href="2020/12/25/go-build/"/>
      <url>2020/12/25/go-build/</url>
      
        <content type="html"><![CDATA[<p><code>golang</code>编译速度非常快，平时一般也就用到<code>go build</code>，其实<code>build</code>功能异常的强大。</p><a id="more"></a><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p><code>golang</code>可以在不同的平台之间交叉编译。如在<code>mac</code>下编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>下表的参数是<code>go build</code>经常使用的，其中<code>-race</code>参数可以检查出多个<code>goroutine</code>操作一个变量的竞争情况。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-v</td><td>编译时显示包名</td></tr><tr><td>-p n</td><td>开启并发编译，默认情况下该值为 CPU 逻辑核数</td></tr><tr><td>-a</td><td>强制重新构建</td></tr><tr><td>-n</td><td>强制重新构建</td></tr><tr><td>-x</td><td>打印编译时会用到的所有命令，但不真正执行</td></tr><tr><td>-race</td><td>开启竞态检测</td></tr></tbody></table><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">var</span> t *time.Timer</span><br><span class="line">t = time.AfterFunc(randomDuration(), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Now().Sub(start))</span><br><span class="line">t.Reset(randomDuration())</span><br><span class="line">&#125;)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDuration</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Duration(rand.Int63n(<span class="number">1e9</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码直接运行，看起来似乎没问题，如果用<code>go run -race main.go</code>运行，就会出现<code>DATA RACE</code>的警告。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">952.879406</span>ms</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at <span class="number">0x00c00012a018</span> by goroutine <span class="number">8</span>:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/zs/projects/main.<span class="keyword">go</span>:<span class="number">14</span> +<span class="number">0x121</span></span><br><span class="line"></span><br><span class="line">Previous write at <span class="number">0x00c00012a018</span> by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/zs/projects/main.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0x18d</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">8</span> (running) created at:</span><br><span class="line">  time.goFunc()</span><br><span class="line">      /usr/local/Cellar/<span class="keyword">go</span>/<span class="number">1.14</span>/libexec/src/time/sleep.<span class="keyword">go</span>:<span class="number">168</span> +<span class="number">0x51</span></span><br><span class="line">==================</span><br><span class="line"><span class="number">1.038131519</span>s</span><br><span class="line"><span class="number">1.709255072</span>s</span><br><span class="line"><span class="number">1.948771443</span>s</span><br><span class="line"><span class="number">2.241263754</span>s</span><br><span class="line"><span class="number">2.793600067</span>s</span><br><span class="line"><span class="number">3.431263086</span>s</span><br><span class="line"><span class="number">3.766549402</span>s</span><br><span class="line"><span class="number">3.954944541</span>s</span><br><span class="line"><span class="number">4.44053012</span>s</span><br><span class="line">Found <span class="number">1</span> data race(s)</span><br></pre></td></tr></table></figure><h2 id="条件编译（Build-tags）"><a href="#条件编译（Build-tags）" class="headerlink" title="条件编译（Build tags）"></a>条件编译（Build tags）</h2><p>我们可以在源码中插入特殊的注释——构建标签(<code>Build tags</code>)，当Go编译一个包时，它会分析包内的每个源码文件并查找构建标签。标签决定了这个源码文件是否被编译。</p><p>构建标签遵循以下规则：</p><ul><li>每个源码允许存在多个构建标签</li><li>空格隔开的选项是或（<code>OR</code>）的关系</li><li>逗号隔开的选项是与（<code>AND</code>）的关系</li><li>每个选项由字母和数字组成。如果前面加上<code>!</code>，则表示反义</li><li>构建标签与<code>package</code>声明之间必须换行</li></ul><p>我们以<code>gin</code>框架为例，它的源码中<code>json</code>模块使用了构建标签来实现替换<code>json</code>库。</p><p><code>internal/json/jsonister.json</code>文件中声明了<code>+build jsoniter</code>，即指明<code>jsoniter</code>这个<code>tag</code>时编译此文件。<code>go build -tags jsoniter main.go</code>这样构建<code>gin</code>服务时，会使用<code>jsonister</code>作为框架的<code>json</code>模块。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br></pre></td></tr></table></figure><p><code>internal/json/json.json</code>文件中声明了<code>+build !jsoniter</code>，即指明在未指明<code>jsoniter</code>这个<code>tag</code>时编译，即默认使用标准库的<code>json</code>模块。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build !jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br></pre></td></tr></table></figure><h2 id="文件名后缀"><a href="#文件名后缀" class="headerlink" title="文件名后缀"></a>文件名后缀</h2><p>如果我们的文件带有特定平台后缀，并且文件名非<code>.</code>和<code>_</code>开头时，<code>go build</code>会只在该平台下编译。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mypkg_freebsd_arm.<span class="keyword">go</span> <span class="comment">// 只在 freebsd/arm 系统编译</span></span><br><span class="line">mypkg_plan9.<span class="keyword">go</span>       <span class="comment">// 只在 plan9 编译</span></span><br></pre></td></tr></table></figure><h2 id="编译参数注入"><a href="#编译参数注入" class="headerlink" title="编译参数注入"></a>编译参数注入</h2><p>有时候我们需要在编译出来的<code>exe</code>中注入版本信息或者是构建时间，我们可以这样使用<code>-ldflags -X importpath.name=value</code>构建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">commit = <span class="string">"ab"</span></span><br><span class="line">buildAt = <span class="string">"ab"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(commit)</span><br><span class="line">fmt.Println(buildAt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用如下命令构建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注意 -ldflags后面的参数需要整体用双引号包裹，-X后面的参数用单引号包裹</span><br><span class="line">go build -ldflags  "-X 'main.commit=$(git rev-parse --short HEAD)' -X 'main.buildAt=$(date +'%F %T %z')'" main.go</span><br></pre></td></tr></table></figure><p>运行后输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ./main</span><br><span class="line">567b580</span><br><span class="line">2020-12-25 15:42:29 +0800</span><br></pre></td></tr></table></figure><h2 id="查看GC分析"><a href="#查看GC分析" class="headerlink" title="查看GC分析"></a>查看GC分析</h2><p>使用如下命令运行，可以看到<code>gc</code>的<code>debug</code>信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=gctrace=1 go run main.go</span><br></pre></td></tr></table></figure><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析也是非常常见的<code>debug</code>需求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=-m main.go</span><br></pre></td></tr></table></figure><h2 id="二进制发布"><a href="#二进制发布" class="headerlink" title="二进制发布"></a>二进制发布</h2><p>如果我们不想提供源码但是又想提供给别人调用，你只需要提供一个编译好的库，同时提供为这个package提供一个源文件。这个源文件不用包含任何代码逻辑，只需增加<code>//go:binary-only-package</code>指令即可(注意//和go:…之间不要加空格)。 这样用户在使用的时候，就可以直接使用你这个二进制的库了。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(28)--gin源码阅读(3)</title>
      <link href="2020/12/19/go-gin-3/"/>
      <url>2020/12/19/go-gin-3/</url>
      
        <content type="html"><![CDATA[<p>学习一下<code>gin</code>是如何处理响应以及管理并发请求的。</p><a id="more"></a><h2 id="ServeHTTP"><a href="#ServeHTTP" class="headerlink" title="ServeHTTP"></a>ServeHTTP</h2><p><code>ServeHTTP</code>方法实现了<code>Handler</code>接口。</p><p>请求进来的时候，首先从连接池里获取<code>Context</code>，然后调用<code>Context</code>的<code>reset</code>方法，在完成请求之后，调用<code>Put</code>方法，将<code>Context</code>归还到连接池中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP conforms to the http.Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">c := engine.pool.Get().(*Context)</span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset()</span><br><span class="line"></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reset</code>方法主要是将相关变量恢复初始值,其中<code>c.Writer = &amp;c.writermem</code>这行代码是将<code>Writer</code>赋值为<code>gin</code>中定义的结构体<code>writermem</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *responseWriter)</span> <span class="title">reset</span><span class="params">(writer http.ResponseWriter)</span></span> &#123;</span><br><span class="line">w.ResponseWriter = writer <span class="comment">// 更换为新请求传入的writer</span></span><br><span class="line">w.size = noWritten</span><br><span class="line">w.status = defaultStatus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Writer = &amp;c.writermem </span><br><span class="line">c.Params = c.Params[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">c.handlers = <span class="literal">nil</span></span><br><span class="line">c.index = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">c.fullPath = <span class="string">""</span></span><br><span class="line">c.Keys = <span class="literal">nil</span></span><br><span class="line">c.Errors = c.Errors[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">c.Accepted = <span class="literal">nil</span></span><br><span class="line">c.queryCache = <span class="literal">nil</span></span><br><span class="line">c.formCache = <span class="literal">nil</span></span><br><span class="line">*c.params = (*c.params)[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要知道<code>Context</code>中<code>Writer</code>和<code>writermem</code>的区别。</p><p>成员变量<code>Writer</code>类型是<code>ResponseWriter</code>这个<code>gin</code>中对<code>http</code>标准库相关接口的扩展出来的接口，<code>writermem</code>则是结构体<code>responseWriter</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">writermem responseWriter</span><br><span class="line">Writer    ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ResponseWriter ...</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">http.ResponseWriter</span><br><span class="line">http.Hijacker</span><br><span class="line">http.Flusher</span><br><span class="line">http.CloseNotifier</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the HTTP response status code of the current request.</span></span><br><span class="line">Status() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the number of bytes already written into the response http body.</span></span><br><span class="line"><span class="comment">// See Written()</span></span><br><span class="line">Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Writes the string into the response body.</span></span><br><span class="line">WriteString(<span class="keyword">string</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns true if the response body was already written.</span></span><br><span class="line">Written() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Forces to write the http header (status code + headers).</span></span><br><span class="line">WriteHeaderNow()</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the http.Pusher for server push</span></span><br><span class="line">Pusher() http.Pusher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> responseWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">http.ResponseWriter</span><br><span class="line">size   <span class="keyword">int</span></span><br><span class="line">status <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>responseWriter</code>内嵌了<code>http.ResponseWriter</code>，这样外部传入的<code>http.ResponseWriter</code>可以非常方便的扩展成结构体<code>responseWriter</code>，而<code>responseWriter</code>实现了<code>ResponseWriter</code>这个接口。</p><h2 id="Context对象池"><a href="#Context对象池" class="headerlink" title="Context对象池"></a>Context对象池</h2><p><code>Context</code>是使用标准库<code>sync.Pool</code>进行管理的，使用对象池大大减少了GC的开销。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pool sync.Pool</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pool</code>的<code>New</code>方法是在<code>Engine</code>创建的时候定义的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">allocateContext</span><span class="params">()</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">v := <span class="built_in">make</span>(Params, <span class="number">0</span>, engine.maxParams)</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine, params: &amp;v&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(29)--高性能JSON解析器`jsoniter`</title>
      <link href="2020/12/19/json-iterator/"/>
      <url>2020/12/19/json-iterator/</url>
      
        <content type="html"><![CDATA[<p><code>jsoniter</code>是一个完全兼容官方<code>json</code>库的一个高性能<code>json</code>解析器。</p><a id="more"></a><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><p>使用上只需要替换调用的函数，其它跟标准库完全一致。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line">json.Marshal(&amp;data)</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = jsoniter.ConfigCompatibleWithStandardLibrary</span><br><span class="line">json.Marshal(&amp;data)</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line">json.Unmarshal(input, &amp;data)</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = jsoniter.ConfigCompatibleWithStandardLibrary</span><br><span class="line">json.Unmarshal(input, &amp;data)</span><br></pre></td></tr></table></figure><h2 id="允许字符串与数字互转"><a href="#允许字符串与数字互转" class="headerlink" title="允许字符串与数字互转"></a>允许字符串与数字互转</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></span><br><span class="line">extra.RegisterFuzzyDecoders()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> val <span class="keyword">string</span></span><br><span class="line">jsoniter.UnmarshalFromString(<span class="string">`100`</span>, &amp;val)</span><br></pre></td></tr></table></figure><h2 id="私有字段"><a href="#私有字段" class="headerlink" title="私有字段"></a>私有字段</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></span><br><span class="line">extra.SupportPrivateFields()</span><br><span class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">obj := TestObject&#123;&#125;</span><br><span class="line">jsoniter.UnmarshalFromString(<span class="string">`&#123;"field1":"Hello"&#125;`</span>, &amp;obj)</span><br><span class="line">should.Equal(<span class="string">"Hello"</span>, obj.field1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(27)--go-generate</title>
      <link href="2020/12/15/go-generate/"/>
      <url>2020/12/15/go-generate/</url>
      
        <content type="html"><![CDATA[<p><code>go generate</code>是<code>golang</code>1.4版本之后加入的命令，可以非常方便很多需要自动生成的场景。</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> generate [-run regexp] [-n] [-v] [-x] [build flags] [file.<span class="keyword">go</span>... | packages]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-run 正则表达式匹配命令行，仅执行匹配的命令</li><li>-v 输出被处理的包名和源文件名</li><li>-n 显示不执行命令</li><li>-x 显示并执行命令</li></ul><p>这个命令可以使用一些内置的环境变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$GOARCH</span><br><span class="line">    体系架构 (arm、amd64等待)</span><br><span class="line">$GOOS</span><br><span class="line">    OS环境(linux、windows等)</span><br><span class="line">$GOFILE</span><br><span class="line">    当前处理中的文件名</span><br><span class="line">$GOLINE</span><br><span class="line">    当前命令在文件中的行号</span><br><span class="line">$GOPACKAGE</span><br><span class="line">    当前处理文件的包名</span><br><span class="line">$DOLLAR</span><br><span class="line">    固定的&quot;$&quot;,不清楚用途</span><br></pre></td></tr></table></figure><h2 id="stringer"><a href="#stringer" class="headerlink" title="stringer"></a>stringer</h2><p>介绍一个常用的使用<code>stringer</code>。</p><p><code>stringer</code>是一个基于<code>go generate</code>自动给类型添加<code>String()</code>方法的生成工具。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>假设我们定义了<code>Pill</code>这个类型。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pill <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Placebo Pill = <span class="literal">iota</span></span><br><span class="line">Aspirin</span><br><span class="line">Ibuprofen</span><br><span class="line">Paracetamol</span><br><span class="line">Acetaminophen = Paracetamol</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行<code>stringer -type=Pill</code>命令会生成如下的代码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Pill)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>如果我们做了代码变更每次都要执行这个命令，更好的办法是添加<code>generate</code>标签。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate stringer -type=Pill</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pill <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Placebo Pill = <span class="literal">iota</span></span><br><span class="line">Aspirin</span><br><span class="line">Ibuprofen</span><br><span class="line">Paracetamol</span><br><span class="line">Acetaminophen = Paracetamol</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后执行<code>go generate</code>，生成<code>pill_string.go</code>文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by "stringer -type=Pill"; DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// An "invalid array index" compiler error signifies that the constant values have changed.</span></span><br><span class="line"><span class="comment">// Re-run the stringer command to generate them again.</span></span><br><span class="line"><span class="keyword">var</span> x [<span class="number">1</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">_ = x[Placebo<span class="number">-0</span>]</span><br><span class="line">_ = x[Aspirin<span class="number">-1</span>]</span><br><span class="line">_ = x[Ibuprofen<span class="number">-2</span>]</span><br><span class="line">_ = x[Paracetamol<span class="number">-3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _Pill_name = <span class="string">"PlaceboAspirinIbuprofenParacetamol"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _Pill_index = [...]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">23</span>, <span class="number">34</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Pill)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= Pill(<span class="built_in">len</span>(_Pill_index)<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Pill("</span> + strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>) + <span class="string">")"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _Pill_name[_Pill_index[i]:_Pill_index[i+<span class="number">1</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(26)--gin源码阅读(2)</title>
      <link href="2020/12/12/go-gin-2/"/>
      <url>2020/12/12/go-gin-2/</url>
      
        <content type="html"><![CDATA[<p><code>Context</code>是<code>gin</code>框架中最重要的概念。</p><a id="more"></a><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>Context</code>是一个结构体，源码如下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context is the most important part of gin. It allows us to pass variables between middleware,</span></span><br><span class="line"><span class="comment">// manage the flow, validate the JSON of a request and render a JSON response for example.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">writermem responseWriter</span><br><span class="line">Request   *http.Request</span><br><span class="line">Writer    ResponseWriter</span><br><span class="line"></span><br><span class="line">Params   Params</span><br><span class="line">handlers HandlersChain</span><br><span class="line">index    <span class="keyword">int8</span></span><br><span class="line">fullPath <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">engine *Engine</span><br><span class="line">params *Params</span><br><span class="line"></span><br><span class="line"><span class="comment">// This mutex protect Keys map</span></span><br><span class="line">mu sync.RWMutex</span><br><span class="line"><span class="comment">// Keys is a key/value pair exclusively for the context of each request.</span></span><br><span class="line">Keys <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errors is a list of errors attached to all the handlers/middlewares who used this context.</span></span><br><span class="line">Errors errorMsgs</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepted defines a list of manually accepted formats for content negotiation.</span></span><br><span class="line">Accepted []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queryCache use url.ParseQuery cached the param query result from c.Request.URL.Query()</span></span><br><span class="line">queryCache url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// formCache use url.ParseQuery cached PostForm contains the parsed form data from POST, PATCH,</span></span><br><span class="line"><span class="comment">// or PUT body parameters.</span></span><br><span class="line">formCache url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// SameSite allows a server to define a cookie attribute making it impossible for</span></span><br><span class="line"><span class="comment">// the browser to send this cookie along with cross-site requests.</span></span><br><span class="line">sameSite http.SameSite</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gin.Context</code>实现了标准库中<code>Context</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deadline always returns that there is no deadline (ok==false),</span></span><br><span class="line"><span class="comment">// maybe you want to use Request.Context().Deadline() instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done always returns nil (chan which will wait forever),</span></span><br><span class="line"><span class="comment">// if you want to abort your work when the connection was closed</span></span><br><span class="line"><span class="comment">// you should use Request.Context().Done() instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Err always returns nil, maybe you want to use Request.Context().Err() instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the value associated with this context for key, or nil</span></span><br><span class="line"><span class="comment">// if no value is associated with key. Successive calls to Value with</span></span><br><span class="line"><span class="comment">// the same key returns the same result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Request</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> keyAsString, ok := key.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">val, _ := c.Get(keyAsString)</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p><code>Context</code>支持非常多的数据绑定方式。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Bind(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindJSON(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindXML(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindQuery(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindYAML(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindHeader(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">BindUri(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">MustBindWith(obj <span class="keyword">interface</span>&#123;&#125;, b binding.Binding) error</span><br><span class="line">ShouldBind(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindJSON(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindXML(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindQuery(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindYAML(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindHeader(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindUri(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">ShouldBindWith(obj <span class="keyword">interface</span>&#123;&#125;, b binding.Binding) error</span><br><span class="line">ShouldBindBodyWith(obj <span class="keyword">interface</span>&#123;&#125;, bb binding.BindingBody) (err error)</span><br></pre></td></tr></table></figure><p>最常用的<code>Bind</code>方法支持自动通过请求方法和请求头，自动参数绑定。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Bind</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := binding.Default(c.Request.Method, c.ContentType())</span><br><span class="line"><span class="keyword">return</span> c.MustBindWith(obj, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default returns the appropriate Binding instance based on the HTTP method</span></span><br><span class="line"><span class="comment">// and the content type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">(method, contentType <span class="keyword">string</span>)</span> <span class="title">Binding</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> method == http.MethodGet &#123;</span><br><span class="line"><span class="keyword">return</span> Form</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> contentType &#123;</span><br><span class="line"><span class="keyword">case</span> MIMEJSON:</span><br><span class="line"><span class="keyword">return</span> JSON</span><br><span class="line"><span class="keyword">case</span> MIMEXML, MIMEXML2:</span><br><span class="line"><span class="keyword">return</span> XML</span><br><span class="line"><span class="keyword">case</span> MIMEPROTOBUF:</span><br><span class="line"><span class="keyword">return</span> ProtoBuf</span><br><span class="line"><span class="keyword">case</span> MIMEMSGPACK, MIMEMSGPACK2:</span><br><span class="line"><span class="keyword">return</span> MsgPack</span><br><span class="line"><span class="keyword">case</span> MIMEYAML:</span><br><span class="line"><span class="keyword">return</span> YAML</span><br><span class="line"><span class="keyword">case</span> MIMEMultipartPOSTForm:</span><br><span class="line"><span class="keyword">return</span> FormMultipart</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// case MIMEPOSTForm:</span></span><br><span class="line"><span class="keyword">return</span> Form</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它方法基本都是通过指定数据类型进行绑定。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">BindJSON</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.MustBindWith(obj, binding.JSON)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>对于不同的数据类型处理，<code>gin</code>定义了<code>Binding</code>这个接口，这样扩展数据类型只需要实现<code>Binding</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Binding <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">Bind(*http.Request, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下最常见的<code>json</code>的数据绑定的实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> jsonBinding <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jsonBinding)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"json"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jsonBinding)</span> <span class="title">Bind</span><span class="params">(req *http.Request, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> req == <span class="literal">nil</span> || req.Body == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid request"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> decodeJSON(req.Body, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jsonBinding)</span> <span class="title">BindBody</span><span class="params">(body []<span class="keyword">byte</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> decodeJSON(bytes.NewReader(body), obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeJSON</span><span class="params">(r io.Reader, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">decoder := json.NewDecoder(r)</span><br><span class="line"><span class="keyword">if</span> EnableDecoderUseNumber &#123;</span><br><span class="line">decoder.UseNumber()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> EnableDecoderDisallowUnknownFields &#123;</span><br><span class="line">decoder.DisallowUnknownFields()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := decoder.Decode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validate(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>+build</code>方式条件编译实现了自定义的<code>json</code>解析方式。使用<code>go build main.go</code>的编译方式使用的是标准库<code>encoding/json</code>，而使用<code>go build -tags=jsoniter main.go</code>进行编译则会使用<code>json-iterator</code>来进行<code>json</code>的处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gin/internal/json/json.go</span></span><br><span class="line"><span class="comment">// +build !jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// Marshal is exported by gin/json package.</span></span><br><span class="line">Marshal = json.Marshal</span><br><span class="line"><span class="comment">// Unmarshal is exported by gin/json package.</span></span><br><span class="line">Unmarshal = json.Unmarshal</span><br><span class="line"><span class="comment">// MarshalIndent is exported by gin/json package.</span></span><br><span class="line">MarshalIndent = json.MarshalIndent</span><br><span class="line"><span class="comment">// NewDecoder is exported by gin/json package.</span></span><br><span class="line">NewDecoder = json.NewDecoder</span><br><span class="line"><span class="comment">// NewEncoder is exported by gin/json package.</span></span><br><span class="line">NewEncoder = json.NewEncoder</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gin/internal/json/jsonister.go</span></span><br><span class="line"><span class="comment">// +build jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">json = jsoniter.ConfigCompatibleWithStandardLibrary</span><br><span class="line"><span class="comment">// Marshal is exported by gin/json package.</span></span><br><span class="line">Marshal = json.Marshal</span><br><span class="line"><span class="comment">// Unmarshal is exported by gin/json package.</span></span><br><span class="line">Unmarshal = json.Unmarshal</span><br><span class="line"><span class="comment">// MarshalIndent is exported by gin/json package.</span></span><br><span class="line">MarshalIndent = json.MarshalIndent</span><br><span class="line"><span class="comment">// NewDecoder is exported by gin/json package.</span></span><br><span class="line">NewDecoder = json.NewDecoder</span><br><span class="line"><span class="comment">// NewEncoder is exported by gin/json package.</span></span><br><span class="line">NewEncoder = json.NewEncoder</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Params-Query"><a href="#Params-Query" class="headerlink" title="Params, Query"></a>Params, Query</h2><p><code>Params</code>获取可以获取<code>url</code>路径中的参数，<code>Query</code>则是可以解析<code>url</code>问号后面附带的请求参数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Param returns the value of the URL param.</span></span><br><span class="line"><span class="comment">// It is a shortcut for c.Params.ByName(key)</span></span><br><span class="line"><span class="comment">//     router.GET("/user/:id", func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">//         // a GET request to /user/john</span></span><br><span class="line"><span class="comment">//         id := c.Param("id") // id == "john"</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Param</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Params.ByName(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query returns the keyed url query value if it exists,</span></span><br><span class="line"><span class="comment">// otherwise it returns an empty string `("")`.</span></span><br><span class="line"><span class="comment">// It is shortcut for `c.Request.URL.Query().Get(key)`</span></span><br><span class="line"><span class="comment">//     GET /path?id=1234&amp;name=Manu&amp;value=</span></span><br><span class="line"><span class="comment">//    c.Query("id") == "1234"</span></span><br><span class="line"><span class="comment">//    c.Query("name") == "Manu"</span></span><br><span class="line"><span class="comment">//    c.Query("value") == ""</span></span><br><span class="line"><span class="comment">//    c.Query("wtf") == ""</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Query</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">value, _ := c.GetQuery(key)</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 允许设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">DefaultQuery</span><span class="params">(key, defaultValue <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> value, ok := c.GetQuery(key); ok &#123;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><p><code>Keys</code>提供了<code>Set</code>和<code>Get</code>这两个方法可以帮助我们传递线程安全的变量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is used to store a new key/value pair exclusively for this context.</span></span><br><span class="line"><span class="comment">// It also lazy initializes  c.Keys if it was not used previously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">c.Keys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Keys[key] = value</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the value for the given key, ie: (value, true).</span></span><br><span class="line"><span class="comment">// If the value does not exists it returns (nil, false)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">c.mu.RLock()</span><br><span class="line">value, exists = c.Keys[key]</span><br><span class="line">c.mu.RUnlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于返回值是<code>interface{}</code>，<code>gin</code>也提供了很多API帮助我们从<code>map</code>中读取指定类型的数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GetString(key <span class="keyword">string</span>) (s <span class="keyword">string</span>)</span><br><span class="line">GetBool(key <span class="keyword">string</span>) (b <span class="keyword">bool</span>)</span><br><span class="line">GetInt(key <span class="keyword">string</span>) (i <span class="keyword">int</span>)</span><br><span class="line">GetInt64(key <span class="keyword">string</span>) (i64 <span class="keyword">int64</span>)</span><br><span class="line">GetUint(key <span class="keyword">string</span>) (ui <span class="keyword">uint</span>)</span><br><span class="line">GetUint64(key <span class="keyword">string</span>) (ui64 <span class="keyword">uint64</span>)</span><br><span class="line">GetFloat64(key <span class="keyword">string</span>) (f64 <span class="keyword">float64</span>)</span><br><span class="line">GetTime(key <span class="keyword">string</span>) (t time.Time)</span><br><span class="line">GetDuration(key <span class="keyword">string</span>) (d time.Duration)</span><br><span class="line">GetStringSlice(key <span class="keyword">string</span>) (ss []<span class="keyword">string</span>)</span><br><span class="line">GetStringMap(key <span class="keyword">string</span>) (sm <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">GetStringMapString(key <span class="keyword">string</span>) (sms <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">GetStringMapStringSlice(key <span class="keyword">string</span>) (smss <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><h2 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h2><p><code>Context</code>并不是并发安全的，所以如果我们需要多个<code>goroutine</code>处理<code>Context</code>，需要用<code>Copy</code>方法复制一份。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy returns a copy of the current context that can be safely used outside the request's scope.</span></span><br><span class="line"><span class="comment">// This has to be used when the context has to be passed to a goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Copy</span><span class="params">()</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">cp := Context&#123;</span><br><span class="line">writermem: c.writermem,</span><br><span class="line">Request:   c.Request,</span><br><span class="line">Params:    c.Params,</span><br><span class="line">engine:    c.engine,</span><br><span class="line">&#125;</span><br><span class="line">cp.writermem.ResponseWriter = <span class="literal">nil</span></span><br><span class="line">cp.Writer = &amp;cp.writermem</span><br><span class="line">cp.index = abortIndex</span><br><span class="line">cp.handlers = <span class="literal">nil</span></span><br><span class="line">cp.Keys = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> c.Keys &#123;</span><br><span class="line">cp.Keys[k] = v</span><br><span class="line">&#125;</span><br><span class="line">paramCopy := <span class="built_in">make</span>([]Param, <span class="built_in">len</span>(cp.Params))</span><br><span class="line"><span class="built_in">copy</span>(paramCopy, cp.Params)</span><br><span class="line">cp.Params = paramCopy</span><br><span class="line"><span class="keyword">return</span> &amp;cp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(26)--gin源码阅读(1)</title>
      <link href="2020/12/11/go-gin-1/"/>
      <url>2020/12/11/go-gin-1/</url>
      
        <content type="html"><![CDATA[<p><code>gin</code>是<code>golang</code>里使用最为广泛的<code>Web</code>开发框架。</p><a id="more"></a><h2 id="IRouter"><a href="#IRouter" class="headerlink" title="IRouter"></a>IRouter</h2><p><code>gin</code>把路由定义成接口，看下它的定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="keyword">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRoutes defines all router handle interface.</span></span><br><span class="line"><span class="keyword">type</span> IRoutes <span class="keyword">interface</span> &#123;</span><br><span class="line">Use(...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">Handle(<span class="keyword">string</span>, <span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">Any(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">GET(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">POST(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">DELETE(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PATCH(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PUT(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">OPTIONS(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">HEAD(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">StaticFile(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">Static(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">StaticFS(<span class="keyword">string</span>, http.FileSystem) IRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的实现<code>IRouter</code>的结构体是<code>RouterGroup</code>，它是一系列相同前缀的路由的集合。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span></span><br><span class="line"><span class="comment">// a prefix and an array of handlers (middleware).</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Handlers HandlersChain <span class="comment">// 请求处理器</span></span><br><span class="line">basePath <span class="keyword">string</span>        <span class="comment">// 前缀</span></span><br><span class="line">engine   *Engine       </span><br><span class="line">root     <span class="keyword">bool</span>          <span class="comment">// 是否根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlersChain []HandlerFunc</span><br></pre></td></tr></table></figure><h2 id="HandlerFunc"><a href="#HandlerFunc" class="headerlink" title="HandlerFunc"></a>HandlerFunc</h2><p><code>HandlerFunc</code>是一个非常重要的定义，用于处理请求，类似标准库<code>http</code>中定义的<code>HandlerFunc</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gin</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure><h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><p><code>Engine</code>是<code>gin</code>中<code>HTTP</code>服务的实体，它包含了路由、中间件及服务相关配置。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">RouterGroup</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自动处理末尾反斜杠如 /foo/ -&gt; /foo</span></span><br><span class="line">RedirectTrailingSlash <span class="keyword">bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 自动处理路由中多余的项  /FOO and /..//Foo -&gt; /foo</span></span><br><span class="line">RedirectFixedPath <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// method转换</span></span><br><span class="line">  HandleMethodNotAllowed <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略。。。</span></span><br><span class="line"></span><br><span class="line">pool             sync.Pool    <span class="comment">// Context池</span></span><br><span class="line">trees            methodTrees  <span class="comment">// 路由树</span></span><br><span class="line">maxParams        <span class="keyword">uint16</span>       <span class="comment">// poll最大上限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Engine</code>实现了标准库<code>http</code>中的<code>Handler</code>接口，因此可以方便的同其它<code>Web</code>服务的组件集成。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">c := engine.pool.Get().(*Context)</span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset()</span><br><span class="line"></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line">  <span class="comment">// 放入池子中</span></span><br><span class="line">engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Engine</code>支持多种服务启动方式。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Run(addr ...<span class="keyword">string</span>) (err error)</span><br><span class="line">RunTLS(addr <span class="keyword">string</span>, certFile <span class="keyword">string</span>, keyFile <span class="keyword">string</span>) (err error)</span><br><span class="line">RunUnix(file <span class="keyword">string</span>) (err error)</span><br><span class="line">RunFd(fd <span class="keyword">int</span>) (err error)</span><br><span class="line">RunListener(listener net.Listener) (err error)</span><br></pre></td></tr></table></figure><p>看下最常见的<code>Run</code>方法的源码，前面说到<code>Engine</code>实现了<code>Handler</code>接口，所以可以直接调用<code>http</code>的<code>ListenAndServe</code>方法启动服务。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">address := resolveAddress(addr)</span><br><span class="line">debugPrint(<span class="string">"Listening and serving HTTP on %s\n"</span>, address)</span><br><span class="line">err = http.ListenAndServe(address, engine)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种参数方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveAddress</span><span class="params">(addr []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(addr) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> port := os.Getenv(<span class="string">"PORT"</span>); port != <span class="string">""</span> &#123;</span><br><span class="line">debugPrint(<span class="string">"Environment variable PORT=\"%s\""</span>, port)</span><br><span class="line"><span class="keyword">return</span> <span class="string">":"</span> + port</span><br><span class="line">&#125;</span><br><span class="line">debugPrint(<span class="string">"Environment variable PORT is undefined. Using port :8080 by default"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">":8080"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> addr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"too many parameters"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RouteInfo"><a href="#RouteInfo" class="headerlink" title="RouteInfo"></a>RouteInfo</h2><p><code>RouteInfo</code>中存储了路由的基本信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoutesInfo defines a RouteInfo array.</span></span><br><span class="line"><span class="keyword">type</span> RoutesInfo []RouteInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// RouteInfo represents a request route's specification which contains method and path and its handler.</span></span><br><span class="line"><span class="keyword">type</span> RouteInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Method      <span class="keyword">string</span></span><br><span class="line">Path        <span class="keyword">string</span></span><br><span class="line">Handler     <span class="keyword">string</span></span><br><span class="line">HandlerFunc HandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个对象，可以获取服务中注册的所有路由。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Routes returns a slice of registered routes, including some useful information, such as:</span></span><br><span class="line"><span class="comment">// the http method, path and the handler name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Routes</span><span class="params">()</span> <span class="params">(routes RoutesInfo)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, tree := <span class="keyword">range</span> engine.trees &#123;</span><br><span class="line">routes = iterate(<span class="string">""</span>, tree.method, routes, tree.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> routes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iterate</span><span class="params">(path, method <span class="keyword">string</span>, routes RoutesInfo, root *node)</span> <span class="title">RoutesInfo</span></span> &#123;</span><br><span class="line">path += root.path</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(root.handlers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">handlerFunc := root.handlers.Last()</span><br><span class="line">routes = <span class="built_in">append</span>(routes, RouteInfo&#123;</span><br><span class="line">Method:      method,</span><br><span class="line">Path:        path,</span><br><span class="line">Handler:     nameOfFunction(handlerFunc),</span><br><span class="line">HandlerFunc: handlerFunc,</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> root.children &#123;</span><br><span class="line">routes = iterate(path, method, routes, child)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> routes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又回到<code>engine</code>结构体中之前没有提到的<code>trees</code>这个<code>methodTrees</code>类型的成员变量，看下它的定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">method <span class="keyword">string</span></span><br><span class="line">root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">path      <span class="keyword">string</span></span><br><span class="line">indices   <span class="keyword">string</span></span><br><span class="line">wildChild <span class="keyword">bool</span></span><br><span class="line">nType     nodeType</span><br><span class="line">priority  <span class="keyword">uint32</span></span><br><span class="line">children  []*node</span><br><span class="line">handlers  HandlersChain</span><br><span class="line">fullPath  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，每种<code>method</code>都是一棵多叉树，<code>node</code>中<code>children</code>代表树的子节点。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(25)--SQL生成库squirrel</title>
      <link href="2020/12/10/go-squirrel/"/>
      <url>2020/12/10/go-squirrel/</url>
      
        <content type="html"><![CDATA[<p>在<code>golang</code>中如果我们不用<code>ORM</code>框架的话，需要我们自己手动拼接<code>SQL</code>，<code>squirrel</code>是一个能够帮助我们简化这个过程的第三方库。</p><a id="more"></a><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>squirrel</code>不是<code>ORM</code>，它是通过表结构构造的方式完成<code>SQL</code>的拼接，通过<code>ToSql</code>方式，生成执行的<code>SQL</code>及对应的参数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sq <span class="string">"github.com/Masterminds/squirrel"</span></span><br><span class="line"></span><br><span class="line">users := sq.Select(<span class="string">"*"</span>).From(<span class="string">"users"</span>).Join(<span class="string">"emails USING (email_id)"</span>)</span><br><span class="line"></span><br><span class="line">active := users.Where(sq.Eq&#123;<span class="string">"deleted_at"</span>: <span class="literal">nil</span>&#125;)</span><br><span class="line"></span><br><span class="line">sql, args, err := active.ToSql()</span><br><span class="line"></span><br><span class="line">sql == <span class="string">"SELECT * FROM users JOIN emails USING (email_id) WHERE deleted_at IS NULL"</span></span><br></pre></td></tr></table></figure><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p><code>Builder</code>是实现增删改查的类</p><blockquote><p>squirrel.InsertBuilder 插入<br>squirrel.UpdateBuilder 修改<br>squirrel.DeleteBuilder 删除<br>squirrel.SelectBuilder 查找</p></blockquote><p>所有的<code>Builder</code>都实现了<code>Sqlizer</code>这个接口，所以它们都可以生成对应<code>SQL</code>语句。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sqlizer <span class="keyword">interface</span> &#123;</span><br><span class="line">ToSql() (<span class="keyword">string</span>, []<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="squirrel-Expr"><a href="#squirrel-Expr" class="headerlink" title="squirrel.Expr"></a>squirrel.Expr</h2><p><code>squirrel.Expr</code>可以用于表达式，实现类似字段自增这样的功能。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squirrel.Update(<span class="string">"money"</span>).Where(...).Set(<span class="string">"value"</span>, squirrel.Expr(fmt.Sprintf(<span class="string">"%s + %d"</span>, <span class="string">"value"</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="Prefix-Suffix"><a href="#Prefix-Suffix" class="headerlink" title="Prefix, Suffix"></a>Prefix, Suffix</h2><p>这两个方式可以在字段前后添加信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nestedBuilder := StatementBuilder.PlaceholderFormat(Dollar).Select(<span class="string">"*"</span>).Prefix(<span class="string">"NOT EXISTS ("</span>).</span><br><span class="line">From(<span class="string">"bar"</span>).Where(<span class="string">"y = ?"</span>, <span class="number">42</span>).Suffix(<span class="string">")"</span>)</span><br><span class="line">outerSql, _, err := StatementBuilder.PlaceholderFormat(Dollar).Select(<span class="string">"*"</span>).</span><br><span class="line">From(<span class="string">"foo"</span>).Where(<span class="string">"x = ?"</span>).Where(nestedBuilder).ToSql()</span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Builder-1"><a href="#Builder-1" class="headerlink" title="Builder"></a>Builder</h2><p><code>InsertBuilder</code>这些<code>builder</code>是项目<code>github.com/lann/builder</code>中结构体<code>builder.Builder</code>的重定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"github.com/lann/builder"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InsertBuilder builder.Builder</span><br></pre></td></tr></table></figure><p><code>builder</code>这个库<a href="https://github.com/lann/builder" target="_blank" rel="noopener">github主页</a>上是这样介绍的。</p><blockquote><p>Builder was originally written for Squirrel, a fluent SQL generator. It is probably the best example of Builder in action.<br>Builder helps you write fluent DSLs for your libraries with method chaining:</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp := ReqBuilder.</span><br><span class="line">    Url(<span class="string">"http://golang.org"</span>).</span><br><span class="line">    Header(<span class="string">"User-Agent"</span>, <span class="string">"Builder"</span>).</span><br><span class="line">Get()</span><br></pre></td></tr></table></figure><p>来看下<code>builder.Builder</code>的定义，参考注释说明，这个结构体主要用于存储一系列不可变的值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder stores a set of named values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// New types can be declared with underlying type Builder and used with the</span></span><br><span class="line"><span class="comment">// functions in this package. See example.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Instances of Builder should be treated as immutable. It is up to the</span></span><br><span class="line"><span class="comment">// implementor to ensure mutable values set on a Builder are not mutated while</span></span><br><span class="line"><span class="comment">// the Builder is in use.</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">builderMap ps.Map  <span class="comment">// ps.Map是下面定义的接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// IsNil returns true if the Map is empty</span></span><br><span class="line">IsNil() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set returns a new map in which key and value are associated.</span></span><br><span class="line"><span class="comment">// If the key didn't exist before, it's created; otherwise, the</span></span><br><span class="line"><span class="comment">// associated value is changed.</span></span><br><span class="line"><span class="comment">// This operation is O(log N) in the number of keys.</span></span><br><span class="line">Set(key <span class="keyword">string</span>, value Any) Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete returns a new map with the association for key, if any, removed.</span></span><br><span class="line"><span class="comment">// This operation is O(log N) in the number of keys.</span></span><br><span class="line">Delete(key <span class="keyword">string</span>) Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lookup returns the value associated with a key, if any.  If the key</span></span><br><span class="line"><span class="comment">// exists, the second return value is true; otherwise, false.</span></span><br><span class="line"><span class="comment">// This operation is O(log N) in the number of keys.</span></span><br><span class="line">Lookup(key <span class="keyword">string</span>) (Any, <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size returns the number of key value pairs in the map.</span></span><br><span class="line"><span class="comment">// This takes O(1) time.</span></span><br><span class="line">Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEach executes a callback on each key value pair in the map.</span></span><br><span class="line">ForEach(f <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, val Any)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys returns a slice with all keys in this map.</span></span><br><span class="line"><span class="comment">// This operation is O(N) in the number of keys.</span></span><br><span class="line">Keys() []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>builder.Builder</code>支持作为下列这些函数的参数调用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Delete</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, vs ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extend</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, vs <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMap</span><span class="params">(builder <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="ToSql实现"><a href="#ToSql实现" class="headerlink" title="ToSql实现"></a>ToSql实现</h2><p>插入操作最后是由<code>insertData</code>这个结构实现的，`ToSql``主要实现的也是字符串的拼接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> insertData <span class="keyword">struct</span> &#123;</span><br><span class="line">PlaceholderFormat PlaceholderFormat</span><br><span class="line">RunWith           BaseRunner</span><br><span class="line">Prefixes          []Sqlizer</span><br><span class="line">StatementKeyword  <span class="keyword">string</span></span><br><span class="line">Options           []<span class="keyword">string</span></span><br><span class="line">Into              <span class="keyword">string</span></span><br><span class="line">Columns           []<span class="keyword">string</span></span><br><span class="line">Values            [][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Suffixes          []Sqlizer</span><br><span class="line">Select            *SelectBuilder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *insertData)</span> <span class="title">ToSql</span><span class="params">()</span> <span class="params">(sqlStr <span class="keyword">string</span>, args []<span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Into) == <span class="number">0</span> &#123;</span><br><span class="line">err = errors.New(<span class="string">"insert statements must specify a table"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Values) == <span class="number">0</span> &amp;&amp; d.Select == <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.New(<span class="string">"insert statements must have at least one set of values or select clause"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sql := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Prefixes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">args, err = appendToSql(d.Prefixes, sql, <span class="string">" "</span>, args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sql.WriteString(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.StatementKeyword == <span class="string">""</span> &#123;</span><br><span class="line">sql.WriteString(<span class="string">"INSERT "</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sql.WriteString(d.StatementKeyword)</span><br><span class="line">sql.WriteString(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Options) &gt; <span class="number">0</span> &#123;</span><br><span class="line">sql.WriteString(strings.Join(d.Options, <span class="string">" "</span>))</span><br><span class="line">sql.WriteString(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sql.WriteString(<span class="string">"INTO "</span>)</span><br><span class="line">sql.WriteString(d.Into)</span><br><span class="line">sql.WriteString(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Columns) &gt; <span class="number">0</span> &#123;</span><br><span class="line">sql.WriteString(<span class="string">"("</span>)</span><br><span class="line">sql.WriteString(strings.Join(d.Columns, <span class="string">","</span>))</span><br><span class="line">sql.WriteString(<span class="string">") "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.Select != <span class="literal">nil</span> &#123;</span><br><span class="line">args, err = d.appendSelectToSQL(sql, args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">args, err = d.appendValuesToSQL(sql, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(d.Suffixes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">sql.WriteString(<span class="string">" "</span>)</span><br><span class="line">args, err = appendToSql(d.Suffixes, sql, <span class="string">" "</span>, args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlStr, err = d.PlaceholderFormat.ReplacePlaceholders(sql.String())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(24)--逃逸分析</title>
      <link href="2020/12/09/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>2020/12/09/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>我们都知道<code>golang</code>是一门有<code>GC</code>的语言，并且频繁的<code>GC</code>会带来很大的性能开销。是不是所有生成对象都会产生<code>GC</code>呢？这个问题我们需要了解<code>golang</code>的逃逸分析。</p><a id="more"></a><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>首先需要了解一下什么是<code>堆栈</code>。它数据结构里的<code>heap</code>和<code>stack</code>是一个东西吗？</p><p>这里说的<code>堆栈</code>是操作系统中的概念</p><blockquote><p>栈：由编译器自动分配释放,存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，栈使用的是一级缓存,他们通常都是被调用时处于存储空间中，调用完毕立即释放。我们可以理解为在函数调用分配的内存上的变量会随着调用函数一起被操作系统回收。</p></blockquote><blockquote><p>堆： 一般由程序员分配释放,若程序员不释放,程序结束时可能由系统回收，分配方式倒是类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p></blockquote><ul><li>变量分配在栈上的好处：存取速度比堆要快，随函数调用结束释放无需<code>GC</code></li></ul><h2 id="逃逸分析是什么"><a href="#逃逸分析是什么" class="headerlink" title="逃逸分析是什么"></a>逃逸分析是什么</h2><blockquote><p>逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定</p></blockquote><p>在函数中创建一个新的对象：</p><ul><li>如果分配在<code>栈</code>中，则函数执行结束可自动回收内存；</li><li>如果分配在<code>堆</code>中，则函数执行结束可交给<code>GC</code>处理;</li></ul><p>不同于<code>JVM</code>语言，<code>golang</code>的逃逸分析也是编译期完成的。</p><p>可以在编译时添加<code>-gcflags=-m</code>开启逃逸分析的<code>debug</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=-m main.go</span><br><span class="line">go build -gcflags="-m -l" main.go // -l 禁止内联编译</span><br></pre></td></tr></table></figure><h2 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h2><h3 id="1-返回指针"><a href="#1-返回指针" class="headerlink" title="1.返回指针"></a>1.返回指针</h3><p>将指针作为返回值，一定会触发逃逸，很明显返回了指针，编译器会认为这个变量还会被使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">T</span><span class="params">()</span> *<span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;A&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">T()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go build -gcflags="-m -l"  main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./m.go:10:9: &amp;A literal escapes to heap</span></span><br></pre></td></tr></table></figure><h3 id="2-栈空间占用过大"><a href="#2-栈空间占用过大" class="headerlink" title="2.栈空间占用过大"></a>2.栈空间占用过大</h3><p>我们创建一个<code>slice</code>的时候，编译器会根据栈空间判断是否在<code>栈</code>上分配。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S1</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[index] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S2</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[index] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">S1()</span><br><span class="line">S2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go build -gcflags="-m -l"  main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./m.go:4:11: make([]int, 1000) does not escape</span></span><br><span class="line"><span class="comment">// ./m.go:13:11: make([]int, 10000) escapes to heap</span></span><br></pre></td></tr></table></figure><p>由于逃逸分析发生在编译期，如果我们指定一个变量作为<code>slice</code>的长度，它就一定会发生逃逸。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[index] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">S(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go build -gcflags="-m -l"  main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./main.go:4:11: make([]int, n) escapes to heap</span></span><br></pre></td></tr></table></figure><h3 id="3-对象被引用"><a href="#3-对象被引用" class="headerlink" title="3.对象被引用"></a>3.对象被引用</h3><p>我们对一个对象取地址了，很多情况都会导致这个对象在函数外被访问到，所以这个对象会逃逸到堆上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">A <span class="keyword">struct</span> &#123;</span><br><span class="line">a *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">a := A&#123;a: &amp;b&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go build -gcflags="-m -l"  main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./main.go:10:6: moved to heap: b</span></span><br></pre></td></tr></table></figure><h3 id="4-闭包引用对象逃逸"><a href="#4-闭包引用对象逃逸" class="headerlink" title="4.闭包引用对象逃逸"></a>4.闭包引用对象逃逸</h3><p>虽然没有直接对对象取地址进行引用，但是闭包本质上就是允许函数内部变量被外部函数访问，所以它也必须分配到堆上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := Fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fibonacci: %d\n"</span>, f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go build -gcflags="-m -l"  main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./main.go:6:2: moved to heap: a</span></span><br><span class="line"><span class="comment">// ./main.go:6:5: moved to heap: b</span></span><br><span class="line"><span class="comment">// ./main.go:7:9: func literal escapes to heap</span></span><br><span class="line"><span class="comment">// ./main.go:17:13: ... argument does not escape</span></span><br><span class="line"><span class="comment">// ./main.go:17:34: f() escapes to heap</span></span><br></pre></td></tr></table></figure><h2 id="官网说明"><a href="#官网说明" class="headerlink" title="官网说明"></a>官网说明</h2><p>关于分配<code>golang</code>的官方说明如下：</p><blockquote><p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p><p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p><p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p><p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jetbrains技巧总结(2)——实用热键</title>
      <link href="2020/12/01/jetbrains-2/"/>
      <url>2020/12/01/jetbrains-2/</url>
      
        <content type="html"><![CDATA[<p><code>jetbrains</code>内置了非常多的实用快捷键，可以实现很多不亚于<code>vim</code>的效果。</p><a id="more"></a><h2 id="多光标"><a href="#多光标" class="headerlink" title="多光标"></a>多光标</h2><blockquote><p>OPTION+SHIFT 下拉，添加多光标</p></blockquote><h2 id="块状选择"><a href="#块状选择" class="headerlink" title="块状选择"></a>块状选择</h2><blockquote><p>OPTION+SHIFT 下拉出矩形选择框</p></blockquote><h2 id="选择到当前单词末尾"><a href="#选择到当前单词末尾" class="headerlink" title="选择到当前单词末尾"></a>选择到当前单词末尾</h2><blockquote><p>OPTION + SHIFT + -&gt; 选择到当前选中单词末尾</p></blockquote><h2 id="选择到末尾"><a href="#选择到末尾" class="headerlink" title="选择到末尾"></a>选择到末尾</h2><blockquote><p>COMMAND + SHIFT + -&gt; 选择到当前行末尾</p></blockquote><h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><blockquote><p>COMMAND + OPTION + J  selection + sorround </p></blockquote><h2 id="搜索-类"><a href="#搜索-类" class="headerlink" title="搜索 类"></a>搜索 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">⌥ + F7 find usage</span><br><span class="line">⌘ + O 通过类的名字进行搜索；</span><br><span class="line">⇧ + ⌘ + O 通过文件名进行搜索；</span><br><span class="line">⌥ + ⌘ + O 通过符号名进行搜索；</span><br><span class="line">⌘ + B 搜索声明；</span><br><span class="line">⌘ + U 基类&#x2F;函数搜索；</span><br></pre></td></tr></table></figure><h2 id="最近使用的文件，地方"><a href="#最近使用的文件，地方" class="headerlink" title="最近使用的文件，地方"></a>最近使用的文件，地方</h2><blockquote><p>COMMAND + E  最近打开的文件<br>COMMAND + SHIFT + E  最近查看的位置</p></blockquote><h2 id="重构菜单"><a href="#重构菜单" class="headerlink" title="重构菜单"></a>重构菜单</h2><blockquote><p>CTRL + T 打开重构选项</p></blockquote><h2 id="转到错误"><a href="#转到错误" class="headerlink" title="转到错误"></a>转到错误</h2><blockquote><p>F2 下一个错误<br>SHFIT + F2  前一个错误</p></blockquote><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><blockquote><p>COMMAND + SHIFT + OPTION + F7 选择范围<br>COMMAND+F 右上角 MASK： <em>.go,!</em>_test.go 排除test文件</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jetbrains技巧总结(1)——git</title>
      <link href="2020/11/25/jetbrains-1/"/>
      <url>2020/11/25/jetbrains-1/</url>
      
        <content type="html"><![CDATA[<p><code>git</code>命令行的功能足够强大，但是像修改记录对比、合并冲突等这些操作可视化更为方便。<code>jetbrains</code>家族的<code>IDE</code>都内置了<code>git</code>客户端，能够通过可视化的方式极大的简化操作。</p><a id="more"></a><h2 id="Annotate"><a href="#Annotate" class="headerlink" title="Annotate"></a>Annotate</h2><p>如果需要查看当前文件最新的变更，右键点击行号的右侧，弹出的菜单中选择<code>Annotate</code>功能。</p><p><img src="https://pic.hupai.pro/img/xdfasdfs.png" alt="Annnotate"></p><p>然后可以看到这个文件最新的变更记录的日期及修改人，选择任一个变更记录，右键选择<code>Show Diff</code>可以查看这次变更前后的对比。</p><p><img src="https://pic.hupai.pro/img/xcafsdqwer.png" alt></p><h2 id="撤销工作区变更"><a href="#撤销工作区变更" class="headerlink" title="撤销工作区变更"></a>撤销工作区变更</h2><p>当我们对工作区有修改之后，变更位置右侧会变有修改标识，点击可以选择查看、撤回等操作</p><p><img src="https://pic.hupai.pro/img/20201125132041.png" alt="变更"></p><h2 id="查看文件修改历史"><a href="#查看文件修改历史" class="headerlink" title="查看文件修改历史"></a>查看文件修改历史</h2><p>选择某一文件，右键 -&gt; git -&gt; Show History，可以看到此文件的所有历史提交记录，选择对应<code>commit</code>可以在面板右侧看到变更前后的记录。</p><p><img src="https://pic.hupai.pro/img/20201125132501.png" alt="文件历史"></p><h2 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h2><p>在打开的<code>git</code>历史中，选中分支，右键 -&gt; Show Diff，可以查看当前代码与此分支的对比。</p><p><img src="https://pic.hupai.pro/img/234234x.png" alt="分支"></p><h2 id="合并分支，解决冲突"><a href="#合并分支，解决冲突" class="headerlink" title="合并分支，解决冲突"></a>合并分支，解决冲突</h2><p>可视化操作对于冲突的解决是非常方便的。我们可以用<code>git</code>菜单栏上的合并分支功能进行合并。如果没有冲突会直接合并，出现冲突则会弹出<code>resolve</code>面板。</p><p><img src="https://pic.hupai.pro/img/212341.png" alt="合并分支"></p><p>在打开的面板中，左侧是当前分支，右侧是合并分支，中间是合并之后的代码。我们可以非常方便的对比，快速选取代码的保留和抛弃。</p><p><img src="https://pic.hupai.pro/img/20201125134326.png" alt="冲突"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(23)--golang标准库container</title>
      <link href="2020/11/24/heap/"/>
      <url>2020/11/24/heap/</url>
      
        <content type="html"><![CDATA[<p><code>golang</code>标准库<code>container</code>实现了三个复杂的数据结构：堆，链表，环。在一些特定的场景下，这三个数据结构可以非常方便的帮我们解决问题。</p><a id="more"></a><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一个非常实用的数据结构，可以非常方便的实现优先队列。</p><p>从定义上看，它在<code>sort.Interface</code>基础上增加了<code>Push</code>和<code>Pop</code>方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">sort.Interface</span><br><span class="line">Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的基本操作，<code>Pop</code>和<code>Push</code>，<code>Pop</code>是弹出当前堆顶元素，<code>Push</code>是添加元素。操</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">h.Push(x)</span><br><span class="line">up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">n := h.Len() - <span class="number">1</span></span><br><span class="line">h.Swap(<span class="number">0</span>, n)</span><br><span class="line">down(h, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用堆构建优先队列，完成N个链表的合并，源码如下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HeapInt []Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Val   <span class="keyword">int</span></span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HeapInt)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(Node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HeapInt)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">r := (*h)[<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">*h = (*h)[:<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HeapInt)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HeapInt)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HeapInt)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">r := &amp;ListNode&#123;&#125;</span><br><span class="line">tmp := r</span><br><span class="line">h := &amp;HeapInt&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, l := <span class="keyword">range</span> lists &#123;</span><br><span class="line"><span class="keyword">if</span> l != <span class="literal">nil</span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, Node&#123;Val: l.Val, Index: i&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">v := heap.Pop(h)</span><br><span class="line">node := v.(Node)</span><br><span class="line">tmp.Next = lists[node.Index]</span><br><span class="line">tmp = tmp.Next</span><br><span class="line">lists[node.Index] = lists[node.Index].Next</span><br><span class="line"><span class="keyword">if</span> lists[node.Index] != <span class="literal">nil</span> &#123;</span><br><span class="line">heap.Push(h, Node&#123;Val: lists[node.Index].Val, Index: node.Index&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a1 := &amp;ListNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">a2 := &amp;ListNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">a3 := &amp;ListNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">a1.Next = a2</span><br><span class="line">a2.Next = a3</span><br><span class="line"></span><br><span class="line">b1 := &amp;ListNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">b2 := &amp;ListNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">b3 := &amp;ListNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">b1.Next = b2</span><br><span class="line">b2.Next = b3</span><br><span class="line"></span><br><span class="line">c1 := &amp;ListNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">c2 := &amp;ListNode&#123;Val: <span class="number">6</span>&#125;</span><br><span class="line">c1.Next = c2</span><br><span class="line"></span><br><span class="line">r := mergeKLists([]*ListNode&#123;a1, b1, c1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(r.Val)</span><br><span class="line">r = r.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><code>golang</code>的<code>slice</code>非常好用，但是它底层是数组，数组的添加、删除元素的开销非常大，频繁增减元素的场景下，双向链表是更适合的数据结构。</p><p><code>golang</code>中<code>container/list</code>的数据结构源码中，每个节点记录了前后元素指针及归属的<code>list</code>对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line"><span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line"><span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line"><span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line"><span class="comment">// element (l.Front()).</span></span><br><span class="line">next, prev *Element</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list to which this element belongs.</span></span><br><span class="line">list *List</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value stored with this element.</span></span><br><span class="line">Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>list</code>使用也非常简单，示例如下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a new list and put some numbers in it.</span></span><br><span class="line">l := list.New()</span><br><span class="line">e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line">e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line">l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line">l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常实现一个<code>LRU</code>缓存，都需要用到<code>list</code>。</p><h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><p>环也就是循环链表，它使用场景不多，但是也有很多独特的优势：</p><p>1) 任何节点都可以做为头节点。 可以从任何节点开始进行链表的遍历。只要当第一个节点被重复访问时，则意味着遍历结束。<br>2) 用于实现队列数据结构是很有帮组的。 如果使用循环链表，则不需要为了队列而维护两个指针(<code>front</code>以及<code>rear</code>)。只需要维护尾节点一个指针即可，因为尾节点的后向节点就是<code>front</code>了。</p><p><code>golang</code>中<code>container/ring</code>也是通过双向链表实现,源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">next, prev *Ring</span><br><span class="line">Value      <span class="keyword">interface</span>&#123;&#125; <span class="comment">// for use by client; untouched by this library</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>约瑟夫问题</p><p><strong>约瑟夫环（约瑟夫问题）是一个数学的应用问题</strong>：已知n 个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。 从编号为k 的人开始报数，数到m 的那个人出圈；他的下一个人又从1 开始报数，数到m 的那个人又出圈；依此规律重复下去，直到剩余最后一个胜利者。 例如：有10个人围成一圈进行此游戏，每个人编号为1-10 。</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/ring"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(n, start, m <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">r := ring.New(n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">r.Value = i + <span class="number">1</span></span><br><span class="line">r = r.Next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; start<span class="number">-2</span>; i++ &#123;</span><br><span class="line">r = r.Next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r = r.Move(m - <span class="number">1</span>)</span><br><span class="line">fmt.Println(r.Next().Value)</span><br><span class="line"><span class="keyword">if</span> r.Len() == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">r.Unlink(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">solve(<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(23)--golang json操作库gojsonq</title>
      <link href="2020/11/23/gojsonq/"/>
      <url>2020/11/23/gojsonq/</url>
      
        <content type="html"><![CDATA[<p>最近做日志消费需要解析<code>json</code>数据，只需要取其中几个字段，但是原始数据确有很多层嵌套，用<code>golang</code>一层一层解析，操作起来异常繁琐。<code>gojsonq</code>可以极大简化操作<code>json</code>。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/thedevsaddam/gojsonq" target="_blank" rel="noopener">源码地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/thedevsaddam/gojsonq/v2</span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gojsonq <span class="string">"github.com/thedevsaddam/gojsonq/v2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> json = <span class="string">`&#123;"name":&#123;"first":"Tom","last":"Hanks"&#125;,"age":61&#125;`</span></span><br><span class="line">name := gojsonq.New().FromString(json).Find(<span class="string">"name.first"</span>)</span><br><span class="line"><span class="built_in">println</span>(name.(<span class="keyword">string</span>)) <span class="comment">// 输出： Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="Find-path"><a href="#Find-path" class="headerlink" title="Find(path)"></a>Find(path)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item := gojsonq.New().File(<span class="string">"./data.json"</span>).Find(<span class="string">"vendor.items.[0]"</span>);</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, item)</span><br></pre></td></tr></table></figure><h3 id="FindR-path"><a href="#FindR-path" class="headerlink" title="FindR(path)"></a>FindR(path)</h3><p>使用上和<code>Find</code>类似，返回的不是<code>inteface</code>而是一个<code>Result</code>对象</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result, err := gojsonq.New().JSONString(jsonStr).FindR(<span class="string">"name.first"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">name, _ := result.String()</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, name)</span><br></pre></td></tr></table></figure><h3 id="From-path"><a href="#From-path" class="headerlink" title="From(path)"></a>From(path)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jq := gojsonq.New().File(<span class="string">"./data.json"</span>).From(<span class="string">"items"</span>).Where(<span class="string">"price"</span>, <span class="string">"&gt;"</span>, <span class="number">1200</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, jq.Get())</span><br></pre></td></tr></table></figure><h3 id="Select-properties"><a href="#Select-properties" class="headerlink" title="Select(properties)"></a>Select(properties)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jq := gojsonq.New().File(<span class="string">"./data.json"</span>).From(<span class="string">"items"</span>).Select(<span class="string">"id"</span>, <span class="string">"name"</span>).WhereNotNil(<span class="string">"id"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, jq.Get())</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">[]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;<span class="string">"id"</span>:<span class="number">1</span>, <span class="string">"name"</span>:<span class="string">"MacBook Pro 13 inch retina"</span>&#125;,</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;<span class="string">"id"</span>:<span class="number">2</span>, <span class="string">"name"</span>:<span class="string">"MacBook Pro 15 inch retina"</span>&#125;,</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;<span class="string">"id"</span>:<span class="number">3</span>, <span class="string">"name"</span>:<span class="string">"Sony VAIO"</span>&#125;,</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;<span class="string">"id"</span>:<span class="number">4</span>, <span class="string">"name"</span>:<span class="string">"Fujitsu"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>JSONQ</code>对象中包含了所有操作函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> JSONQ <span class="keyword">struct</span> &#123;</span><br><span class="line">option           option               <span class="comment">// contains options for JSONQ</span></span><br><span class="line">queryMap         <span class="keyword">map</span>[<span class="keyword">string</span>]QueryFunc <span class="comment">// contains query functions</span></span><br><span class="line">node             <span class="keyword">string</span>               <span class="comment">// contains node name</span></span><br><span class="line">raw              json.RawMessage      <span class="comment">// raw message from source (reader, string or file)</span></span><br><span class="line">rootJSONContent  <span class="keyword">interface</span>&#123;&#125;          <span class="comment">// original decoded json data</span></span><br><span class="line">jsonContent      <span class="keyword">interface</span>&#123;&#125;          <span class="comment">// copy of original decoded json data for further processing</span></span><br><span class="line">queryIndex       <span class="keyword">int</span>                  <span class="comment">// contains number of orWhere query call</span></span><br><span class="line">queries          [][]query            <span class="comment">// nested queries</span></span><br><span class="line">attributes       []<span class="keyword">string</span>             <span class="comment">// select attributes that will be available in final resuls</span></span><br><span class="line">offsetRecords    <span class="keyword">int</span>                  <span class="comment">// number of records that will be skipped in final result</span></span><br><span class="line">limitRecords     <span class="keyword">int</span>                  <span class="comment">// number of records that will be available in final result</span></span><br><span class="line">distinctProperty <span class="keyword">string</span>               <span class="comment">// contain the distinct attribute name</span></span><br><span class="line">errors           []error              <span class="comment">// contains all the errors when processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数支持指定<code>Decoder</code>，如果不传，默认使用标准库<code>encoding/json</code>进行解码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(options ...OptionFunc)</span> *<span class="title">JSONQ</span></span> &#123;</span><br><span class="line">jq := &amp;JSONQ&#123;</span><br><span class="line">queryMap: defaultQueries(),</span><br><span class="line">option: option&#123;</span><br><span class="line">decoder:   &amp;DefaultDecoder&#123;&#125;,</span><br><span class="line">separator: defaultSeparator,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line"><span class="keyword">if</span> err := option(jq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">jq.addError(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionFunc <span class="function"><span class="keyword">func</span><span class="params">(*JSONQ)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithDecoder take a custom decoder to decode JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDecoder</span><span class="params">(u Decoder)</span> <span class="title">OptionFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(j *JSONQ)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"decoder can not be nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">j.option.decoder = u</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithSeparator set custom separator for traversing child node, default separator is DOT (.)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithSeparator</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">OptionFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(j *JSONQ)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"separator can not be empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line">j.option.separator = s</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getNestedValue</code>是最重要的解析函数。</p><ul><li><code>input</code>是原始的<code>json</code>数据。</li><li><code>node</code>为传入的节点信息,如<code>user.name</code></li><li><code>separator</code>为<code>node</code>中<code>key</code>的分隔符,如<code>.</code></li></ul><p>对于<code>map</code>的情况，一层层解析成<code>input.(map[string]interface{})</code>和<code>input.(map[string][]interface{})</code>将原始数据逐层解析出来。</p><p>对于<code>array</code>则用<code>isIndex</code>处理<code>json</code>中数组的情况，原始数据解析成<code>[]interface</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNestedValue</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;, node, separator <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">pp := strings.Split(node, separator)</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> pp &#123;</span><br><span class="line"><span class="keyword">if</span> isIndex(n) &#123;</span><br><span class="line"><span class="comment">// find slice/array</span></span><br><span class="line"><span class="keyword">if</span> arr, ok := input.([]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">indx, err := getIndex(n)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> input, err</span><br><span class="line">&#125;</span><br><span class="line">arrLen := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> arrLen == <span class="number">0</span> ||</span><br><span class="line">indx &gt; arrLen<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> empty, errors.New(<span class="string">"empty array"</span>)</span><br><span class="line">&#125;</span><br><span class="line">input = arr[indx]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// map内是对象</span></span><br><span class="line">validNode := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mp, ok := input.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">input, ok = mp[n]</span><br><span class="line">validNode = ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map是同列表</span></span><br><span class="line"><span class="keyword">if</span> mp, ok := input.(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">input, ok = mp[n]</span><br><span class="line">validNode = ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !validNode &#123;</span><br><span class="line"><span class="keyword">return</span> empty, fmt.Errorf(<span class="string">"invalid node name %s"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> input, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL GTID详解</title>
      <link href="2020/11/04/mysql-gtid/"/>
      <url>2020/11/04/mysql-gtid/</url>
      
        <content type="html"><![CDATA[<p><code>GTID</code>是<code>MySQL</code>5.6版本的新特性，其全称是<code>Global Transaction Identifier</code>，可简化<code>MySQL</code>的主从切换以及<code>Failover</code>。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>GTID</code>用于在<code>Binlog</code>中唯一标识一个事务。当事务提交时，<code>MySQL</code>在写binlog的时候，会先写一个特殊的<code>Binlog Event</code>，类型为<code>GTID_Event</code>，指定下一个事务的<code>GTID</code>，然后再写事务的<code>Binlog</code>。主从同步时<code>GTID_Event</code>和事务的<code>Binlog</code>都会传递到从库，从库在执行的时候也是用同样的<code>GTID</code>去写<code>binlog</code>，这样主从同步以后，就可通过<code>GTID</code>确定从库同步到的位置了。也就是说，无论是级联情况，还是一主多从情况，都可以通过<code>GTID</code>自动定位，而无需像之前那样通过<code>File_name</code>和<code>File_position</code>定位了。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li>GTID = server_uuid:transaction_id </li><li>server_uuid 来源于 <code>auto.cnf</code>,服务的唯一标识，<code>MySQL</code>使用机器网卡、当前时间、随机数等拼接成一个128bit的uuid</li><li>transaction_id <code>InnoDB</code> 每一个事物都存在一个事务唯一ID, 从 <code>1</code> 开始的自增计数，表示在这个主库上执行的第 <code>n</code> 个事务</li><li>GTID: 在一组复制中，全局唯一</li></ul><h2 id="开启GTID"><a href="#开启GTID" class="headerlink" title="开启GTID"></a>开启GTID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode&#x3D;ON(必选)  </span><br><span class="line">enforce-gtid-consistency（必选）</span><br><span class="line">log_bin&#x3D;ON（可选）--高可用切换，最好设置ON  </span><br><span class="line">log-slave-updates&#x3D;ON（可选）--高可用切换，最好设置ON</span><br></pre></td></tr></table></figure><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><code>GTID</code>的最大特性就是它的<code>Failover</code>能力，如下架构，当主库<code>A crash</code>时，需要进行主从切换，将B或C其中一台提升为主，传统模式我们无法确认哪台数据较新，由于同一个事务在每台机器上所在的<code>binlog</code>名字和位置都不一样，那么怎么找到C当前同步停止点，对应B的<code>master_log_file</code>和<code>master_log_pos</code>，需要通过程序对比或者借助<code>MHA</code>等工具。</p><p><code>GTID</code>出现后，这个问题就显得非常简单。由于同一事务的<code>GTID</code>在所有节点上的值一致，那么根据C当前停止点的<code>GTID</code>就能唯一定位到B上的<code>GTID</code>。甚至由于<code>MASTER_AUTO_POSITION</code>功能的出现，我们都不需要知道<code>GTID</code>的具体值，直接使用<code>CHANGE MASTER TO MASTER_HOST=&#39;xxx&#39;</code>, <code>MASTER_AUTO_POSITION=1</code>命令就可以直接完成<code>failover</code>的工作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang版Canal源码阅读</title>
      <link href="2020/11/04/go-canal/"/>
      <url>2020/11/04/go-canal/</url>
      
        <content type="html"><![CDATA[<p><code>Canal</code>是阿里开源的一款<code>Java</code>语言编写的中间件，主要用途是基于MySQL 数据库增量日志解析。<a href="https://github.com/siddontang/go-mysql" target="_blank" rel="noopener">go-mysql</a>是<code>golang</code>版本的实现。它不仅支持增量<code>binlog</code>消费，也支持全量数据的解析。</p><a id="more"></a><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── canal    &#x2F;&#x2F; 核心类</span><br><span class="line">├── client   &#x2F;&#x2F; 连接数据库的client</span><br><span class="line">├── cmd      &#x2F;&#x2F; 功能</span><br><span class="line">│   ├── go-binlogparser</span><br><span class="line">│   ├── go-canal</span><br><span class="line">│   ├── go-mysqlbinlog</span><br><span class="line">│   └── go-mysqldump</span><br><span class="line">├── docker</span><br><span class="line">├── driver   </span><br><span class="line">├── dump     &#x2F;&#x2F; 导出</span><br><span class="line">├── failover</span><br><span class="line">├── mysql</span><br><span class="line">├── notes</span><br><span class="line">├── packet</span><br><span class="line">├── replication  &#x2F;&#x2F; slave注册,binlog解析</span><br><span class="line">├── schema       &#x2F;&#x2F; schema解析</span><br><span class="line">├── server</span><br><span class="line">├── test_util</span><br><span class="line">└── utils</span><br></pre></td></tr></table></figure><h2 id="Canal类解析"><a href="#Canal类解析" class="headerlink" title="Canal类解析"></a>Canal类解析</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Canal can sync your MySQL data into everywhere, like Elasticsearch, Redis, etc...</span></span><br><span class="line"><span class="comment">// MySQL must open row format for binlog</span></span><br><span class="line"><span class="keyword">type</span> Canal <span class="keyword">struct</span> &#123;</span><br><span class="line">m sync.Mutex</span><br><span class="line"></span><br><span class="line">cfg *Config    <span class="comment">// 配置</span></span><br><span class="line"></span><br><span class="line">parser     *parser.Parser  <span class="comment">// 解析器</span></span><br><span class="line">master     *masterInfo</span><br><span class="line">dumper     *dump.Dumper  <span class="comment">// 数据导出</span></span><br><span class="line">dumped     <span class="keyword">bool</span></span><br><span class="line">dumpDoneCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">syncer     *replication.BinlogSyncer  <span class="comment">// 伪装成从库，同步binlog，事件生产者</span></span><br><span class="line"></span><br><span class="line">eventHandler EventHandler  <span class="comment">// 事件处理，消费者</span></span><br><span class="line"></span><br><span class="line">connLock sync.Mutex</span><br><span class="line">conn     *client.Conn  <span class="comment">// 数据库连接</span></span><br><span class="line"></span><br><span class="line">tableLock          sync.RWMutex</span><br><span class="line">tables             <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Table</span><br><span class="line">errorTablesGetTime <span class="keyword">map</span>[<span class="keyword">string</span>]time.Time</span><br><span class="line"></span><br><span class="line">tableMatchCache   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">includeTableRegex []*regexp.Regexp</span><br><span class="line">excludeTableRegex []*regexp.Regexp</span><br><span class="line"></span><br><span class="line">delay *<span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">ctx    context.Context</span><br><span class="line">cancel context.CancelFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Canal</code>中比较重要的是<code>Dumper</code>类和<code>BinlogSyncer</code>类,<code>Dumper</code>用于处理当前数据，<code>BinlogSyncer</code>处理增量数据。</p><h2 id="Dumper"><a href="#Dumper" class="headerlink" title="Dumper"></a>Dumper</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlick mysqldump, Dumper is designed for parsing and syning data easily.</span></span><br><span class="line"><span class="keyword">type</span> Dumper <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// mysqldump execution path, like mysqldump or /usr/bin/mysqldump, etc...</span></span><br><span class="line">ExecutionPath <span class="keyword">string</span>  </span><br><span class="line"></span><br><span class="line">Addr     <span class="keyword">string</span></span><br><span class="line">User     <span class="keyword">string</span></span><br><span class="line">Password <span class="keyword">string</span></span><br><span class="line">Protocol <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Will override Databases</span></span><br><span class="line">Tables  []<span class="keyword">string</span></span><br><span class="line">TableDB <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">Databases []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">Where   <span class="keyword">string</span></span><br><span class="line">Charset <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">IgnoreTables <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">ExtraOptions []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">ErrOut io.Writer</span><br><span class="line"></span><br><span class="line">masterDataSkipped <span class="keyword">bool</span></span><br><span class="line">maxAllowedPacket  <span class="keyword">int</span></span><br><span class="line">hexBlob           <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dumper)</span> <span class="title">Dump</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出数据并解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dumper)</span> <span class="title">DumpAndParse</span><span class="params">(h ParseHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dumper</code>原理是通过<code>myqldump</code>导出数据到<code>Dump</code>函数传入的参数<code>io.Writer</code>中。</p><p><code>DumpAndParse</code>函数接收<code>ParseHandler</code>这个<code>interface</code>进行数据解析，以此实现导出到不同的数据源。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析mysqldump数据</span></span><br><span class="line"><span class="keyword">type</span> ParseHandler <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Parse CHANGE MASTER TO MASTER_LOG_FILE=name, MASTER_LOG_POS=pos;</span></span><br><span class="line">BinLog(name <span class="keyword">string</span>, pos <span class="keyword">uint64</span>) error  <span class="comment">// 解析binlog position</span></span><br><span class="line">GtidSet(gtidsets <span class="keyword">string</span>) error  <span class="comment">// 解析gtid</span></span><br><span class="line">Data(schema <span class="keyword">string</span>, table <span class="keyword">string</span>, values []<span class="keyword">string</span>) error  <span class="comment">// 处理行数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BinlogSyncer"><a href="#BinlogSyncer" class="headerlink" title="BinlogSyncer"></a>BinlogSyncer</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BinlogSyncer <span class="keyword">struct</span> &#123;</span><br><span class="line">m sync.RWMutex</span><br><span class="line"></span><br><span class="line">cfg BinlogSyncerConfig</span><br><span class="line"></span><br><span class="line">c *client.Conn</span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">parser *BinlogParser</span><br><span class="line"></span><br><span class="line">nextPos Position</span><br><span class="line"></span><br><span class="line">prevGset, currGset GTIDSet</span><br><span class="line"></span><br><span class="line">running <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">ctx    context.Context</span><br><span class="line">cancel context.CancelFunc</span><br><span class="line"></span><br><span class="line">lastConnectionID <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">retryCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定的postion开始同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinlogSyncer)</span> <span class="title">StartSync</span><span class="params">(pos Position)</span> <span class="params">(*BinlogStreamer, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于GTID同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinlogSyncer)</span> <span class="title">StartSyncGTID</span><span class="params">(gset GTIDSet)</span> <span class="params">(*BinlogStreamer, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinlogStreamer gets the streaming event.</span></span><br><span class="line"><span class="keyword">type</span> BinlogStreamer <span class="keyword">struct</span> &#123;</span><br><span class="line">ch  <span class="keyword">chan</span> *BinlogEvent</span><br><span class="line">ech <span class="keyword">chan</span> error</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BinlogSyncer</code>同时支持指定<code>binlog</code>位置和<code>GTID</code>模式进行同步。它将接收到的<code>binlog</code>消息写到<code>BinlogStreamer</code>内部的<code>chan *BinlogEvent</code>中。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BinlogEvent <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// raw binlog data which contains all data, including binlog header and event body, and including crc32 checksum if exists</span></span><br><span class="line">RawData []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">Header *EventHeader</span><br><span class="line">Event  Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *BinlogEvent)</span> <span class="title">Dump</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">e.Header.Dump(w)</span><br><span class="line">e.Event.Dump(w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">//Dump Event, format like python-mysql-replication</span></span><br><span class="line">Dump(w io.Writer)</span><br><span class="line"></span><br><span class="line">Decode(data []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入<code>BinlogStreamer</code>中的消息，最后也会被写入到<code>Event</code>这个接口<code>Dump</code>函数中的<code>io.Writer</code>中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(23)--golang常用设计模式</title>
      <link href="2020/10/22/go-patterns/"/>
      <url>2020/10/22/go-patterns/</url>
      
        <content type="html"><![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常面向对象语言会有很多常见的设计范式，<code>golang</code>作为一门不够彻底的面向对象编程语言，也有很多常见的设计范式。</p><a id="more"></a><p>设计模式总共23种，但很多设计模式对<code>golagn</code>并不完全适用，本文主要总结下<code>golang</code>中常用的一些设计模式。</p><p>下述代码源码可以在 <a href="https://github.com/go-zs/go-patterns" target="_blank" rel="noopener">Golang常用设计模式</a> 中获取。</p><h2 id="选项模式"><a href="#选项模式" class="headerlink" title="选项模式"></a>选项模式</h2><p><code>golang</code>函数式选项模式是利用<code>golang</code>函数可变参数，很好的解决了缺少构造函数缺少默认值以及构造参数变更的问题。</p><p>通常用于<code>struct</code>的构造函数中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> options</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">school <span class="keyword">struct</span> &#123;</span><br><span class="line">students <span class="keyword">int</span></span><br><span class="line">teachers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SchoolOption <span class="keyword">interface</span> &#123;</span><br><span class="line">apply(*school)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultStudents = <span class="number">100</span></span><br><span class="line">defaultTeachers = <span class="number">500</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchool</span><span class="params">(options ...SchoolOption)</span> *<span class="title">school</span></span> &#123;</span><br><span class="line">s := &amp;school&#123;</span><br><span class="line">students: defaultStudents,</span><br><span class="line">teachers: defaultTeachers,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> options &#123;</span><br><span class="line">o.apply(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetStudents</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">SchoolOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> studentOption(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetTeachers</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">SchoolOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> teacherOption(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentOption <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o studentOption)</span> <span class="title">apply</span><span class="params">(s *school)</span></span> &#123;</span><br><span class="line">s.students = <span class="keyword">int</span>(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> teacherOption <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o teacherOption)</span> <span class="title">apply</span><span class="params">(s *school)</span></span> &#123;</span><br><span class="line">s.teachers = <span class="keyword">int</span>(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂方法模式（<code>Factory method pattern</code>）是一种实现了<code>工厂</code>概念的面向对象设计模式。</p><p>就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。</p><p>工厂方法模式的实质是<em>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类</em>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">CarFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">ICar <span class="keyword">interface</span> &#123;</span><br><span class="line">Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Benz <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Bmw  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">CarType <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">CarTypeBenz CarType = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">CarTypeBmw</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCarFactory</span><span class="params">()</span> *<span class="title">CarFactory</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CarFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Benz)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Benz run"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bmw)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Bmw run"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CarFactory)</span> <span class="title">Build</span><span class="params">(tp CarType)</span> <span class="title">ICar</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> tp &#123;</span><br><span class="line"><span class="keyword">case</span> CarTypeBenz:</span><br><span class="line"><span class="keyword">return</span> Benz&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> CarTypeBmw:</span><br><span class="line"><span class="keyword">return</span> Bmw&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种常用的软件设计模式，在它的核心结构中只包含一个实例的特殊类。</p><p><code>golang</code>中可以用<code>sync.Once</code>来实现类的单次初始化，这种方式也可以很好的实现 <em>实例延迟加载</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">once   sync.Once</span><br><span class="line">single *Singleton</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleton</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">single = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> single</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了算法家族，在调用算法家族的时候不感知算法的变化，客户也不会受到影响。</p><p>例如用户在使用浏览器时，使用的搜索引擎可以自由选择。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">ISearcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Search() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Baidu <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Google <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sougou <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Chrome <span class="keyword">struct</span> &#123;</span><br><span class="line">searcher ISearcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChromeOption <span class="function"><span class="keyword">func</span><span class="params">(chrome *Chrome)</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Google)</span> <span class="title">Search</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"google"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Baidu)</span> <span class="title">Search</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"baidu"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Sougou)</span> <span class="title">Search</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"sougou"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">defaultChromeSearcher = Google&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChrome</span><span class="params">(options ...ChromeOption)</span> *<span class="title">Chrome</span></span> &#123;</span><br><span class="line">c := &amp;Chrome&#123;</span><br><span class="line">searcher: defaultChromeSearcher,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> options &#123;</span><br><span class="line">o(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chrome)</span> <span class="title">SetSearcher</span><span class="params">(s ISearcher)</span></span> &#123;</span><br><span class="line">c.searcher = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chrome)</span> <span class="title">Find</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(c.searcher.Search())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> design patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda</title>
      <link href="2020/10/06/conda/"/>
      <url>2020/10/06/conda/</url>
      
        <content type="html"><![CDATA[<p><code>conda</code>是<code>Anoconda</code>提供的包管理工具。</p><a id="more"></a><h2 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h2><p><code>conda</code>是<code>Anoconda</code>提供的包管理工具。</p><p>我们可以在<a href="https://repo.anaconda.com/archive/" target="_blank" rel="noopener">Annoconda下载地址</a>找到<code>Anoconda</code>的安装包，下载后安装。</p><p>如果我们只需要安装<code>conda</code>，而不需要<code>Anoconda</code>提供的集成环境，也可以选择安装<code>MiniConda</code>。</p><p><a href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/" target="_blank" rel="noopener">miniconda官方安装地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -O ~/miniconda.sh</span><br><span class="line">bash ~/miniconda.sh -b -p $HOME/miniconda</span><br></pre></td></tr></table></figure><p>安装完成后可以执行<code>conda -V</code>查看安装情况及版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda -V</span></span><br><span class="line">conda 4.9.2</span><br></pre></td></tr></table></figure><h2 id="conda镜像源"><a href="#conda镜像源" class="headerlink" title="conda镜像源"></a>conda镜像源</h2><p><code>conda</code>国外源地址非常不稳定，我们可以选国内的镜像源。</p><p>首先执行<code>conda config --set show_channel_urls yes</code>，生成<code>.condarc</code>文件。然后添加以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;pro</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">  msys2: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">  bioconda: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">  menpo: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">  pytorch: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">  simpleitk: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br></pre></td></tr></table></figure><p>运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p><h2 id="conda基本使用"><a href="#conda基本使用" class="headerlink" title="conda基本使用"></a>conda基本使用</h2><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a>1.常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）conda list 查看安装了哪些包。</span><br><span class="line"></span><br><span class="line">2）conda env list 或 conda info -e 查看当前存在哪些虚拟环境</span><br><span class="line"></span><br><span class="line">3）conda update conda 检查更新当前conda</span><br></pre></td></tr></table></figure><h3 id="2-创建python虚拟环境"><a href="#2-创建python虚拟环境" class="headerlink" title="2.创建python虚拟环境"></a>2.创建python虚拟环境</h3><pre><code>使用 conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。</code></pre><h3 id="3-使用激活-或切换不同python版本-的虚拟环境"><a href="#3-使用激活-或切换不同python版本-的虚拟环境" class="headerlink" title="3.使用激活(或切换不同python版本)的虚拟环境"></a>3.使用激活(或切换不同python版本)的虚拟环境</h3><blockquote><p>conda activate py36</p></blockquote><h3 id="4-对虚拟环境中安装额外的包"><a href="#4-对虚拟环境中安装额外的包" class="headerlink" title="4.对虚拟环境中安装额外的包"></a>4.对虚拟环境中安装额外的包</h3><pre><code>使用命令conda install -n your_env_name [package]即可安装package到your_env_name中</code></pre><h3 id="5-关闭虚拟环境-即从当前环境退出返回使用PATH环境中的默认python版本"><a href="#5-关闭虚拟环境-即从当前环境退出返回使用PATH环境中的默认python版本" class="headerlink" title="5.关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)"></a>5.关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)</h3><blockquote><p>conda deactivate</p></blockquote><h3 id="6-删除虚拟环境"><a href="#6-删除虚拟环境" class="headerlink" title="6.删除虚拟环境"></a>6.删除虚拟环境</h3><p>   使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。</p><h3 id="7-删除环境中的某个包"><a href="#7-删除环境中的某个包" class="headerlink" title="7.删除环境中的某个包"></a>7.删除环境中的某个包</h3><p>   使用命令conda remove –name your_env_name  package_name 即可。</p><h3 id="8-导出依赖包"><a href="#8-导出依赖包" class="headerlink" title="8.导出依赖包"></a>8.导出依赖包</h3><blockquote><p>conda list -e &gt; requirements.txt</p></blockquote><h3 id="9-安装依赖"><a href="#9-安装依赖" class="headerlink" title="9.安装依赖"></a>9.安装依赖</h3><p>指定文件安装依赖</p><blockquote><p>conda install -y -f requirements.txt</p></blockquote><p><code>conda</code>失败的时候执行<code>pip install</code></p><blockquote><p>while read requirement; do conda install –yes $requirement || pip install $requirement; done &lt; requirements.txt </p></blockquote><h3 id="10-导出conda环境"><a href="#10-导出conda环境" class="headerlink" title="10.导出conda环境"></a>10.导出conda环境</h3><blockquote><p>conda env export &gt; freeze.yml</p></blockquote><h3 id="11-导入conda环境"><a href="#11-导入conda环境" class="headerlink" title="11. 导入conda环境"></a>11. 导入conda环境</h3><blockquote><p>conda env create -f freeze.yml</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis源码分析(2)--rehash</title>
      <link href="2020/09/24/redis-rehash/"/>
      <url>2020/09/24/redis-rehash/</url>
      
        <content type="html"><![CDATA[<p><code>Redis</code>底层数据结构是<code>hash</code>，<code>hash</code>在发生扩容、缩容的时候都会发生<code>rehash</code>。它的<code>rehash</code>不是一蹴而就的，而是一个渐近式的过程。</p><a id="more"></a><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>字典及hash表的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;   <span class="comment">//  类型</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];     <span class="comment">//  ht[0] 旧数组, ht[1]rehash后的数组</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;   <span class="comment">// 当前rehash的索引位置，初始为0  -1表示未rehash</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; </span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;      <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// sizemask=size-1,用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;      <span class="comment">// 已经用的节点数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>从源码我们可以知道，<code>dict</code>中存储了一个长度为2的<code>dictht</code>类型数组，用于记录，<code>rehash</code>前后的两个哈希表。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 正在rehash或者新的size小于当前使用的key的数量，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; <span class="built_in">size</span>)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span>) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.<span class="built_in">size</span> = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典初始化</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ht[1]中存储新的hash</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    <span class="comment">// 记录rehash index</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// empty_visits 旧key迁移到新key的数量</span></span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rehash</code>的做的事其实就是逐步将旧<code>hash</code>中的<code>key</code>迁移到新<code>hash</code>中。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dictRehashStep</code>在dict的增删改查操作中都会被调用,每次调用都会触发一次<code>rehash</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>dictRehashMilliseconds</code>函数会进行<code>n</code>毫秒的<code>rehash</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>databasesCron</code>是<code>redis</code>中的一个定时器，它会定时调用<code>dictRehashMilliseconds</code>进行<code>rehash</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">databasesCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Expire keys by random sampling. Not required for slaves</span></span><br><span class="line"><span class="comment">     * as master will synthesize DELs for us. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iAmMaster()) &#123;</span><br><span class="line">            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expireSlaveKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Defrag keys gradually. */</span></span><br><span class="line">    activeDefragCycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform hash tables rehashing if needed, but only if there are no</span></span><br><span class="line"><span class="comment">     * other processes saving the DB on disk. Otherwise rehashing is bad</span></span><br><span class="line"><span class="comment">     * as will cause a lot of copy-on-write of memory pages. */</span></span><br><span class="line">    <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">        <span class="comment">/* We use global counters so if we stop the computation at a given</span></span><br><span class="line"><span class="comment">         * DB we'll be able to start from the successive in the next</span></span><br><span class="line"><span class="comment">         * cron loop iteration. */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> resize_db = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> rehash_db = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don't test more DBs than we have. */</span></span><br><span class="line">        <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum) dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum);</span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rehash */</span></span><br><span class="line">        <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> work_done = incrementallyRehash(rehash_db);</span><br><span class="line">                <span class="keyword">if</span> (work_done) &#123;</span><br><span class="line">                    <span class="comment">/* If the function did some work, stop here, we'll do</span></span><br><span class="line"><span class="comment">                     * more at the next cron loop. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* If this db didn't need rehash, we'll try the next one. */</span></span><br><span class="line">                    rehash_db++;</span><br><span class="line">                    rehash_db %= server.dbnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下，<code>redis</code>的<code>rehash</code>是在在字典的读写操作，以及定时事件中每次完成一定量的迁移。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>源码分析redis(1)--scan</title>
      <link href="2020/09/16/redis-scan/"/>
      <url>2020/09/16/redis-scan/</url>
      
        <content type="html"><![CDATA[<p>Redis的SCAN是一个基于游标的迭代器，Redis的底层数据结构是<code>Hash</code>，那么它是如何保证发生<code>rehash</code>的情况下也能完整的遍历。</p><a id="more"></a><h2 id="scan用法"><a href="#scan用法" class="headerlink" title="scan用法"></a>scan用法</h2><p>由于<code>redis</code>的单线程的特性，<code>keys</code>会导致<code>redis</code>长时间的堵塞，所以生产环境是严禁使用<code>keys</code>命令的。</p><p>但是很多时候，我们确实需要筛选出符合条件的<code>key</code>，<code>scan</code>命令可以很好的解决这个问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [MATCH pattern] [COUNT count]</span><br><span class="line"></span><br><span class="line">eg: scan 0 match * count 100</span><br></pre></td></tr></table></figure><h2 id="scan的遍历顺序"><a href="#scan的遍历顺序" class="headerlink" title="scan的遍历顺序"></a>scan的遍历顺序</h2><p><code>Redis</code>的<code>key</code>也是用的<code>Hash</code>表作为底层实现，也就是数组+链表的数据结构。</p><p><code>scan</code>其实就是对这个数组的遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 总共4个key</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;abc&quot;</span><br><span class="line">2) &quot;qwe&quot;</span><br><span class="line">3) &quot;jhi&quot;</span><br><span class="line">4) &quot;def&quot;</span><br><span class="line"></span><br><span class="line"># 每次scan一个,返回的第一个参数为数组index</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match * count 1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) 1) &quot;abc&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 2 match * count 1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) 1) &quot;jhi&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1 match * count 1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) 1) &quot;qwe&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3 match * count 1</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;def&quot;</span><br></pre></td></tr></table></figure><p>它的遍历顺序是 <code>0-&gt;2-&gt;1-&gt;3</code></p><p>顺序看起来很奇怪，看下源码的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dick.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction* bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line">      ...</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        <span class="comment">// 将游标的umask位的bit都置为1</span></span><br><span class="line">        v |= ~m0;</span><br><span class="line">        <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">        <span class="comment">// 反转游标</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        <span class="comment">// 反转后+1，达到高位加1的效果</span></span><br><span class="line">        v++;</span><br><span class="line">        <span class="comment">// 再次反转复位</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>发现每次这个序列是高位加1的。普通二进制的加法，是从右往左相加、进位。而这个序列是从左往右相加、进位的。</p><p>对应二进制顺序其实是 <code>00-&gt;10-&gt;01-&gt;11</code></p><p>我们看下<code>redis</code>这种高位进位的遍历方式遇到扩容或者缩容会如何处理。假设加入原始数组有4个元素，也就是索引有2位，这时候扩容会把它变成3位，并进行Rehash。</p><p><img src="https://pic.hupai.pro/img/scan.png" alt="scan"></p><p>原来索引为<code>xx</code>的所有元素被重新分配到<code>0xx</code>和<code>1xx</code>索引上。</p><p>此时的遍历顺序为，<code>0-&gt;4-&gt;2-&gt;6-&gt;1-&gt;5-&gt;3-&gt;7</code>，也就是<code>000-&gt;100-&gt;010-&gt;110-&gt;001-&gt;101-&gt;011-&gt;111</code></p><p>参考上图，当我们即将遍历<code>10</code>时，<code>dict</code>进行了扩容，这时，<code>scan</code>命令会从<code>010</code>开始遍历，而<code>000</code>和<code>100</code>（原<code>00</code>下挂接的元素）不会再被重复遍历,未被遍历的元素<code>01</code>和<code>11</code>也不会遗漏。</p><p>从原理上说，这种遍历方式保证了在扩容的时候，原来<code>dict</code>上的4个元素在新的<code>dict</code>上保持了原来的遍历顺序，因此不会重复并且不会遗漏。</p><p>再来看看缩容的情况。假设<code>dict</code>从3位缩容到2位，当即将遍历<code>110</code>时，<code>dict</code>发生了缩容，这时<code>scan</code>会遍历<code>10</code>。这时<code>010</code>上的元素会被重复遍历，但<code>010</code>之前的元素都不会被重复遍历了。所以，缩容时还是可能会有些重复元素出现的。</p><p>总结来说，<code>redis</code>里<code>rehash</code>扩容时，<code>scan</code>命令不会重复也不会遗漏。而缩容时，有可能会造成重复但不会遗漏。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(23)--goland简化单元测试的利器-testify</title>
      <link href="2020/09/15/testify/"/>
      <url>2020/09/15/testify/</url>
      
        <content type="html"><![CDATA[<p><code>golang</code>自带了一个非常强大的单元测试组件，让我们可以非常方便的编写单元测试，美中不足的是它缺少断言功能，很多时候不得不写很多的<code>if</code>判断。<code>testify</code>是一个非常强大的测试包，提供了很多非常实用的断言功能，大大提升了单元测试的可读性。</p><a id="more"></a><h2 id="安装testify"><a href="#安装testify" class="headerlink" title="安装testify"></a>安装testify</h2><p>执行下面的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;stretchr&#x2F;testify&#x2F;assert</span><br></pre></td></tr></table></figure><p>在<code>test</code>文件中引入<code>testify</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xx_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"testing"</span></span><br><span class="line">  <span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h2><p>参考官方示例</p><p>可用于判断<code>err</code>是否为<code>nil</code>,值是否相等，大于、小于, true、false等</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> yours</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"testing"</span></span><br><span class="line">  <span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert equality</span></span><br><span class="line">  assert.Equal(t, <span class="number">123</span>, <span class="number">123</span>, <span class="string">"they should be equal"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert inequality</span></span><br><span class="line">  assert.NotEqual(t, <span class="number">123</span>, <span class="number">456</span>, <span class="string">"they should not be equal"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert for nil (good for errors)</span></span><br><span class="line">  assert.Nil(t, object)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert for greater, less</span></span><br><span class="line">assert.Greater(t, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">assert.LessOrEqual(t, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert for true</span></span><br><span class="line">  assert.True(t, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assert for not nil (good when you expect something)</span></span><br><span class="line">  <span class="keyword">if</span> assert.NotNil(t, object) &#123;</span><br><span class="line">    <span class="comment">// now we know that object isn't nil, we are safe to make</span></span><br><span class="line">    <span class="comment">// further assertions without causing any errors</span></span><br><span class="line">    assert.Equal(t, <span class="string">"Something"</span>, object.Value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>golang</code>强类型的特性，要比较不同类型的值是否相等，不能用<code>assert.Equal</code>，可以用<code>assert.EqualValues</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert.EqualValues(t, <span class="keyword">uint64</span>(<span class="number">1</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="accuire"><a href="#accuire" class="headerlink" title="accuire"></a>accuire</h2><p>它和<code>assert</code>非常类似，参考源码，它只是在<code>assert</code>基础上，增加了<code>断言</code>失败的时候，退出<code>test</code>的处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equal asserts that two objects are equal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    assert.Equal(t, 123, 123)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pointer variable equality is determined based on the equality of the</span></span><br><span class="line"><span class="comment">// referenced values (as opposed to the memory addresses). Function equality</span></span><br><span class="line"><span class="comment">// cannot be determined and will always fail.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(t TestingT, expected <span class="keyword">interface</span>&#123;&#125;, actual <span class="keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> h, ok := t.(tHelper); ok &#123;</span><br><span class="line">h.Helper()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> assert.Equal(t, expected, actual, msgAndArgs...) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.FailNow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Table-Driven-表驱动测试"><a href="#Table-Driven-表驱动测试" class="headerlink" title="Table Driven 表驱动测试"></a>Table Driven 表驱动测试</h2><p><code>golang</code>的匿名<code>struct</code>可以非常方便的实现表驱动测试。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.go</span></span><br><span class="line"><span class="keyword">package</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(userIds []<span class="keyword">uint64</span>)</span> []<span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">struct</span>&#123;&#125;, <span class="built_in">len</span>(userIds))</span><br><span class="line"><span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(userIds); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := m[userIds[j]]; !ok &#123;</span><br><span class="line">m[userIds[j]] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">userIds[i] = userIds[j]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userIds[:i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFilter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">testCases = []<span class="keyword">struct</span> &#123;</span><br><span class="line">userIds  []<span class="keyword">uint64</span></span><br><span class="line">expected []<span class="keyword">uint64</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">userIds:  <span class="literal">nil</span>,</span><br><span class="line">expected: <span class="literal">nil</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">userIds:  []<span class="keyword">uint64</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">expected: []<span class="keyword">uint64</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">userIds:  []<span class="keyword">uint64</span>&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">expected: []<span class="keyword">uint64</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">userIds:  []<span class="keyword">uint64</span>&#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">expected: []<span class="keyword">uint64</span>&#123;<span class="number">6</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">userIds:  []<span class="keyword">uint64</span>&#123;<span class="number">7</span>, <span class="number">22</span>, <span class="number">22</span>&#125;,</span><br><span class="line">expected: []<span class="keyword">uint64</span>&#123;<span class="number">7</span>, <span class="number">22</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">userIds:  []<span class="keyword">uint64</span>&#123;<span class="number">66</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">66</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">22</span>&#125;,</span><br><span class="line">expected: []<span class="keyword">uint64</span>&#123;<span class="number">66</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">11</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">r := Filter(c.userIds)</span><br><span class="line">assert.Equal(t, <span class="built_in">len</span>(r), <span class="built_in">len</span>(c.expected))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.expected); i++ &#123;</span><br><span class="line">assert.Equal(t, c.expected[i], r[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-使用"><a href="#mock-使用" class="headerlink" title="mock 使用"></a>mock 使用</h2><p><code>mock</code>可以让我们非常方便的隔离外部依赖，比如发送邮件、连接数据库等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/stretchr/testify/mock"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockSettingGetter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockSettingGetter)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    args := m.Called(key)</span><br><span class="line">    <span class="keyword">return</span> args.Get(<span class="number">0</span>).([]<span class="keyword">byte</span>), args.Error(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUpdateThreshold</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        v      <span class="keyword">string</span></span><br><span class="line">        err    error</span><br><span class="line">        rs     <span class="keyword">int64</span></span><br><span class="line">        hasErr <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;v: <span class="string">"1000"</span>, err: <span class="literal">nil</span>, rs: <span class="number">1000</span>, hasErr: <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;v: <span class="string">"a"</span>, err: <span class="literal">nil</span>, rs: <span class="number">0</span>, hasErr: <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;v: <span class="string">""</span>, err: fmt.Errorf(<span class="string">"consul is down"</span>), rs: <span class="number">0</span>, hasErr: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        mockSettingGetter := <span class="built_in">new</span>(MockSettingGetter)</span><br><span class="line">        mockSettingGetter.On(<span class="string">"Get"</span>, mock.Anything).Return([]<span class="keyword">byte</span>(test.v), test.err)</span><br><span class="line"></span><br><span class="line">        limiter := &amp;IPLimit&#123;SettingGetter: mockSettingGetter&#125;</span><br><span class="line">        err := limiter.UpdateThreshold()</span><br><span class="line">        <span class="keyword">if</span> test.hasErr &#123;</span><br><span class="line">            assert.Error(t, err, <span class="string">"row %d"</span>, idx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assert.NoError(t, err, <span class="string">"row %d"</span>, idx)</span><br><span class="line">        &#125;</span><br><span class="line">        assert.Equal(t, test.rs, limiter.Threshold, <span class="string">"thredshold should equal, row %d"</span>, idx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="suite"><a href="#suite" class="headerlink" title="suite"></a>suite</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic imports</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">    <span class="string">"github.com/stretchr/testify/suite"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the suite, and absorb the built-in basic suite</span></span><br><span class="line"><span class="comment">// functionality from testify - including a T() method which</span></span><br><span class="line"><span class="comment">// returns the current testing context</span></span><br><span class="line"><span class="keyword">type</span> ExampleTestSuite <span class="keyword">struct</span> &#123;</span><br><span class="line">    suite.Suite</span><br><span class="line">    VariableThatShouldStartAtFive <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure that VariableThatShouldStartAtFive is set to five</span></span><br><span class="line"><span class="comment">// before each test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span> <span class="title">SetupTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    suite.VariableThatShouldStartAtFive = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All methods that begin with "Test" are run as tests within a</span></span><br><span class="line"><span class="comment">// suite.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span> <span class="title">TestExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    assert.Equal(suite.T(), <span class="number">5</span>, suite.VariableThatShouldStartAtFive)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In order for 'go test' to run this suite, we need to create</span></span><br><span class="line"><span class="comment">// a normal test function and pass our suite to suite.Run</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExampleTestSuite</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    suite.Run(t, <span class="built_in">new</span>(ExampleTestSuite))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(22)--goland远程调试</title>
      <link href="2020/08/25/remote/"/>
      <url>2020/08/25/remote/</url>
      
        <content type="html"><![CDATA[<p>很多时候需要在服务器上进行调试，<code>goland</code>配合<code>golang</code>的<code>debug</code>工具<code>dlv</code>可以非常容易的实现远程开发调试。</p><a id="more"></a><h2 id="1-配置sftp"><a href="#1-配置sftp" class="headerlink" title="1.配置sftp"></a>1.配置sftp</h2><h3 id="首先我们需要实现代码的实时同步。"><a href="#首先我们需要实现代码的实时同步。" class="headerlink" title="首先我们需要实现代码的实时同步。"></a>首先我们需要实现代码的实时同步。</h3><p>Goland菜单: Tools -&gt; Deployment -&gt; Configuration</p><p><img src="/2020/08/25/remote/deployment.png" alt="deployment"></p><h3 id="配置本地目录与远端的映射"><a href="#配置本地目录与远端的映射" class="headerlink" title="配置本地目录与远端的映射"></a>配置本地目录与远端的映射</h3><p>配置目录映射也非常简单</p><p><img src="/2020/08/25/remote/mapping.jpg" alt="mapping"></p><h3 id="开启自动同步"><a href="#开启自动同步" class="headerlink" title="开启自动同步"></a>开启自动同步</h3><p>开启自动同步后，<code>goland</code>会在<code>save</code>的时候自动同步远端</p><p><img src="/2020/08/25/remote/auto.png" alt="auto"></p><h2 id="2-服务端安装Delve"><a href="#2-服务端安装Delve" class="headerlink" title="2.服务端安装Delve"></a>2.服务端安装Delve</h2><p>注意需要确保执行命令的目录并非一个<code>go module</code>的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>dlv</code>查看结果</p><p><img src="/2020/08/25/remote/dlv.png" alt="dlv"></p><p>如果提示找不到此命令，则需要把<code>$GOPATH\bin</code>添加到<code>$PATH</code></p><h2 id="4-build-and-dlv"><a href="#4-build-and-dlv" class="headerlink" title="4.build and dlv"></a>4.build and dlv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">go build main.go </span><br><span class="line"></span><br><span class="line"># 调试</span><br><span class="line">dlv --listen&#x3D;:2345 --headless&#x3D;true --api-version&#x3D;2 exec .&#x2F;main</span><br></pre></td></tr></table></figure><p><img src="/2020/08/25/remote/demo.png" alt="demo"></p><h2 id="5-goland-debug"><a href="#5-goland-debug" class="headerlink" title="5.goland debug"></a>5.goland debug</h2><p>Run -&gt; Edit Configurations -&gt; 点击左上角+号 -&gt; Go Remote </p><p><img src="/2020/08/25/remote/debug.png" alt="debug"></p><p>配置服务器的ip及端口，然后就能收到调试信息了</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(21)--golang服务热更新</title>
      <link href="2020/08/19/hotload/"/>
      <url>2020/08/19/hotload/</url>
      
        <content type="html"><![CDATA[<p>线上服务经常需要更新，通常的做法是，通过前端的负载均衡（如nginx）来保证升级时至少有一个服务可用，依次（灰度）升级。<br>如果用到了k8s，则是先创建一个新的pod，待新pod启动成功后关闭旧的pod。这两种方式都会带来一个很短暂服务不可用。<br>还有一种更方便的方法是在应用上做热重启，直接更新源码、配置或升级应用而不停服务，这样便可提升服务可用性以及用户体验。</p><a id="more"></a><h2 id="热重启原理"><a href="#热重启原理" class="headerlink" title="热重启原理"></a>热重启原理</h2><p><code>nginx reload</code>采取的就是进程热更新的模式进行升级。<br>热重启的原理比较简单，但是涉及到一些系统调用以及父子进程之间文件句柄的传递等等细节比较多。<br>处理过程分为以下几个步骤：</p><ol><li>监听信号（USR2..）</li><li>收到信号时fork子进程（使用相同的启动命令），将服务监听的socket文件描述符传递给子进程</li><li>子进程监听父进程的socket，这个时候父进程和子进程都可以接收请求</li><li>子进程启动成功之后，父进程停止接收新的连接，等待旧连接处理完成（或超时）</li><li>父进程退出，重启完成</li></ol><h2 id="golang热更新"><a href="#golang热更新" class="headerlink" title="golang热更新"></a>golang热更新</h2><p>server.Shutdown() 优雅关闭是go 1.8的特性。</p><blockquote><p>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context’s error, otherwise it returns any error returned from closing the Server’s underlying Listener(s).</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line"></span><br><span class="line">idleConnsClosed := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">sigint := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(sigint, os.Interrupt)</span><br><span class="line">&lt;-sigint</span><br><span class="line"></span><br><span class="line"><span class="comment">// We received an interrupt signal, shut down.</span></span><br><span class="line"><span class="keyword">if</span> err := srv.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Error from closing listeners, or context timeout:</span></span><br><span class="line">log.Printf(<span class="string">"HTTP server Shutdown: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(idleConnsClosed)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.ListenAndServe(); err != http.ErrServerClosed &#123;</span><br><span class="line"><span class="comment">// Error starting or closing listener:</span></span><br><span class="line">log.Fatalf(<span class="string">"HTTP server ListenAndServe: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-idleConnsClosed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"net"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"syscall"</span></span><br><span class="line">   <span class="string">"os"</span></span><br><span class="line">   <span class="string">"os/signal"</span></span><br><span class="line">   <span class="string">"context"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"os/exec"</span></span><br><span class="line">   <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   listener net.Listener</span><br><span class="line">   err error</span><br><span class="line">   server http.Server</span><br><span class="line">   graceful =  flag.Bool(<span class="string">"g"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHandler <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MyHandler)</span><span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">"request start at "</span>, time.Now(),  r.URL.Path+<span class="string">"?"</span>+r.URL.RawQuery,  <span class="string">"request done at "</span>, time.Now(), <span class="string">"  pid:"</span>, os.Getpid())</span><br><span class="line">   time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">   w.Write([]<span class="keyword">byte</span>(<span class="string">"this is test response"</span>))</span><br><span class="line">   fmt.Println(<span class="string">"request done at "</span>, time.Now(), <span class="string">"  pid:"</span>, os.Getpid() )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   flag.Parse()</span><br><span class="line">   fmt.Println(<span class="string">"start-up at "</span> , time.Now(), *graceful)</span><br><span class="line">   <span class="keyword">if</span> *graceful &#123;</span><br><span class="line">      f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)</span><br><span class="line">      listener, err = net.FileListener(f)</span><br><span class="line">      fmt.Printf( <span class="string">"graceful-reborn  %v %v  %#v \n"</span>, f.Fd(), f.Name(), listener)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      listener, err = net.Listen(<span class="string">"tcp"</span>, <span class="string">":1111"</span>)</span><br><span class="line">      tcp,_ := listener.(*net.TCPListener)</span><br><span class="line">      fd,_ := tcp.File()</span><br><span class="line">      fmt.Printf( <span class="string">"first-boot  %v %v %#v \n "</span>, fd.Fd(),fd.Name(), listener)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   server := http.Server&#123;</span><br><span class="line">      Handler: &amp;MyHandler&#123;&#125;,</span><br><span class="line">      ReadTimeout: <span class="number">6</span> * time.Second,</span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(<span class="string">"Actual pid is %d\n"</span>, syscall.Getpid())</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(<span class="string">" listener: %v\n"</span>,   listener)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="comment">//不要阻塞主进程</span></span><br><span class="line">      err := server.Serve(listener)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//signals</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">      signal.Notify(ch, syscall.SIGHUP, syscall.SIGTERM)</span><br><span class="line">      <span class="keyword">for</span>&#123;<span class="comment">//阻塞主进程， 不停的监听系统信号</span></span><br><span class="line">         sig := &lt;- ch</span><br><span class="line">         log.Printf(<span class="string">"signal: %v"</span>, sig)</span><br><span class="line">         ctx, _ := context.WithTimeout(context.Background(), <span class="number">20</span>*time.Second)</span><br><span class="line">         <span class="keyword">switch</span> sig &#123;</span><br><span class="line">         <span class="keyword">case</span> syscall.SIGTERM, syscall.SIGHUP:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"signal cause reloading"</span>)</span><br><span class="line">            signal.Stop(ch)</span><br><span class="line">            &#123;<span class="comment">//fork new child process</span></span><br><span class="line">               tl, ok := listener.(*net.TCPListener)</span><br><span class="line">               <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                  fmt.Println(<span class="string">"listener is not tcp listener"</span>)</span><br><span class="line">                  <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               currentFD, err := tl.File()</span><br><span class="line">               <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                  fmt.Println(<span class="string">"acquiring listener file failed"</span>)</span><br><span class="line">                  <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               cmd := exec.Command(os.Args[<span class="number">0</span>], <span class="string">"-g"</span>)</span><br><span class="line">               cmd.ExtraFiles, cmd.Stdout,cmd.Stderr = []*os.File&#123;currentFD&#125; ,os.Stdout, os.Stderr</span><br><span class="line">               err = cmd.Start()</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                  fmt.Println(<span class="string">"cmd.Start fail: "</span>, err)</span><br><span class="line">                  <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               fmt.Println(<span class="string">"forked new pid : "</span>,cmd.Process.Pid)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server.Shutdown(ctx)</span><br><span class="line">            fmt.Println(<span class="string">"graceful shutdown at "</span>, time.Now())</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 <code>ab -v -k -c2 -n100 &#39;127.0.0.1:1111/aa/bb?c=d&#39;</code></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用prometheus对golang服务业务监测</title>
      <link href="2020/08/14/prometheus/"/>
      <url>2020/08/14/prometheus/</url>
      
        <content type="html"><![CDATA[<p>对服务器性能指标的监控很多时候无法真正感知到服务的运行状况，往往我们需要对业务指标进行监控。<br><code>Prometheus</code> 是一个开源的监测解决方案，原生的服务发现支持让它成为动态环境下进行服务监测的一个完美选择。<code>Prometheus</code> 支持从 AWS, Kubernetes, Consul 等 拉取服务 !<br>当使用 <code>Prometheus</code> 生成服务级别的指标时，有两个典型的方法：内嵌地运行在一个服务里并在 HTTP 服务器上开放一个 <code>/metrics</code> 路由，或者创建一个独立的http服务。</p><a id="more"></a><p><a href="https://github.com/prometheus/client_golang" target="_blank" rel="noopener">golang prometheus client</a> 提供了一个用 Golang 写成的健壮的插桩库，可以用来注册，收集和暴露服务的指标。</p><p>prometheus支持下面4种暴露指标。</p><h2 id="Counter-计数器"><a href="#Counter-计数器" class="headerlink" title="Counter (计数器)"></a>Counter (计数器)</h2><p><code>Counter</code>是一个只增不减的计数器，觉的监控指标，如 <code>http_requests_total</code>,<code>node_cpu</code>都是<code>Counter</code>类型的监控指标。<br>PromQL内置的聚合操作和函数可以让用户对这些数据进行进一步的分析：</p><p>如通过<code>rate()</code>函数获取<code>http</code>请求量的增长率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure><p>如需要查询访问量前10的<code>http</code>地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(10, http_requests_total)</span><br></pre></td></tr></table></figure><h2 id="Gauge-可增减的仪表盘"><a href="#Gauge-可增减的仪表盘" class="headerlink" title="Gauge (可增减的仪表盘)"></a>Gauge (可增减的仪表盘)</h2><p><code>Gauge</code>类型侧重于反应当前系统的状态，这类指标的样本数据可增可减。常见指标如：node_memory_MemFree（主机当前空闲的内容大小）、node_memory_MemAvailable（可用内存大小）都是Gauge类型的监控指标。</p><p>对于Gauge类型的监控指标，通过PromQL内置函数delta()可以获取样本在一段时间返回内的变化情况。例如，计算CPU温度在两个小时内的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host&#x3D;&quot;zeus&quot;&#125;[2h])</span><br></pre></td></tr></table></figure><h2 id="百分位数（quantile）"><a href="#百分位数（quantile）" class="headerlink" title="百分位数（quantile）"></a>百分位数（quantile）</h2><p><code>Prometheus</code>中称为<code>quantile</code>，其实叫<code>percentile</code>更准确。百分位数是指小于某个特定数值的采样点达到一定的百分比。例如，假设<code>0.9-quantile</code>的值为120，意思就是所有的采样值中，小于120的采样值的数量占总体采样值的90%。相应的，假设<code>0.5-quantile</code>的值为x，那么意思就是指小于x的采样值占总体的50%，所以<code>0.5-quantile</code>也指中值（<code>median</code>）。</p><p>相对于简单的平均值来说，百分位数更丰富，更能反应出真实的用户体验。常用的百分位数为<code>0.5-quantile</code>，<code>0.9-quantile</code>以及<code>0.99-quantile</code>。这也是<code>Prometheus</code>默认的设置。</p><h2 id="Histogram（分布图"><a href="#Histogram（分布图" class="headerlink" title="Histogram（分布图)"></a>Histogram（分布图)</h2><p>histogram是柱状图，在Prometheus系统中的查询语言中，有三种作用：</p><ul><li>对每个采样点进行统计（并不是一段时间的统计），打到各个桶(bucket)中</li><li>对每个采样点值累计和(sum)</li><li>对采样点的次数累计和(count)</li></ul><p>每定义一个Histogram类型的metrics，实际也会生成几个metrics</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metric := prometheus.NewHistogramVec(prometheus.HistogramOpts&#123;</span><br><span class="line">    Name: <span class="string">"http_request_duration_millisecond"</span>,</span><br><span class="line">    Help:  <span class="string">"http request durations in millisecond."</span>,</span><br><span class="line">    Buckets: []<span class="keyword">float64</span>,</span><br><span class="line">    &#125;, []<span class="keyword">string</span>&#123;<span class="string">"path"</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的Histogram会产生下面6类metrics。后面4个可以用于计算quantile值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http_request_duration_millisecond_count</span><br><span class="line">http_request_duration_millisecond_sum</span><br><span class="line">http_request_duration_millisecond_bucket</span><br><span class="line">http_request_duration_millisecond_bucket</span><br><span class="line">http_request_duration_millisecond_bucket</span><br><span class="line">http_request_duration_millisecond_bucket</span><br></pre></td></tr></table></figure><h2 id="Summary-摘要"><a href="#Summary-摘要" class="headerlink" title="Summary (摘要)"></a>Summary (摘要)</h2><p>每定义一个Summary类型的metrics，实际会生成几个metrics。</p><p>例如，下面的summary是用于监控http请求的响应时间</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">httpCallDurations = prometheus.NewSummaryVec(</span><br><span class="line">prometheus.SummaryOpts&#123;</span><br><span class="line">    Name:       “http_request_duration_millisecond<span class="string">",</span></span><br><span class="line"><span class="string">    Help:       “http request durations in millisecond."</span>,</span><br><span class="line">    Objectives: <span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">float64</span>,</span><br><span class="line">&#125;, []<span class="keyword">string</span>&#123;“path<span class="string">"&#125;)</span></span><br></pre></td></tr></table></figure><p>上面的<code>summary</code>实际上生成的是5类<code>metrics</code>，后面3个就是百分位数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http_request_duration_millisecond_count</span><br><span class="line">http_request_duration_millisecond_sum</span><br><span class="line">http_request_duration_millisecond</span><br><span class="line">http_request_duration_millisecond</span><br><span class="line">http_request_duration_millisecond</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(20)-benchmark</title>
      <link href="2020/05/24/go(20)-benchmark/"/>
      <url>2020/05/24/go(20)-benchmark/</url>
      
        <content type="html"><![CDATA[<p>go自带的benchmark是一个性能测试的利器，利用这个工具，开发者可以方便快捷地在测试一个函数在串行或并发环境下的基准表现。</p><a id="more"></a><h2 id="benchmark常用API"><a href="#benchmark常用API" class="headerlink" title="benchmark常用API"></a>benchmark常用API</h2><ul><li>b.StopTimer()</li><li>b.StartTimer()</li><li>b.ResetTimer()</li><li>b.Run(name string, f func(b *B))</li><li>b.RunParallel(body func(*PB))</li><li>b.ReportAllocs()</li><li>b.SetParallelism(p int)</li><li>b.SetBytes(n int64)</li><li>testing.Benchmark(f func(b *B)) BenchmarkResult</li></ul><h2 id="串行测试"><a href="#串行测试" class="headerlink" title="串行测试"></a>串行测试</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFoo</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">    dosomething()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFoo</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">dosomething()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(19)——Validator参数校验</title>
      <link href="2020/05/13/go(19)-validator/"/>
      <url>2020/05/13/go(19)-validator/</url>
      
        <content type="html"><![CDATA[<p>http服务中参数校验是非常重要的一环，<a href="https://github.com/go-playground/validator" target="_blank" rel="noopener">go-playground/validator</a>是golang非常好用的开源库，它通过给<code>struct</code>添加<code>tag</code>的方式，自动完成参数的校验。</p><a id="more"></a><p>通常在<code>golang</code>中我们会为每个请求声明一个<code>struct</code>，在<code>json</code>序列化过程中我们是添加<code>json</code>这个<code>tag</code>实现字段之间的映射。同样的，我们使用<code>validator</code>这个库只需要添加<code>validate</code>这个<code>tag</code>，使用预定义的类型即可自动完成<code>struct</code>上的参数校验。</p><p>下面是一个简单的示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  Age <span class="keyword">int</span> <span class="string">`validate:"required,max=60,min=18"`</span>  <span class="comment">// 18&lt;=age&lt;= 60</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`validate:"required"`</span>  <span class="comment">// 非空</span></span><br><span class="line">  ClassArr []<span class="keyword">string</span> <span class="string">`validate:"required,min=1" // 长度至少为1</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="常见内置标识"><a href="#常见内置标识" class="headerlink" title="常见内置标识"></a>常见内置标识</h2><p><code>validator</code>内置了一些标识</p><h3 id="required标识"><a href="#required标识" class="headerlink" title="required标识"></a>required标识</h3><blockquote><p>// 要求字段非空<br>Usage <code>required</code><br>// Field1或Field2存在时要求非空<br>Usage <code>required_with=Field1 Field2</code><br>// Filed1和Field2都存在时要求非空<br>Usage <code>required_with_all==Field1 Field2</code><br>// Field1或Field2不存在时要求非空<br>Usage <code>required_without=Field1 Field2</code><br>// Field1和Field2都不存在时要求非空<br>Usage <code>required_without_all=Field1 Field2</code></p></blockquote><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="Skip标识"><a href="#Skip标识" class="headerlink" title="Skip标识"></a>Skip标识</h3><blockquote><p>Usage <code>-</code></p></blockquote><h3 id="Or标识"><a href="#Or标识" class="headerlink" title="Or标识"></a>Or标识</h3><blockquote><p>Usage <code>|</code></p></blockquote><h3 id="omitempty标识"><a href="#omitempty标识" class="headerlink" title="omitempty标识"></a>omitempty标识</h3><p>允许字段不存在，此时如果字段不存在时不会进行校验，如果字段存在，<code>min</code>之类的校验会生效</p><blockquote><p>Usage <code>omitempty</code></p></blockquote><h3 id="Dive标识"><a href="#Dive标识" class="headerlink" title="Dive标识"></a>Dive标识</h3><p>这个字段会让<code>validator</code>校验<code>slice</code>或者<code>map</code>中的元素</p><blockquote><p>Usage <code>dive</code></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">  [][]<span class="keyword">string</span> with validation tag <span class="string">"gt=0,dive,len=1,dive,required"</span></span><br><span class="line">  <span class="comment">// gt=0 will be applied to []</span></span><br><span class="line">  <span class="comment">// len=1 will be applied to []string</span></span><br><span class="line">  <span class="comment">// required will be applied to string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h3><p>比较符号就只有以下这 6 种：</p><ul><li><code>eq</code> 等于</li><li><code>ne</code> 不等于</li><li><code>gt</code> 大于</li><li><code>gte</code> 大于等于</li><li><code>lt</code> 小于</li><li><code>lte</code> 小于等于</li></ul><h3 id="跨字段验证"><a href="#跨字段验证" class="headerlink" title="跨字段验证"></a>跨字段验证</h3><blockquote><p>Usage <code>eqfield=Field</code> 必须等于 Field 的值<br>Usage <code>nefield=Field</code> 必须不等于 Field 的值<br>Usage <code>gtfield=Field</code> 必须大于 Field 的值<br>Usage <code>eqcsfield=Other.Field</code> 必须等于 struct Other 中 Field 的值；</p></blockquote><h3 id="One-Of"><a href="#One-Of" class="headerlink" title="One Of"></a>One Of</h3><blockquote><p>Usage: oneof=5 7 9</p></blockquote><h3 id="Unique"><a href="#Unique" class="headerlink" title="Unique"></a>Unique</h3><blockquote><p>Usage: unique  // for arrays, slices, and maps<br>Usage: unique=field // for slices of structs</p></blockquote><h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><blockquote><p>Usage: contains=@ </p></blockquote><h3 id="Excludes"><a href="#Excludes" class="headerlink" title="Excludes"></a>Excludes</h3><blockquote><p>Usage: excludes=@<br>Usage: excludesall=!@#?</p></blockquote><h3 id="Starts-With"><a href="#Starts-With" class="headerlink" title="Starts With"></a>Starts With</h3><blockquote><p>Usage: startswith=hello</p></blockquote><h3 id="Ends-With"><a href="#Ends-With" class="headerlink" title="Ends With"></a>Ends With</h3><blockquote><p>Usage: endswith=hello</p></blockquote><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote><p>Usage: alpha  // ASCII alpha characters  only<br>Usage: numeric  // 数字<br>Usage: email   // email<br>Usage: file       // File Path<br>Usage: url      // must contain a schema eg: http://<br>Usage: ip<br>Usage: ipv4<br>Usage: ipv6<br>Usage: tcp_addr     </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc(1)--protobuf语法</title>
      <link href="2020/02/29/2020-02-29-grpc-1/"/>
      <url>2020/02/29/2020-02-29-grpc-1/</url>
      
        <content type="html"><![CDATA[<p>gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。<br>Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。</p><a id="more"></a><h2 id="protobuf介绍"><a href="#protobuf介绍" class="headerlink" title="protobuf介绍"></a>protobuf介绍</h2><p>Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。</p><p>Protocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p><p>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><h2 id="protobuf优点"><a href="#protobuf优点" class="headerlink" title="protobuf优点"></a>protobuf优点</h2><ul><li>足够简单</li><li>序列化后体积很小:消息大小只需要XML的1/10 ~ 1/3</li><li>解析速度快:解析速度比XML快20 ~ 100倍</li><li>多语言支持</li><li>更好的兼容性,Protobuf设计的一个原则就是要能够很好的支持向下或向上兼容</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>官方建议新项目采用proto3，主要介绍一下proto3的语法</p><p>下面是一个<code>hello world</code>的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F; 指定proto版本</span><br><span class="line"></span><br><span class="line">package hello; &#x2F;&#x2F; 指定默认包名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 Hello Service</span><br><span class="line">service Hello &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义SayHello方法</span><br><span class="line">    rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义请求值 HelloRequest </span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name &#x3D; 1;  &#x2F;&#x2F; 变量类型 + 变量名 &#x3D; 序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义返回值结构 HelloResponse</span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">    string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li>数字类型： double、float、int32、int64、uint32、uint64、sint32、sint64: 存储长度可变的浮点数、整数、无符号整数和有符号整数</li><li>存储固定大小的数字类型：fixed32、fixed64、sfixed32、sfixed64: 存储空间固定</li><li>布尔类型: bool</li><li>字符串: string</li><li>bytes: 字节数组</li><li>messageType: 消息类型</li><li>enumType:枚举类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">  &#x2F;&#x2F; allow_alias 允许字段编号重复</span><br><span class="line">  option allow_alias &#x3D; true;</span><br><span class="line">  UNKNOWN &#x3D; 0;</span><br><span class="line">  STARTED &#x3D; 1;</span><br><span class="line">  RUNNING &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="import其它proto文件"><a href="#import其它proto文件" class="headerlink" title="import其它proto文件"></a>import其它proto文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  &quot;other.proto&quot;;</span><br></pre></td></tr></table></figure><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p><code>package</code>定义包名，同名的<code>message</code>可以通过不同的<code>package</code>名进行区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package abc.hello;</span><br></pre></td></tr></table></figure><h2 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a>oneof</h2><p><code>oneof</code>可以实现最多允许一组字段中一个字段出现，它是支持设置零值。由于proto3无法判断字段是否设置值（未设置值的情况下会默认零值），可以通过<code>oneof</code>来判断字段是否设置值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package oneof;</span><br><span class="line">message OneofMessage &#123;</span><br><span class="line">    oneof oneof_msg &#123;</span><br><span class="line">      string name &#x3D; 4;</span><br><span class="line">      int64 value &#x3D; 9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message Student &#123;</span><br><span class="line">  required int32 age &#x3D; 1;</span><br><span class="line">  required string name &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Class &#123;</span><br><span class="line">  repeated Student student &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int64,string&gt; values &#x3D; 1;</span><br></pre></td></tr></table></figure><h2 id="Reserved"><a href="#Reserved" class="headerlink" title="Reserved"></a>Reserved</h2><p>Reserved可以用来指明此message不使用某些字段，也就是忽略这些字段。</p><p>可以通过字段编号范围或者字段名称指定保留的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reserved 1, 4 to 6;</span><br><span class="line">reserved &quot;field1&quot;, &quot;field2&quot;;</span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>any字段是protobuf内置的类型，通用类型, any字段是以bytes呈现序列化的消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">  repeated google.protobuf.Any details &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新消息类型"><a href="#更新消息类型" class="headerlink" title="更新消息类型"></a>更新消息类型</h2><p>有时候你不得不修改正在使用的proto文件，比如为类型增加一个字段，protobuf支持这种修改而不影响已有的服务，不过你需要遵循一定的规则：</p><ul><li>不要改变已有字段的字段编号</li><li>当你增加一个新的字段的时候，老系统序列化后的数据依然可以被你的新的格式所解析，只不过你需要处理新加字段的缺省值。 老系统也能解析你信息的值，新加字段只不过被丢弃了</li><li>字段也可以被移除，但是建议你Reserved这个字段，避免将来会使用这个字段</li><li>int32, uint32, int64, uint64 和 bool类型都是兼容的</li><li>sint32 和 sint64兼容，但是不和其它整数类型兼容</li><li>string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes的话</li><li>嵌入类型和bytes兼容，如果bytes包含一个消息的编码版本的话</li><li>fixed32和sfixed32, fixed64和sfixed64</li><li>enum和int32, uint32, int64, uint64格式兼容</li><li>把单一一个值改变成一个新的oneof类型的一个成员是安全和二进制兼容的。把一组字段变成一个新的oneof字段也是安全的，如果你确保这一组字段最多只会设置一个。把一个字段移动到一个已存在的oneof字段是不安全的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(18)--errors包</title>
      <link href="2020/02/27/2020-02-27-errors-go-18/"/>
      <url>2020/02/27/2020-02-27-errors-go-18/</url>
      
        <content type="html"><![CDATA[<p>golang错误处理一直以来争议都很大，<code>errors</code>包提供了很多功能大大增强了golang程序异常处理能力。</p><a id="more"></a><h2 id="New-amp-amp-Errorf"><a href="#New-amp-amp-Errorf" class="headerlink" title="New &amp;&amp; Errorf"></a>New &amp;&amp; Errorf</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error with the supplied message.</span></span><br><span class="line"><span class="comment">// New also records the stack trace at the point it was called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;fundamental&#123;</span><br><span class="line">msg:   message,</span><br><span class="line">stack: callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errorf formats according to a format specifier and returns the string</span></span><br><span class="line"><span class="comment">// as a value that satisfies error.</span></span><br><span class="line"><span class="comment">// Errorf also records the stack trace at the point it was called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;fundamental&#123;</span><br><span class="line">msg:   fmt.Sprintf(format, args...),</span><br><span class="line">stack: callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundamental is an error that has a message and a stack, but no caller.</span></span><br><span class="line"><span class="keyword">type</span> fundamental <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fundamental)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> f.msg &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %s,%v //功能一样，输出错误信息，不包含堆栈</span></span><br><span class="line"><span class="comment">// %q //输出的错误信息带引号，不包含堆栈</span></span><br><span class="line"><span class="comment">// %+v //输出错误信息和堆栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fundamental)</span> <span class="title">Format</span><span class="params">(s fmt.State, verb <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> verb &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line"><span class="keyword">if</span> s.Flag(<span class="string">'+'</span>) &#123;</span><br><span class="line">io.WriteString(s, f.msg)</span><br><span class="line">f.stack.Format(s, verb)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">io.WriteString(s, f.msg)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">fmt.Fprintf(s, <span class="string">"%q"</span>, f.msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fundamental</code>实现了<code>Formatter</code>接口，可以通过<code>fmt.Printf</code>打印堆栈信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorf</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"not enough arguments, expected at least 3, got %d"</span>, <span class="built_in">len</span>(args))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := TestErrorf([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>&#125;)</span><br><span class="line">    <span class="comment">// +v flag</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">not enough arguments, expected at least <span class="number">3</span>, got <span class="number">1</span></span><br><span class="line">main.TestErrorf</span><br><span class="line">        /Users/zs/projects/golang/simple/e.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">main.main</span><br><span class="line">        /Users/zs/projects/golang/simple/e.<span class="keyword">go</span>:<span class="number">16</span></span><br><span class="line">runtime.main</span><br><span class="line">        /usr/local/<span class="keyword">go</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">203</span></span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/<span class="keyword">go</span>/src/runtime/asm_amd64.s:<span class="number">1357</span></span><br></pre></td></tr></table></figure><h2 id="WithStack"><a href="#WithStack" class="headerlink" title="WithStack"></a>WithStack</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithStack annotates err with a stack trace at the point WithStack was called.</span></span><br><span class="line"><span class="comment">// If err is nil, WithStack returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">err,</span><br><span class="line">callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> withStack <span class="keyword">struct</span> &#123;</span><br><span class="line">error</span><br><span class="line">*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithMessage"><a href="#WithMessage" class="headerlink" title="WithMessage"></a>WithMessage</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> withMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">cause error</span><br><span class="line">msg   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *withMessage)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> w.msg + <span class="string">": "</span> + w.cause.Error() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *withMessage)</span> <span class="title">Cause</span><span class="params">()</span> <span class="title">error</span></span>  &#123; <span class="keyword">return</span> w.cause &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap provides compatibility for Go 1.13 error chains.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *withMessage)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.cause &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *withMessage)</span> <span class="title">Format</span><span class="params">(s fmt.State, verb <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> verb &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line"><span class="keyword">if</span> s.Flag(<span class="string">'+'</span>) &#123;</span><br><span class="line">fmt.Fprintf(s, <span class="string">"%+v\n"</span>, w.Cause())</span><br><span class="line">io.WriteString(s, w.msg)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>, <span class="string">'q'</span>:</span><br><span class="line">io.WriteString(s, w.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrap returns an error annotating err with a stack trace</span></span><br><span class="line"><span class="comment">// at the point Wrap is called, and the supplied message.</span></span><br><span class="line"><span class="comment">// If err is nil, Wrap returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   message,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">err,</span><br><span class="line">callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>参考B站毛剑大佬2019年GopherChina上的演讲，总结的golang异常处理最佳实践</p><ol><li>库内代码使用<code>pkg/errors</code>的<code>New/Errorf</code>返回错误(保留堆栈信息)</li><li>库内代码接受其它库的返回，直接透传(已经保留过了，直接返回)</li><li>和标准库/第三方库的交互，用<code>WithStack/Wrap</code>来携带上下文(不破坏，可能会重复保留堆栈)</li><li>把错误抛给调用者，而不是到处打日志</li><li>在顶部调用者或work goroutine统一打日志</li></ol><h2 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h2><p>errgroup 在 WaitGroup 的基础上实现子协程错误传递, 同时使用 context 控制协程的生命周期。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    group, _ := errgroup.WithContext(context.Background())</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        index := i</span><br><span class="line">        group.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"start to execute the %d gorouting\n"</span>, index)</span><br><span class="line">            time.Sleep(time.Duration(index) * time.Second)</span><br><span class="line">            <span class="keyword">if</span> index%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">"something has failed on grouting:%d"</span>, index)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"gorouting:%d end\n"</span>, index)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := group.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习笔记(1)——k8s安装</title>
      <link href="2020/02/01/2020-02-01-k8s-1/"/>
      <url>2020/02/01/2020-02-01-k8s-1/</url>
      
        <content type="html"><![CDATA[<p>k8s，即Kubernetes，是一个全新的基于容器技术的分布式架构解决方案。因为肺炎宅在家，这个春节总算能好好系统的学习一下k8s。</p><a id="more"></a><h2 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h2><p>首先需要关闭CentOS自带防火墙服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>然后安装etcd和k8s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y etcd kubernetes</span><br></pre></td></tr></table></figure><p>按顺序启所有的k8s相关服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start etcd</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start kube-proxy</span><br></pre></td></tr></table></figure><p>安装完成之后，可以查看下k8s版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl --version</span><br><span class="line"><span class="meta">#</span><span class="bash">output Kubernetes v1.5.2</span></span><br></pre></td></tr></table></figure><h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><ol><li><p>下载Docker for Mac App, <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>安装完毕后勾选Enable Kubernetes 及使用k8s作为默认的编排器</p></li></ol><p><img src="/2020/02/01/2020-02-01-k8s-1/mac%E9%85%8D%E7%BD%AEk8s.jpg" alt="k8s配置"></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> kubenates </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(17)--sort包</title>
      <link href="2020/01/27/2020-01-27-sort/"/>
      <url>2020/01/27/2020-01-27-sort/</url>
      
        <content type="html"><![CDATA[<p>golang中<code>sort</code>包提供了常用的排序功能，<code>sort</code>包中实现了３种基本的排序算法：插入排序．快排和堆排序。</p><a id="more"></a><h2 id="sort-Interface"><a href="#sort-Interface" class="headerlink" title="sort Interface"></a>sort Interface</h2><p>任何实现了 <code>sort.Interface</code> 的数据容器都可以调用<code>sort</code>包完成排序。</p><p><code>sort.Interface</code>定义如下，需要实现3个方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Len() <span class="keyword">int</span>  <span class="comment">// 容器长度</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>  <span class="comment">// 大小比较</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)  <span class="comment">// 元素交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通用排序函数 <code>sort.Sort</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">n := data.Len()</span><br><span class="line">quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h2><p>我们只需要对一个 <code>struct</code> 实现 <code>sort.Interface</code> 这个接口即可</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arr [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(*this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">(*this)[i], (*this)[j] = (*this)[j], (*this)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以第一个元素作升序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*this)[i][<span class="number">0</span>] &lt; (*this)[j][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := Arr([][]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>&#125;,</span><br><span class="line">&#123;<span class="number">21</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">sort.Sort(&amp;arr)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// [[0 11 33] [1 2 3] [21 6 8]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(16)——channel</title>
      <link href="2020/01/18/2020-01-18-channel/"/>
      <url>2020/01/18/2020-01-18-channel/</url>
      
        <content type="html"><![CDATA[<p><code>channel</code>是<code>golang</code>非常核心的数据结构，总结一下<code>channel</code>的用法。</p><a id="more"></a><h2 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带缓存的channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带缓存的channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只写channel</span></span><br><span class="line">c := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>最开始一直没想明白，只读channel怎么用，因为它只读，直接写数据会<code>panic</code>，<code>channel</code>里是可以直接转换类型，也可以通过函数转换<code>channel</code>类型</p><p>直接转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch1 :&#x3D; make(chan int)</span><br><span class="line">ch2 :&#x3D; (&lt;-chan int)(ch1) &#x2F;&#x2F; ch2就是一个单向的读取channel</span><br><span class="line">ch3 :&#x3D; chan&lt;- int(ch1) &#x2F;&#x2F; ch3 是一个单向的写入channel</span><br><span class="line">fmt.Println(ch1, ch2, ch3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; output</span><br><span class="line">&#x2F;&#x2F; 0xc0000b0000 0xc0000b0000 0xc0000b0000</span><br></pre></td></tr></table></figure><p>通过函数转换</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span> )</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> c <span class="comment">// 转换为只读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span></span><br><span class="line">b := send(a)  <span class="comment">// b为 &lt;-chan int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c := &lt;- b:</span><br><span class="line">fmt.Println(<span class="string">"c = "</span>, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// c =  1</span></span><br></pre></td></tr></table></figure><h2 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h2><p>判断一个channel是否关闭</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">if</span> v, ok := &lt;- c; ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"channel has been closed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// channel has been closed</span></span><br></pre></td></tr></table></figure><p>关闭或写入<code>closed</code>的<code>channel</code>, 都会引发<code>panic</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// close closed channel</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// panic: close of closed channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入closed channel</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></table></figure><p>读取<code>closed</code>的<code>channel</code>, 会一直读到零值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; make(chan int)</span><br><span class="line">close(c)</span><br><span class="line">for &#123;</span><br><span class="line">v :&#x3D; &lt;- c</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; output</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><code>for-range</code>语法可以用到通道上。<code>Range</code>循环会一直接收channel里面的数据，直到<code>channel</code>关闭。不同于<code>array/slice/map</code>上的<code>for-range</code>，<code>channel</code>的<code>for-range</code>只允许有一个变量。</p><p>注意<code>for-range</code>对应的channel不能是只写channe</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++ &#123;</span><br><span class="line">c&lt;- i</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="comment">// range 会读空channel</span></span><br><span class="line">    <span class="comment">// 如果 channel未close，会一直堵塞通道</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(v) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h3><p><code>select</code>多个通道都满足时，会随机选择一个执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">a &lt;- <span class="string">"a"</span></span><br><span class="line">b &lt;- <span class="string">"b"</span></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">string</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;- a:</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">case</span> v = &lt;- b:</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 多次几次 随机输出 "a"  or "b"</span></span><br></pre></td></tr></table></figure><h3 id="timeout-channel"><a href="#timeout-channel" class="headerlink" title="timeout channel"></a>timeout channel</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.NewTimer(time.Second).C:</span><br><span class="line">fmt.Println(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-c:</span><br><span class="line">fmt.Println(<span class="string">"get value"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// time out</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github加速</title>
      <link href="2020/01/12/github%E5%8A%A0%E9%80%9F/"/>
      <url>2020/01/12/github%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<p>国内访问GitHub的速度实在感人，经常clone不下来，push不上去，大大影响了程序员的工作效率。</p><h2 id="https-修改hosts"><a href="#https-修改hosts" class="headerlink" title="https 修改hosts"></a>https 修改hosts</h2><p>GitHub在国内访问速度慢的问题原因有很多，有很大一部分原因是是GitHub的CDN加速的域名遭到dns污染。<br>这个可以通过修改<code>hosts</code>文件解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vim &#x2F;etc&#x2F;hosts  </span><br><span class="line">&#x2F;&#x2F; add </span><br><span class="line">192.30.253.112 http:&#x2F;&#x2F;github.com</span><br><span class="line">151.101.184.133 http:&#x2F;&#x2F;assets-cdn.github.com</span><br><span class="line">151.101.185.194 http:&#x2F;&#x2F;github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><h2 id="ssh-设置代理-ssh-config"><a href="#ssh-设置代理-ssh-config" class="headerlink" title="ssh 设置代理 ~/.ssh/config"></a>ssh 设置代理 ~/.ssh/config</h2><p>当然，修改<code>hosts</code>只能提升<code>https</code>方式，我们通常是用公钥访问，走的是<code>ssh</code>协议，这样访问还是很慢。如果有梯子就可以提升<code>ssh</code>协议的访问速度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// vim ~/.ssh/config</span><br><span class="line">// add</span><br><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">ProxyCommand /usr/bin/nc -x 127.0.0.1:1080 %h %p  # 1080 是shdowsocks代理端口</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="2020/01/12/docker-command-2020-01-12/"/>
      <url>2020/01/12/docker-command-2020-01-12/</url>
      
        <content type="html"><![CDATA[<p>内容目录：<br>(1) 基本命令<br>(2) docker build<br>(2) docker-compose<br>(3) docker swarm</p><a id="more"></a><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker ps ( -a )</span><br><span class="line">docker info  # 查看整体信息</span><br><span class="line">docker images</span><br><span class="line">docker logs -f &lt;container-id&gt;  </span><br><span class="line">docekr exec -it &lt;container-id&gt; &lt;command&gt;  # 执行命令</span><br><span class="line">docker inspect &lt;container-id&gt; # 查看容器信息</span><br><span class="line">docker inspect nginx | grep -C 5 IPAddress</span><br><span class="line">docker inspect -f "&#123;&#123;range .Mounts&#125;&#125; &#123;&#123;println .Source .Destination&#125;&#125; &#123;&#123;end&#125;&#125;" &lt;container-id&gt; # 看看挂载</span><br><span class="line">docker inspect -f "&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;" &lt;container-id&gt; # 看看ip</span><br><span class="line">docker inspect --format='&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' $(docker ps -aq)  # 查看所有ip</span><br><span class="line">docker system prune # 清理stopped container和无效的镜像，network</span><br><span class="line">docker stats   # 查看资源</span><br><span class="line">docker top &lt;container-id&gt; # 查看ps信息</span><br><span class="line">docker cp helloworld:/test.txt ~/hello.txt</span><br><span class="line">docker diff xxx  # 查看容器变化</span><br><span class="line">docker rm $(docker stop $(docker ps -a -q)) # 删除所有容器</span><br></pre></td></tr></table></figure><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t xxx:tag</span><br><span class="line">docker run --name xxx -d xxx:tag # 运行</span><br><span class="line">docker commit xxx x:tag  ## 保存修改生成新image</span><br><span class="line">docker push</span><br><span class="line">docker pull</span><br><span class="line">docker save  xxx &gt; x.tar</span><br><span class="line">docker load &lt; x.tar</span><br></pre></td></tr></table></figure><h2 id="docker-network"><a href="#docker-network" class="headerlink" title="docker network"></a>docker network</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">    app_net:</span><br><span class="line">        driver: bridge</span><br><span class="line">        ipam:</span><br><span class="line">            driver: default</span><br><span class="line">            config:</span><br><span class="line">                - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">Compose和Docker兼容性：</span><br><span class="line">    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x</span><br><span class="line">    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本</span><br><span class="line"></span><br><span class="line">常用参数：</span><br><span class="line">    version           # 指定 compose 文件的版本</span><br><span class="line">    services          # 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span><br><span class="line"></span><br><span class="line">        build                 # 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span><br><span class="line">            context               # context: 指定 Dockerfile 文件所在的路径</span><br><span class="line">            dockerfile            # dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span><br><span class="line">            args                  # args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span><br><span class="line">            cache_from            # v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span><br><span class="line">            labels                # v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span><br><span class="line">            shm_size              # v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span><br><span class="line"></span><br><span class="line">        command               # 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span><br><span class="line"></span><br><span class="line">        configs               # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        cgroup_parent         # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        container_name        # 指定容器的名称 (等同于 docker run --name 的作用)</span><br><span class="line"></span><br><span class="line">        credential_spec       # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        deploy                # v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span><br><span class="line">            endpoint_mode         # v3.3 版本中新增的功能, 指定服务暴露的方式</span><br><span class="line">                vip                   # Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span><br><span class="line">                dnsrr                 # DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span><br><span class="line">            labels                # 指定服务的标签，这些标签仅在服务上设置</span><br><span class="line">            mode                  # 指定 deploy 的模式</span><br><span class="line">                global                # 每个集群节点都只有一个容器</span><br><span class="line">                replicated            # 用户可以指定集群中容器的数量(默认)</span><br><span class="line">            placement             # 不知道怎么用</span><br><span class="line">            replicas              # deploy 的 mode 为 replicated 时, 指定容器副本的数量</span><br><span class="line">            resources             # 资源限制</span><br><span class="line">                limits                # 设置容器的资源限制</span><br><span class="line">                    cpus: "0.5"           # 设置该容器最多只能使用 50% 的 CPU </span><br><span class="line">                    memory: 50M           # 设置该容器最多只能使用 50M 的内存空间 </span><br><span class="line">                reservations          # 设置为容器预留的系统资源(随时可用)</span><br><span class="line">                    cpus: "0.2"           # 为该容器保留 20% 的 CPU</span><br><span class="line">                    memory: 20M           # 为该容器保留 20M 的内存空间</span><br><span class="line">            restart_policy        # 定义容器重启策略, 用于代替 restart 参数</span><br><span class="line">                condition             # 定义容器重启策略(接受三个参数)</span><br><span class="line">                    none                  # 不尝试重启</span><br><span class="line">                    on-failure            # 只有当容器内部应用程序出现问题才会重启</span><br><span class="line">                    any                   # 无论如何都会尝试重启(默认)</span><br><span class="line">                delay                 # 尝试重启的间隔时间(默认为 0s)</span><br><span class="line">                max_attempts          # 尝试重启次数(默认一直尝试重启)</span><br><span class="line">                window                # 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span><br><span class="line">            update_config         # 用于配置滚动更新配置</span><br><span class="line">                parallelism           # 一次性更新的容器数量</span><br><span class="line">                delay                 # 更新一组容器之间的间隔时间</span><br><span class="line">                failure_action        # 定义更新失败的策略</span><br><span class="line">                    continue              # 继续更新</span><br><span class="line">                    rollback              # 回滚更新</span><br><span class="line">                    pause                 # 暂停更新(默认)</span><br><span class="line">                monitor               # 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br><span class="line">                max_failure_ratio     # 回滚期间容忍的失败率(默认值为0)</span><br><span class="line">                order                 # v3.4 版本中新增的参数, 回滚期间的操作顺序</span><br><span class="line">                    stop-first            #旧任务在启动新任务之前停止(默认)</span><br><span class="line">                    start-first           #首先启动新任务, 并且正在运行的任务暂时重叠</span><br><span class="line">            rollback_config       # v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span><br><span class="line">                parallelism           # 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span><br><span class="line">                delay                 # 每个组回滚之间的时间间隔(默认为0)</span><br><span class="line">                failure_action        # 定义回滚失败的策略</span><br><span class="line">                    continue              # 继续回滚</span><br><span class="line">                    pause                 # 暂停回滚</span><br><span class="line">                monitor               # 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br><span class="line">                max_failure_ratio     # 回滚期间容忍的失败率(默认值0)</span><br><span class="line">                order                 # 回滚期间的操作顺序</span><br><span class="line">                    stop-first            # 旧任务在启动新任务之前停止(默认)</span><br><span class="line">                    start-first           # 首先启动新任务, 并且正在运行的任务暂时重叠</span><br><span class="line"></span><br><span class="line">            注意：</span><br><span class="line">                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项</span><br><span class="line">                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent</span><br><span class="line">                network_mode  external_links  restart  build  userns_mode  sysctls</span><br><span class="line"></span><br><span class="line">        devices               # 指定设备映射列表 (等同于 docker run --device 的作用)</span><br><span class="line"></span><br><span class="line">        depends_on            # 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span><br><span class="line">            示例：</span><br><span class="line">                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动</span><br><span class="line">                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系</span><br><span class="line">                version: '3'</span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        build: .</span><br><span class="line">                        depends_on:</span><br><span class="line">                            - db      </span><br><span class="line">                            - redis  </span><br><span class="line">                    redis:</span><br><span class="line">                        image: redis</span><br><span class="line">                    db:</span><br><span class="line">                        image: postgres                             </span><br><span class="line"></span><br><span class="line">        dns                   # 设置 DNS 地址(等同于 docker run --dns 的作用)</span><br><span class="line"></span><br><span class="line">        dns_search            # 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span><br><span class="line"></span><br><span class="line">        tmpfs                 # v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        entrypoint            # 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span><br><span class="line"></span><br><span class="line">        env_file              # 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span><br><span class="line">            文件格式：</span><br><span class="line">                RACK_ENV=development </span><br><span class="line"></span><br><span class="line">        environment           # 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span><br><span class="line"></span><br><span class="line">        expose                # 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span><br><span class="line"></span><br><span class="line">        external_links        # 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        extra_hosts           # 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span><br><span class="line"></span><br><span class="line">        healthcheck           # v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span><br><span class="line">            test                  # 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span><br><span class="line">                NONE                  # 禁用容器的健康状态检测</span><br><span class="line">                CMD                   # test: ["CMD", "curl", "-f", "http://localhost"]</span><br><span class="line">                CMD-SHELL             # test: ["CMD-SHELL", "curl -f http://localhost || exit 1"] 或者　test: curl -f https://localhost || exit 1</span><br><span class="line">            interval: 1m30s       # 每次检查之间的间隔时间</span><br><span class="line">            timeout: 10s          # 运行命令的超时时间</span><br><span class="line">            retries: 3            # 重试次数</span><br><span class="line">            start_period: 40s     # v3.4 以上新增的选项, 定义容器启动时间间隔</span><br><span class="line">            disable: true         # true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span><br><span class="line"></span><br><span class="line">        image                 # 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span><br><span class="line"></span><br><span class="line">        init                  # v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span><br><span class="line"></span><br><span class="line">        isolation             # 隔离容器技术, 在 Linux 中仅支持 default 值</span><br><span class="line"></span><br><span class="line">        labels                # 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span><br><span class="line"></span><br><span class="line">        links                 # 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        logging               # 设置容器日志服务</span><br><span class="line">            driver                # 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span><br><span class="line">            options               # 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span><br><span class="line">                max-size              # 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span><br><span class="line">                max-file              # 日志文件保留的数量</span><br><span class="line"></span><br><span class="line">        network_mode          # 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span><br><span class="line"></span><br><span class="line">        networks              # 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span><br><span class="line">            aliases               # 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span><br><span class="line">            ipv4_address      # IP V4 格式</span><br><span class="line">            ipv6_address      # IP V6 格式</span><br><span class="line"></span><br><span class="line">            示例:</span><br><span class="line">                version: '3.7'</span><br><span class="line">                services: </span><br><span class="line">                    test: </span><br><span class="line">                        image: nginx:1.14-alpine</span><br><span class="line">                        container_name: mynginx</span><br><span class="line">                        command: ifconfig</span><br><span class="line">                        networks: </span><br><span class="line">                            app_net:                                # 调用下面 networks 定义的 app_net 网络</span><br><span class="line">                            ipv4_address: 172.16.238.10</span><br><span class="line">                networks:</span><br><span class="line">                    app_net:</span><br><span class="line">                        driver: bridge</span><br><span class="line">                        ipam:</span><br><span class="line">                            driver: default</span><br><span class="line">                            config:</span><br><span class="line">                                - subnet: 172.16.238.0/24</span><br><span class="line"></span><br><span class="line">        pid: 'host'           # 共享宿主机的 进程空间(PID)</span><br><span class="line"></span><br><span class="line">        ports                 # 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                - "3000"                            # 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span><br><span class="line">                - "3000-3005"                       # 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span><br><span class="line">                - "8000:8000"                       # 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span><br><span class="line">                - "9090-9091:8080-8081"</span><br><span class="line">                - "127.0.0.1:8001:8001"             # 指定映射宿主机的指定地址的</span><br><span class="line">                - "127.0.0.1:5000-5010:5000-5010"   </span><br><span class="line">                - "6060:6060/udp"                   # 指定协议</span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                ports:</span><br><span class="line">                    - target: 80                    # 容器端口</span><br><span class="line">                      published: 8080               # 宿主机端口</span><br><span class="line">                      protocol: tcp                 # 协议类型</span><br><span class="line">                      mode: host                    # host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span><br><span class="line"></span><br><span class="line">        secrets               # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        security_opt          # 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        stop_grace_period     # 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span><br><span class="line"></span><br><span class="line">        stop_signal           # 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        sysctls               # 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        ulimits               # 设置容器的 limit</span><br><span class="line"></span><br><span class="line">        userns_mode           # 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        volumes               # 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                volumes:</span><br><span class="line">                    - /var/lib/mysql                # 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span><br><span class="line">                    - /opt/data:/var/lib/mysql      # 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span><br><span class="line">                    - ./cache:/tmp/cache            # 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span><br><span class="line">                    - ~/configs:/etc/configs/:ro    # 映射容器宿主机的目录到容器中去, 权限只读</span><br><span class="line">                    - datavolume:/var/lib/mysql     # datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                version: "3.2"</span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        image: nginx:alpine</span><br><span class="line">                        ports:</span><br><span class="line">                            - "80:80"</span><br><span class="line">                        volumes:</span><br><span class="line">                            - type: volume                  # mount 的类型, 必须是 bind、volume 或 tmpfs</span><br><span class="line">                                source: mydata              # 宿主机目录</span><br><span class="line">                                target: /data               # 容器目录</span><br><span class="line">                                volume:                     # 配置额外的选项, 其 key 必须和 type 的值相同</span><br><span class="line">                                    nocopy: true                # volume 额外的选项, 在创建卷时禁用从容器复制数据</span><br><span class="line">                            - type: bind                    # volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span><br><span class="line">                                source: ./static</span><br><span class="line">                                target: /opt/app/static</span><br><span class="line">                                read_only: true             # 设置文件系统为只读文件系统</span><br><span class="line">                volumes:</span><br><span class="line">                    mydata:                                 # 定义在 volume, 可在所有服务中调用</span><br><span class="line"></span><br><span class="line">        restart               # 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span><br><span class="line">            no                    # 禁止自动重启容器(默认)</span><br><span class="line">            always                # 无论如何容器都会重启</span><br><span class="line">            on-failure            # 当出现 on-failure 报错时, 容器重新启动</span><br><span class="line"></span><br><span class="line">        其他选项：</span><br><span class="line">            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir</span><br><span class="line">            上面这些选项都只接受单个值和 docker run 的对应参数类似</span><br><span class="line"></span><br><span class="line">        对于值为时间的可接受的值：</span><br><span class="line">            2.5s</span><br><span class="line">            10s</span><br><span class="line">            1m30s</span><br><span class="line">            2h32m</span><br><span class="line">            5h34m56s</span><br><span class="line">            时间单位: us, ms, s, m， h</span><br><span class="line">        对于值为大小的可接受的值：</span><br><span class="line">            2b</span><br><span class="line">            1024kb</span><br><span class="line">            2048k</span><br><span class="line">            300m</span><br><span class="line">            1gb</span><br><span class="line">            单位: b, k, m, g 或者 kb, mb, gb</span><br><span class="line">    networks          # 定义 networks 信息</span><br><span class="line">        driver                # 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span><br><span class="line">            bridge                # Docker 默认使用 bridge 连接单个主机上的网络</span><br><span class="line">            overlay               # overlay 驱动程序创建一个跨多个节点命名的网络</span><br><span class="line">            host                  # 共享主机网络名称空间(等同于 docker run --net=host)</span><br><span class="line">            none                  # 等同于 docker run --net=none</span><br><span class="line">        driver_opts           # v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span><br><span class="line">        attachable            # driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span><br><span class="line">        ipam                  # 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span><br><span class="line">            driver                # IPAM 驱动程序, bridge 或者 default</span><br><span class="line">            config                # 配置项</span><br><span class="line">                subnet                # CIDR格式的子网，表示该网络的网段</span><br><span class="line">        external              # 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span><br><span class="line">        name                  # v3.5 以上版本, 为此网络设置名称</span><br><span class="line">文件格式示例：</span><br><span class="line">    version: "3"</span><br><span class="line">    services:</span><br><span class="line">      redis:</span><br><span class="line">        image: redis:alpine</span><br><span class="line">        ports:</span><br><span class="line">          - "6379"</span><br><span class="line">        networks:</span><br><span class="line">          - frontend</span><br><span class="line">        deploy:</span><br><span class="line">          replicas: 2</span><br><span class="line">          update_config:</span><br><span class="line">            parallelism: 2</span><br><span class="line">            delay: 10s</span><br><span class="line">          restart_policy:</span><br><span class="line">            condition: on-failure</span><br><span class="line">      db:</span><br><span class="line">        image: postgres:9.4</span><br><span class="line">        volumes:</span><br><span class="line">          - db-data:/var/lib/postgresql/data</span><br><span class="line">        networks:</span><br><span class="line">          - backend</span><br><span class="line">        deploy:</span><br><span class="line">          placement:</span><br><span class="line">            constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init  # 初始化node</span><br><span class="line">docker stack deploy -c docker-compose.yml &lt;stack-name&gt; # 创建stack</span><br><span class="line">docker stack rm &lt;stack-name&gt; # 删除</span><br><span class="line">docker service ls # 查看进程</span><br><span class="line">docker service logs -f &lt;service-id&gt; # 查看日志</span><br><span class="line">docker service update --force &lt;service-id&gt; # 强制更新</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从配置指南</title>
      <link href="2020/01/05/mysql%E4%B8%BB%E4%BB%8E-2020-01-05/"/>
      <url>2020/01/05/mysql%E4%B8%BB%E4%BB%8E-2020-01-05/</url>
      
        <content type="html"><![CDATA[<p>之前一直用的阿里云上的数据库，一直没动手配置过。现在因为是TO B的公司，私有化的场景比较多，记录一下配置过程。</p><a id="more"></a><ol><li>修改配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># master</span><br><span class="line"># 对本地的mysql客户端的配置</span><br><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line"># 对其他远程连接的mysql客户端的配置</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line"># 本地mysql服务的配置</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake &#x3D; FALSE</span><br><span class="line">character-set-server &#x3D; utf8mb4</span><br><span class="line">collation-server &#x3D; utf8mb4_unicode_ci</span><br><span class="line"></span><br><span class="line">#主数据库端ID号</span><br><span class="line">server_id &#x3D; 1</span><br><span class="line">#开启二进制日志</span><br><span class="line">log-bin &#x3D; mysql-bin</span><br><span class="line">#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可</span><br><span class="line">binlog-do-db &#x3D; rpa_license</span><br><span class="line">#将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中</span><br><span class="line">log-slave-updates</span><br><span class="line">#控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失)</span><br><span class="line">sync_binlog &#x3D; 1</span><br><span class="line">#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span><br><span class="line">auto_increment_offset &#x3D; 1</span><br><span class="line">#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span><br><span class="line">auto_increment_increment &#x3D; 1</span><br><span class="line">#二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除</span><br><span class="line">expire_logs_days &#x3D; 7</span><br><span class="line">#将函数复制到slave</span><br><span class="line">log_bin_trust_function_creators &#x3D; 1</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># slave</span><br><span class="line">server_id &#x3D; 2 # 必须与主库server_id不同</span><br><span class="line">log-bin &#x3D; mysql-bin</span><br><span class="line">log-slave-updates</span><br><span class="line">sync_binlog &#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作</span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 0</span><br><span class="line">#指定slave要复制哪个库</span><br><span class="line">replicate-do-db &#x3D; rpa_license</span><br><span class="line">#MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据</span><br><span class="line">slave-net-timeout &#x3D; 60</span><br><span class="line">log_bin_trust_function_creators &#x3D; 1</span><br></pre></td></tr></table></figure><ol start="2"><li><p>同步两数据库数据，主mysql执行下面的命令:<br><code>FLUSH TABLES WITH READ LOCK</code> 防止变更</p></li><li><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@’172.19.76.44’ IDENTIFIED BY ‘rpa’ WITH GRANT OPTION;</p></li></ol><ol start="4"><li><p>进主库执行  <code>show master status;</code>， 记录 <code>MASTER_LOG_FILE</code>与<code>MASTER_PORT</code></p></li><li><p>进从库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"></span><br><span class="line">CHANGE MASTER to MASTER_HOST&#x3D;&#39;172.19.76.45&#39;, MASTER_PORT&#x3D;3306, MASTER_USER&#x3D;&#39;root&#39;, MASTER_PASSWORD&#x3D;&#39;rpa&#39;, MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000002&#39;, MASTER_LOG_POS&#x3D;154;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li></ol><p>6.检查从库状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"># Slave_IO_Running   Slave_SQL_Running 必须为 true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(15)——类型转换</title>
      <link href="2020/01/02/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-2020-01-02/"/>
      <url>2020/01/02/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-2020-01-02/</url>
      
        <content type="html"><![CDATA[<p>Golang是强类型语言，不像python可以随便给一个变量赋任意类型的值。当然，我们也经常需要用到类型转换</p><a id="more"></a><h2 id="通用类型转换"><a href="#通用类型转换" class="headerlink" title="通用类型转换"></a>通用类型转换</h2><ul><li>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</li><li>类型转换是用来在不同但相互兼容的类型之间的相互转换的方式，所以，当类型不兼容的时候，是无法转换的</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 <span class="keyword">int</span> = <span class="number">7</span></span><br><span class="line">fmt.Printf(<span class="string">"%T-&gt;%v\n"</span>, var1, var1)</span><br><span class="line">var2 := <span class="keyword">float32</span>(var1)</span><br><span class="line">var3 := <span class="keyword">int64</span>(var1)</span><br><span class="line">    </span><br><span class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></span><br><span class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></span><br><span class="line">(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">(x)</span>        // <span class="title">function</span> <span class="title">signature</span> <span class="title">func</span><span class="params">()</span> <span class="title">x</span></span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(x)</span>      // <span class="title">x</span> <span class="title">is</span> <span class="title">converted</span> <span class="title">to</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span>)<span class="params">(x)</span>  // <span class="title">x</span> <span class="title">is</span> <span class="title">converted</span> <span class="title">to</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span><span class="params">(x)</span>    // <span class="title">x</span> <span class="title">is</span> <span class="title">converted</span> <span class="title">to</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span> <span class="params">(unambiguous)</span></span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><ul><li>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言</li><li>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言 如果系统检测到不匹配，会在运行时调用内置的panic，抛出异常</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"TT"</span></span><br><span class="line">    j, b := i.(<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%T-&gt;%d\n"</span>, j, j)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"类型不匹配"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h2><h3 id="字符串与整型互转"><a href="#字符串与整型互转" class="headerlink" title="字符串与整型互转"></a>字符串与整型互转</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to int</span></span><br><span class="line">i, err := strconv.Atoi(<span class="string">"-42"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// int to string</span></span><br><span class="line">s := strconv.Itoa(<span class="number">-42</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseInt ParseUint (s, base, bitSize)</span></span><br><span class="line"><span class="comment">// s：要转换的字符串</span></span><br><span class="line"><span class="comment">// base：进位制（2 进制到 36 进制）</span></span><br><span class="line"><span class="comment">// bitSize：指定整数类型（0:int、8:int8、16:int16、32:int32、64:int64）</span></span><br><span class="line">fmt.Println(strconv.ParseInt(<span class="string">"12345"</span>, <span class="number">10</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure><h3 id="布尔值转换"><a href="#布尔值转换" class="headerlink" title="布尔值转换"></a>布尔值转换</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strconv.ParseBool(<span class="string">"false"</span>)) <span class="comment">// false  // 转化为bool</span></span><br><span class="line">fmt.Println(strconv.FormatBool(<span class="number">0</span> &lt; <span class="number">1</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="符点数转换"><a href="#符点数转换" class="headerlink" title="符点数转换"></a>符点数转换</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="string">"3.14159265"</span></span><br><span class="line"><span class="keyword">if</span> s, err := strconv.ParseFloat(f, <span class="number">32</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(s) <span class="comment">// 3.1415927410125732</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float to string, int</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">"%f"</span>, <span class="number">123.456</span>) <span class="comment">// s == "123.456000"</span></span><br><span class="line">d := fmt.Sprintf(<span class="string">"%d"</span>, <span class="number">123</span>) <span class="comment">// s == 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// format float </span></span><br><span class="line"><span class="comment">// string to float</span></span><br><span class="line"><span class="comment">// f：要转换的浮点数</span></span><br><span class="line"><span class="comment">// fmt：格式标记（b、e、E、f、g、G）</span></span><br><span class="line"><span class="comment">// prec：精度（数字部分的长度，不包括指数部分）</span></span><br><span class="line"><span class="comment">// bitSize：指定浮点类型（32:float32、64:float64）</span></span><br><span class="line">f := <span class="number">100.12345678901234567890123456789</span></span><br><span class="line">fmt.Println(strconv.FormatFloat(f, <span class="string">'f'</span>, <span class="number">5</span>, <span class="number">32</span>))</span><br><span class="line"><span class="comment">// 100.12346  'f'表示小数位数</span></span><br><span class="line">fmt.Println(strconv.FormatFloat(f, <span class="string">'g'</span>, <span class="number">5</span>, <span class="number">32</span>))</span><br><span class="line"><span class="comment">// 100.12</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超实用压力测试工具</title>
      <link href="2019/12/30/ab%E6%B5%8B%E8%AF%95/"/>
      <url>2019/12/30/ab%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>ab全称为：ApacheBench，是Apache http性能测试工具，其设计意图是描绘当前所安装Apache的执行性能，当然，它也可以对其它类型的服务器进行压力测试。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>手动下载，进入apache官网 <a href="http://httpd.apache.org/" target="_blank" rel="noopener">http://httpd.apache.org/</a> 下载apache即可。</li><li>Linux命令行安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ubuntu</span><br><span class="line">sudo apt-get install apache2-utils</span><br><span class="line"></span><br><span class="line"># CentOS</span><br><span class="line">yum -y install httpd-tools</span><br><span class="line"></span><br><span class="line"># mac</span><br><span class="line">mac自带了ab</span><br></pre></td></tr></table></figure></li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>ab使用很简单，注意根目录的<code>url</code> 结尾必须是<code>/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c 并发数</span><br><span class="line">-n 请求总数</span><br><span class="line">ab -c 1000 -n 10000 https:&#x2F;&#x2F;baidu.com&#x2F;</span><br></pre></td></tr></table></figure><h2 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h2><p>ab输出结果指标比较多，一般关注吞吐率和平均等待时间即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Requests per second: 吞吐率</span><br><span class="line">Time per request： 平均等待时间</span><br><span class="line">Time per request: 服务器平均请求时间</span><br></pre></td></tr></table></figure><p><img src="/2019/12/30/ab%E6%B5%8B%E8%AF%95/ab%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA.jpg" alt="ab测试结题"></p><h2 id="ab添加请求头"><a href="#ab添加请求头" class="headerlink" title="ab添加请求头"></a>ab添加请求头</h2><p>-H 参数可以传多个header</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H &quot;clientId:test-client&quot; -H &quot;token:93e6acff-2ef9-4c85-9d0b-c9948a8ee93b&quot;</span><br></pre></td></tr></table></figure><h2 id="ab-POST-请求"><a href="#ab-POST-请求" class="headerlink" title="ab POST 请求"></a>ab POST 请求</h2><p>将请求体写入 <code>post.txt</code> 中<br>-p post body内容，内容需要与编码相符<br>-T 指明编码形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># urlencode 比如原data&#x3D;&#123;&quot;username&quot;:&quot;zs&quot;&#125;, postdata要进行urlencode加密</span><br><span class="line">ab -c 1000 -n 10000 -p post.txt -T application&#x2F;x-www-form-urlencoded https:&#x2F;&#x2F;baidu.com</span><br><span class="line"></span><br><span class="line"># json postdata &#123;&quot;username&quot;:&quot;zs&quot;&#125;</span><br><span class="line">ab -c 1000 -n 10000 -p post.txt -T application&#x2F;json https:&#x2F;&#x2F;baidu.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># form-data  boundary可以自定义，但必须与post data匹配</span><br><span class="line"># ------ceshi\r\nContent-Disposition: form-data; name&#x3D;&quot;accountEmail&quot;\r\n\r\njiaowei@datagrand.com\r\n------WebKitFormBoundaryT5vjZWundP38bTD3\r\nContent-Disposition: form-data;     name&#x3D;&quot;password&quot;\r\n\r\njiaowei\r\n------ceshi--</span><br><span class="line">ab -n 10000 -c 1000 -p post.txt -T &#39;multipart&#x2F;form-data; boundary&#x3D;---ceshi&#39; &quot;http:&#x2F;&#x2F;rpa-v5.datagrand.com&#x2F;token?_allow_anonymous&#x3D;true&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(14)——定时器</title>
      <link href="2019/12/27/%E5%AE%9A%E6%97%B6%E5%99%A8-2019-12-27/"/>
      <url>2019/12/27/%E5%AE%9A%E6%97%B6%E5%99%A8-2019-12-27/</url>
      
        <content type="html"><![CDATA[<p>绝对时间一定不会是完全准确的，它对于一个运行中的分布式系统其实没有太多指导意义，但是由于相对时间的计算不依赖于外部的系统，所以它的计算可以做的比较准确。因此定时器对于一个程序非常重要，研究一下<code>Golang</code>里相对时间的定时器的实现原理也非常必要。</p><a id="more"></a><h2 id="Timer数据结构"><a href="#Timer数据结构" class="headerlink" title="Timer数据结构"></a>Timer数据结构</h2><p><code>timer</code> 就是 <code>Golang</code> 定时器的内部表示，每一个 <code>timer</code> 其实都存储在堆中，<code>tb</code> 就是用于存储当前定时器的桶，而 <code>i</code> 是当前定时器在堆中的索引，我们可以通过这两个变量找到当前定时器在堆中的位置：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">tb *timersBucket</span><br><span class="line">i  <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">when   <span class="keyword">int64</span></span><br><span class="line">period <span class="keyword">int64</span></span><br><span class="line">f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>when</code> 表示当前定时器（Timer）被唤醒的时间，而 <code>period</code> 表示两次被唤醒的间隔，每当定时器被唤醒时都会调用 <code>f(args, now)</code> 函数并传入 <code>args</code> 和当前时间作为参数。然而这里的 <code>timer</code> 作为一个私有结构体其实只是定时器的运行时表示，<code>time</code> 包对外暴露的定时器使用了如下所示的结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Timer</code> 定时器必须通过 <code>NewTimer</code> 或者 <code>AfterFunc</code> 函数进行创建，其中的 <code>runtimeTimer</code> 其实就是上面介绍的 <code>timer</code> 结构体，当定时器失效时，失效的时间就会被发送给当前定时器持有的 <code>Channel C</code>，订阅管道中消息的 <code>Goroutine</code> 就会收到当前定时器失效的时间。</p><p>在 <code>time</code> 包中，除了 <code>timer</code> 和 <code>Timer</code> 两个分别用于表示运行时定时器和对外暴露的 API 之外，timersBucket 这个用于存储定时器的结构体也非常重要，它会存储一个处理器上的全部定时器，不过如果当前机器的核数超过了 64 核，也就是机器上的处理器 P 的个数超过了 64 个，多个处理器上的定时器就可能存储在同一个桶中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timersBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">lock         mutex</span><br><span class="line">gp           *g</span><br><span class="line">created      <span class="keyword">bool</span></span><br><span class="line">sleeping     <span class="keyword">bool</span></span><br><span class="line">rescheduling <span class="keyword">bool</span></span><br><span class="line">sleepUntil   <span class="keyword">int64</span></span><br><span class="line">waitnote     note</span><br><span class="line">t            []*timer  <span class="comment">// 存储定时器，最小堆，最上面的元素就是最近需要唤醒的定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">t := &amp;Timer&#123;</span><br><span class="line">C: c,</span><br><span class="line">r: runtimeTimer&#123;</span><br><span class="line">when: when(d),</span><br><span class="line">f:    sendTime,</span><br><span class="line">arg:  c,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">startTimer(&amp;t.r)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定时器到期时调用传入的func</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span></span> &#123;</span><br><span class="line">t := &amp;Timer&#123;</span><br><span class="line">r: runtimeTimer&#123;</span><br><span class="line">when: when(d),</span><br><span class="line">f:    goFunc,</span><br><span class="line">arg:  f,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">startTimer(&amp;t.r)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startTimer 基本上就是创建定时器的入口了，所有定时器的创建和重启基本上都需要调用该函数：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">addtimer(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">tb := t.assignBucket()</span><br><span class="line">tb.addtimerLocked(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleep</span><span class="params">(ns <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ns &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp := getg()</span><br><span class="line">t := gp.timer</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">t = <span class="built_in">new</span>(timer)</span><br><span class="line">gp.timer = t</span><br><span class="line">&#125;</span><br><span class="line">*t = timer&#123;&#125;</span><br><span class="line">t.when = nanotime() + ns</span><br><span class="line">t.f = goroutineReady</span><br><span class="line">t.arg = gp</span><br><span class="line">tb := t.assignBucket()</span><br><span class="line">lock(&amp;tb.lock)</span><br><span class="line"><span class="keyword">if</span> !tb.addtimerLocked(t) &#123;</span><br><span class="line">unlock(&amp;tb.lock)</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">goparkunlock(&amp;tb.lock, waitReasonSleep, traceEvGoSleep, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeSleep 会创建一个新的 timer 结构体，在初始化的过程中我们会传入当前 Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数 goroutineReady，</span></span><br><span class="line"><span class="comment">// 随后会调用 goparkunlock 将当前 Goroutine 陷入休眠状态，当定时器到期时也会调用 goroutineReady 方法唤醒当前的 Goroutine：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineReady</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">goready(arg.(*g), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h2><p>除了只用于一次的定时器（Timer）之外，Go 语言的 time 包中还提供了用于多次通知的 Ticker 计时器，计时器中包含了一个用于接受通知的 Channel 和一个定时器，这两个字段共同组成了用于连续多次触发事件的计时器：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">C &lt;-<span class="keyword">chan</span> Time <span class="comment">// The channel on which the ticks are delivered.</span></span><br><span class="line">r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个计时器</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errors.New(<span class="string">"non-positive interval for NewTicker"</span>))</span><br><span class="line">&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">t := &amp;Ticker&#123;</span><br><span class="line">C: c,</span><br><span class="line">r: runtimeTimer&#123;</span><br><span class="line">when:   when(d),</span><br><span class="line">period: <span class="keyword">int64</span>(d),</span><br><span class="line">f:      sendTime,</span><br><span class="line">arg:    c,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">startTimer(&amp;t.r)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是每一个 NewTicker 方法开启的计时器都需要在不需要使用时调用 Stop 进行关闭，如果不显示调用 Stop 方法，创建的计时器就没有办法被垃圾回收，而通过 Tick 创建的计时器由于只对外提供了 Channel，所以是一定没有办法关闭的，我们一定要谨慎使用这一接口创建计时器。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(13)——反射</title>
      <link href="2019/12/22/%E5%8F%8D%E5%B0%84-2019-12-22/"/>
      <url>2019/12/22/%E5%8F%8D%E5%B0%84-2019-12-22/</url>
      
        <content type="html"><![CDATA[<p>反射是 <code>Go</code> 语言比较重要的一个特性之一，虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 <code>Go</code> 语言的反射机制实现一些动态的功能。作为一门静态语言，<code>Golang</code> 在设计上都非常简洁，所以在语法上其实并没有较强的表达能力，但是 <code>Go</code> 语言为我们提供的 <code>reflect</code> 包提供的动态特性却能够弥补它在语法上的一些劣势。</p><a id="more"></a><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>类型 <code>Type</code> 是 <code>Golang</code> 反射包中定义的一个接口，我们可以使用 <code>TypeOf</code> 函数获取任意值的变量的的类型，我们能从这个接口中看到非常多有趣的方法，<code>MethodByName</code> 可以获取当前类型对应方法的引用、<code>Implements</code> 可以判断当前类型是否实现了某个接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">        Align() <span class="keyword">int</span></span><br><span class="line">        FieldAlign() <span class="keyword">int</span></span><br><span class="line">        Method(<span class="keyword">int</span>) Method</span><br><span class="line">        MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line">        NumMethod() <span class="keyword">int</span></span><br><span class="line">        Name() <span class="keyword">string</span></span><br><span class="line">        PkgPath() <span class="keyword">string</span></span><br><span class="line">        Size() <span class="keyword">uintptr</span></span><br><span class="line">        String() <span class="keyword">string</span></span><br><span class="line">        Kind() Kind</span><br><span class="line">        Implements(u Type) <span class="keyword">bool</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>反射包中 <code>Value</code> 的类型却与 <code>Type</code> 不同，<code>Type</code> 是一个接口类型，但是 <code>Value</code> 在 <code>reflect</code> 包中的定义是一个结构体，这个结构体没有任何对外暴露的成员变量，但是却提供了很多方法让我们获取或者写入 Value 结构体中存储的数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Float</span><span class="params">()</span> <span class="title">float64</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="反射法则"><a href="#反射法则" class="headerlink" title="反射法则"></a>反射法则</h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式，它是 <code>元编程</code> 的一种，但是它带来的灵活性也是一把双刃剑，过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢，我们在这一节中就会介绍 <code>Go</code> 语言反射的三大法则，这能够帮助我们更好地理解反射的作用。</p><ol><li>从接口值可反射出反射对象；</li><li>从反射对象可反射出接口值；</li><li>要修改反射对象，其值必须可设置；</li></ol><h3 id="获得对象类型"><a href="#获得对象类型" class="headerlink" title="获得对象类型"></a>获得对象类型</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">author := <span class="string">"draven"</span></span><br><span class="line">fmt.Println(<span class="string">"TypeOf author:"</span>, reflect.TypeOf(author))</span><br><span class="line">fmt.Println(<span class="string">"ValueOf author:"</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// TypeOf author: string</span></span><br><span class="line"><span class="comment">// ValueOf author: draven</span></span><br></pre></td></tr></table></figure><h3 id="获得对象值"><a href="#获得对象值" class="headerlink" title="获得对象值"></a>获得对象值</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface&#123;&#125;.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h3><p><code>Go</code> 语言反射的最后一条法则是与值是否可以被更改相关的，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line">v.SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</span></span><br></pre></td></tr></table></figure><p>想要修改原有的变量我们只能通过如下所示的方法，首先通过 <code>reflect.ValueOf</code> 获取变量指针，然后通过 <code>Elem</code> 方法获取指针指向的变量并调用 <code>SetInt</code> 方法更新变量的值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;i)</span><br><span class="line">v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><h3 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h3><p><code>Golang</code> 的 <code>interface{}</code> 类型在语言内部都是通过 <code>emptyInterface</code> 这个结体来表示的，其中包含一个 <code>rtype</code> 字段用于表示变量的类型以及一个 <code>word</code> 字段指向内部封装的数据：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于获取变量类型的 <code>TypeOf</code> 函数就是将传入的 <code>i</code> 变量强制转换成 <code>emptyInterface</code> 类型并获取其中存储的类型信息 <code>rtype</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtype</code> 就是一个实现了 <code>Type</code> 接口的接口体，我们能在 <code>reflect</code> 包中找到如下所示的 <code>Name</code> 方法帮助我们获取当前类型的名称等信息：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := t.nameOff(t.str).name()</span><br><span class="line"><span class="keyword">if</span> t.tflag&amp;tflagExtraStar != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeOf</code> 函数的实现原理其实并不复杂，它只是将一个 <code>interface{}</code> 变量转换成了内部的 <code>emptyInterface</code> 表示，然后从中获取相应的类型信息。</p><p>用于获取接口值 <code>Value</code> 的函数 <code>ValueOf</code> 实现也非常简单，在该函数中我们先调用了 <code>escapes</code> 函数保证当前值逃逸到堆上，然后通过 <code>unpackEface</code> 方法从接口中获取 <code>Value</code> 结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">escapes(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">t := e.typ</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">f := flag(t.Kind())</span><br><span class="line"><span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">f |= flagIndir</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unpackEface</code> 函数会将传入的接口 <code>interface{}</code> 转换成 <code>emptyInterface</code> 结构体然后将其中表示接口值类型、指针以及值的类型包装成 <code>Value</code> 结构体并返回。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(12)——Context上下文</title>
      <link href="2019/12/19/context-2019-12-19/"/>
      <url>2019/12/19/context-2019-12-19/</url>
      
        <content type="html"><![CDATA[<p>context应该是golang中最有意思的设计了，它是实现golang并发编程的核心，了解它的使用才能真正的控制goroutine的并发。</p><a id="more"></a><p>Go中<code>HTTP</code>或<code>RPC</code> 请求的都会启动新的 <code>goroutine</code> 访问服务器、数据库和 RPC 服务，我们也可能会创建多个 Goroutine 来处理一次请求，而 <code>context</code> 的主要作用就是在不同的 <code>goroutine</code> 之间同步请求特定的数据、取消信号以及处理请求的<code>deadline</code>。</p><h2 id="Context数据结构"><a href="#Context数据结构" class="headerlink" title="Context数据结构"></a>Context数据结构</h2><p>context本质上是一个context包的接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><p>emptyCtx 实现了一个最简单的context接口，无论何时调用都会返回nil或者宿舍。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Background-and-TODO"><a href="#Background-and-TODO" class="headerlink" title="Background and TODO"></a>Background and TODO</h3><p>这两个都是emptyCtx的实例化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h3><p>WithCancel 方法能够从 Context 中创建出一个新的子上下文，同时还会返回用于取消该上下文的函数，也就是 CancelFunc，我们直接从 WithCancel 函数的实现来看它到底做了什么：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCancelCtx 是包中的私有方法，它将传入的父上下文包到私有结构体 cancelCtx{Context: parent} 中，cancelCtx 就是当前函数最终会返回的结构体类型，我们在详细了解它是如何实现接口之前，先来了解一下用于传递取消信号的 propagateCancel 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancelCtx 实现的几个接口方法其实没有太多值得介绍的地方，该结构体最重要的方法其实是 cancel 方法，这个方法会关闭上下文的管道并向所有的子上下文发送取消信号：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = closedchan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c.done)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h3><p>除了 WithCancel 之外，context 包中的另外两个函数 WithDeadline 和 WithTimeout 也都能创建可以被取消的上下文，WithTimeout 只是 context 包为我们提供的便利方法，能让我们更方便地创建 timerCtx：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h3><p>在最后我们需要了解一下如何使用上下文传值，context 包中的 WithValue 函数能从父上下文中创建一个子上下文，传值的子上下文使用私有结构体 valueCtx 类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueCtx 函数会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，只会处理 Value 方法的调用，然而每一个 valueCtx 内部也并没有存储一个键值对的哈希，而是只包含一个键值对：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然context传值功能非常少用，一般用于分布式追踪请求id。</p><p>常见的web框架，比如<code>gin</code>中的<code>Context</code>也是实现了<code>context</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context is the most important part of gin. It allows us to pass variables between middleware,</span></span><br><span class="line"><span class="comment">// manage the flow, validate the JSON of a request and render a JSON response for example.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">writermem responseWriter</span><br><span class="line">Request   *http.Request</span><br><span class="line">Writer    ResponseWriter</span><br><span class="line"></span><br><span class="line">Params   Params</span><br><span class="line">handlers HandlersChain</span><br><span class="line">index    <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line">engine *Engine</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys is a key/value pair exclusively for the context of each request.</span></span><br><span class="line">Keys <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errors is a list of errors attached to all the handlers/middlewares who used this context.</span></span><br><span class="line">Errors errorMsgs</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepted defines a list of manually accepted formats for content negotiation.</span></span><br><span class="line">Accepted []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch配置冷热分离</title>
      <link href="2019/12/13/2020-01-13-es%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/"/>
      <url>2019/12/13/2020-01-13-es%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>部署ES集群</li></ol><ol start="2"><li>修改节点配置：node.attr.box_type</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> elasticesearch.yml </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add</span></span><br><span class="line">node.attr.box_type: hot   # 热数据节点</span><br><span class="line">node.attr.box_type: cold  # 冷数据节点</span><br></pre></td></tr></table></figure><ol start="3"><li>定义索引模板<br>我们可以通过指定参数<code>&quot;routing.allocation.include.box_type&quot;: &quot;hot&quot;</code>，让所有符合命名规则索引的 <code>Shard</code> 都将被分配到 <code>Hot Nodes</code> 上：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 热索引</span></span><br><span class="line">PUT _template/active-logs</span><br><span class="line">&#123;</span><br><span class="line">  "template": "active-logs-*",</span><br><span class="line">  "settings": &#123;</span><br><span class="line">    "number_of_shards":   5,</span><br><span class="line">    "number_of_replicas": 1,</span><br><span class="line">    "routing.allocation.include.box_type": "hot",</span><br><span class="line">    "routing.allocation.total_shards_per_node": 2</span><br><span class="line">  &#125;,</span><br><span class="line">  "aliases": &#123;</span><br><span class="line">    "active-logs":  &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样符合命名规则索引的 Shard 会被分配到 Warm Nodes 上，我们指定了更少的 Shards 数量和复本数。</p><p>注意，这里的复本数为 0，和 best_compression 级别的压缩，方便做迁移等操作，以及进行一些数据的压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 冷索引</span></span><br><span class="line">PUT _template/inactive-logs</span><br><span class="line">&#123;</span><br><span class="line">  "template": "inactive-logs-*",</span><br><span class="line">  "settings": &#123;</span><br><span class="line">    "number_of_shards":   1,</span><br><span class="line">    "number_of_replicas": 0,</span><br><span class="line">    "routing.allocation.include.box_type": "code",</span><br><span class="line">    "codec": "best_compression"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置定时任务</li></ol><p>定时执行冷热数据切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">es="elasticsearch:9200" # es地址</span><br><span class="line">yesterday=`date -d '-1days' +%Y-%m-%d`  # 根据index时间格式来，一般一天一个index</span><br><span class="line">important_index="xxxxxx" # 多副本的index</span><br><span class="line">migration_index=$(curl -s -XGET "$&#123;es&#125;/_cat/indices/*-$&#123;yesterday&#125;?h=index"  | grep -v '^\.')</span><br><span class="line"><span class="meta">#</span><span class="bash"> replication_index=$(curl -s -XGET <span class="string">"<span class="variable">$&#123;es&#125;</span>/_cat/indices/*-<span class="variable">$&#123;yesterday&#125;</span>?h=index"</span>  | grep -v <span class="string">'^\.'</span> | grep -Ev <span class="variable">$&#123;important_index&#125;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> move hot to cold</span></span><br><span class="line">function migration_index_to_cold()&#123;</span><br><span class="line">   for i in `echo $1` </span><br><span class="line">   do</span><br><span class="line">     curl -X PUT "$&#123;es&#125;/$&#123;i&#125;/_settings" -H 'Content-Type: application/json' -d'&#123;</span><br><span class="line">        "index.routing.allocation.include.box_type": "cold",</span><br><span class="line">        "index.blocks.write": true</span><br><span class="line">     &#125;'</span><br><span class="line">   done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shrink  index</span></span><br><span class="line">function shrink_index()&#123;</span><br><span class="line">   for i in `echo $1` </span><br><span class="line">   do</span><br><span class="line">     curl -X PUT "$&#123;es&#125;/$&#123;i&#125;/_shrink/in$&#123;i&#125;" -H 'Content-Type: application/json' -d'&#123;</span><br><span class="line">        "number_of_shards": 1,</span><br><span class="line">        "number_of_shards": 0</span><br><span class="line">     &#125;'</span><br><span class="line">   done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> delete hot index</span></span><br><span class="line">function delete_index()&#123;</span><br><span class="line">   for i in `echo $1` </span><br><span class="line">   do</span><br><span class="line">     curl -X DELETE "$&#123;es&#125;/$&#123;i&#125;" </span><br><span class="line">   done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">migration_index_to_cold "$migration_index"</span><br><span class="line">shrink_index "$migration_index"</span><br><span class="line">delete_index "$migration_index"</span><br></pre></td></tr></table></figure><ol><li>讨论任务调度的方案设计</li><li>测试私有化部署任务调度的bug</li><li>修复导入dll的文件无法自动生成sdk文档的bug</li></ol>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(11)——并发</title>
      <link href="2019/12/12/%E5%B9%B6%E5%8F%91-2019012-12/"/>
      <url>2019/12/12/%E5%B9%B6%E5%8F%91-2019012-12/</url>
      
        <content type="html"><![CDATA[<p>golang并发很简单，实现方式也很多样。不同的实现方式都有哪些特点呢。</p><a id="more"></a><h2 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a>最简单的实现</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现很有可能<code>Hello World</code>并不会打印出来，因为main函数会退出。</p><h2 id="防止main函数退出"><a href="#防止main函数退出" class="headerlink" title="防止main函数退出"></a>防止main函数退出</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 撞大运</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环, 非常糟糕，for循环会独占线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用select阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    <span class="keyword">select</span>&#123;&#125; <span class="comment">// 阻塞, 不占用CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用channel阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 阻塞, 不占用CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种都会导致<code>fatal error: all goroutines are asleep - deadlock!</code>, 因为阻塞导致死锁异常。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">"你好, 并发!"</span>) <span class="comment">// 干活的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) &#125; () <span class="comment">// 滥竽充数的, Goroutine 泄露</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span>&#123;&#125; &#125; () <span class="comment">// 浪费资源的, 但不是 Goroutine 泄露</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125; () <span class="comment">// 滥竽充数的, 但不是 Goroutine 泄露</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完美的并发需要做好 goroutine 的善后工作<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 函数阻塞, 直到 done 管道有数据</span></span><br><span class="line"><span class="comment">// 当 done 管道有数据时, 后台 Goroutine 必然已经完成了打印工作</span></span><br><span class="line"><span class="comment">// Goroutine 何时退出并不关心, 重点是工作已经完成了</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h2><p>函数执行时，<code>i</code>的值并不确定</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出，多次运行，也可能打印出3，4等其它结果</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="同一个Goroutine内-满足顺序一致性内存模型"><a href="#同一个Goroutine内-满足顺序一致性内存模型" class="headerlink" title="同一个Goroutine内: 满足顺序一致性内存模型"></a>同一个Goroutine内: 满足顺序一致性内存模型</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    msg = <span class="string">"hello, world"</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> done &#123;</span><br><span class="line">            <span class="built_in">println</span>(msg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"retry..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同Goroutine之间-不满足顺序一致性"><a href="#不同Goroutine之间-不满足顺序一致性" class="headerlink" title="不同Goroutine之间: 不满足顺序一致性!"></a>不同Goroutine之间: 不满足顺序一致性!</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        msg = <span class="string">"hello, world"</span></span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> done &#123;</span><br><span class="line">            <span class="built_in">println</span>(msg); <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"retry..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main线程可能无法看到后台线程对msg和done做的更新</span></span><br><span class="line"><span class="comment">// msg 的修改不是原子操作, main可能看到被修改一半的数据</span></span><br><span class="line"><span class="comment">// 多线程环境, 程序结果未知</span></span><br></pre></td></tr></table></figure><h2 id="Goroutine特点"><a href="#Goroutine特点" class="headerlink" title="Goroutine特点"></a>Goroutine特点</h2><ul><li>由go关键字启动, 是一种轻量级的线程</li><li>以一个很小的栈启动(可能是2KB/4KB), 可以启动很多</li><li>Goroutine栈的大小会根据需要动态地伸缩, 不用担心栈溢出</li><li>m个goroutine运行在n个操作系统线程上, n默认对应CPU核数</li><li>runtime.GOMAXPROCS用于控制当前运行运行正常非阻塞Goroutine的系统线程数目</li><li>发生在用户态, 切换的代价要比系统线程低(切换时只需要保存必要的寄存器)</li><li>Goroutine采用的是半抢占式的协作调度(在函数入口处插入协作代码)</li><li>IO/sleep/runtime.Gosched 均会导致调度</li><li>runtime 无法强制剥夺纯计算型 Goroutine 的运行</li><li>Goroutine故意设计为没有ID</li></ul><h4 id="注意：Goroutine是一种资源，也有泄露的风险！"><a href="#注意：Goroutine是一种资源，也有泄露的风险！" class="headerlink" title="注意：Goroutine是一种资源，也有泄露的风险！"></a>注意：Goroutine是一种资源，也有泄露的风险！</h4>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(10)——线程安全map</title>
      <link href="2019/12/06/syncmap-2019-12-06/"/>
      <url>2019/12/06/syncmap-2019-12-06/</url>
      
        <content type="html"><![CDATA[<p>golang中goroutine中操作map是线程安全的吗？很明显不是的，并发操作会出现异常。</p><a id="more"></a><h2 id="并发安全测试"><a href="#并发安全测试" class="headerlink" title="并发安全测试"></a>并发安全测试</h2><p>我们写一个简单的demo程序，测试一下map并发安全性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Read()</span><br><span class="line"><span class="keyword">go</span> Write()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// fatal error: concurrent map read and map write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine 5 [running]:</span></span><br><span class="line"><span class="comment">// runtime.throw(0x10d4b60, 0x21)</span></span><br><span class="line"><span class="comment">//         /usr/local/Cellar/go/1.13/libexec/src/runtime/panic.go:774 +0x72 fp=0xc000048758 sp=0xc000048728 pc=0x10296b2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>很快程序就出现异常了。很明显map并发读写是不安全的。官方解释如下。</p><blockquote><p>After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized. Therefore requiring that all map operations grab a mutex would slow down most programs and add safety to few. This was not an easy decision, however, since it means uncontrolled map access can crash the program.</p></blockquote><p>这个异常是无法被recover的, 测试一下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Read()</span><br><span class="line"><span class="keyword">go</span> Write()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// fatal error: concurrent map read and map write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine 5 [running]:</span></span><br><span class="line"><span class="comment">// runtime.throw(0x10d4b60, 0x21)</span></span><br><span class="line"><span class="comment">//         /usr/local/Cellar/go/1.13/libexec/src/runtime/panic.go:774 +0x72 fp=0xc000048758 sp=0xc000048728 pc=0x10296b2</span></span><br></pre></td></tr></table></figure><p>从结果中我们可以看出<code>recover</code>函数未被执行。</p><h2 id="并发安全实现"><a href="#并发安全实现" class="headerlink" title="并发安全实现"></a>并发安全实现</h2><p>我们有两种方式可以解决这个问题</p><ol><li>加锁</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> m *SafeMap</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">M <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSafeMap</span><span class="params">()</span> *<span class="title">SafeMap</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;SafeMap&#123;</span><br><span class="line">M:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>),</span><br><span class="line">RWMutex: sync.RWMutex&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100000</span>; i++&#123;</span><br><span class="line">m.RLock()</span><br><span class="line">m.M[<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line">m.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"read done"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100000</span>; i++&#123;</span><br><span class="line">m.Lock()</span><br><span class="line">_ = m.M[<span class="number">1</span>]</span><br><span class="line">m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write done"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = NewSafeMap()</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">m.M[<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line"><span class="keyword">go</span> Read()</span><br><span class="line"><span class="keyword">go</span> Write()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// write done</span></span><br><span class="line"><span class="comment">// read done</span></span><br></pre></td></tr></table></figure><p>加锁实现很简单，当然性能上就不那么让人满意了。</p><ol start="2"><li>golang1.9引入的sync.Map</li></ol><p>因为想要借助 lock free 来提高访问效率，那么势必需要增加一些辅助的数据结构来支持 lock free 操作。<br>在 syncmap 中实际存在两个 map：read map &amp; dirty map。 可以看一下代码中的表示:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex  <span class="comment">// 锁</span></span><br><span class="line">    read atomic.Value <span class="comment">// readOnly，只读不用加锁</span></span><br><span class="line">    <span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，</span></span><br><span class="line">    <span class="comment">// 但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),</span></span><br><span class="line">    <span class="comment">// 有些数据还可能没有移动到read字段中。</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry  <span class="comment">// 操作需要加锁</span></span><br><span class="line">    <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></span><br><span class="line">    misses <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    amended <span class="keyword">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry相当于map中的value</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Map 实现上有以下特点</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现减少加锁对性能的影响。</li><li>使用只读数据(read)，避免读写冲突。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking。</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p>最后我们用 <code>sync.Map</code>实现一下并发读写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100000</span>; i++&#123;</span><br><span class="line">m.Store(<span class="number">1</span>, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"read done"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100000</span>; i++&#123;</span><br><span class="line">m.Load(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write done"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">m = sync.Map&#123;&#125;</span><br><span class="line">m.Store(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> Read()</span><br><span class="line"><span class="keyword">go</span> Write()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// write done</span></span><br><span class="line"><span class="comment">// read done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(9)——map源码阅读</title>
      <link href="2019/12/01/map-2019-12-01/"/>
      <url>2019/12/01/map-2019-12-01/</url>
      
        <content type="html"><![CDATA[<p>Go中的map在底层是用哈希表实现的，最典型的空间换时间的数据结构。研究一下它底层的实现。</p><a id="more"></a><h3 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h3><p>go1.13 map的定义在<code>runtime/map.go</code>中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler's definition.</span></span><br><span class="line">count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makemap implements Go map creation for make(map[k]v, hint).</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">hint = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize Hmap</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h = <span class="built_in">new</span>(hmap)</span><br><span class="line">&#125;</span><br><span class="line">h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B一定程度上表示的就是桶的数量</span></span><br><span class="line">    <span class="comment">// 当然不是说B是3桶的数量就是3，而是2的3次方，也就是8；当B为5，桶的数量就是32</span></span><br><span class="line">B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">B++</span><br><span class="line">&#125;</span><br><span class="line">    h.B = B</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapaccess1)</span><br><span class="line">racereadpc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">t.key.alg.hash(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"concurrent map read and map write"</span>)</span><br><span class="line">&#125;</span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0)) <span class="comment">// 计算key的hash值</span></span><br><span class="line">m := bucketMask(h.B) <span class="comment">// 通过B计算要取最后几位</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize))) <span class="comment">// 移动针对到对应桶的位置</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash) <span class="comment">// 取出key的前8位作为tophash</span></span><br><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line"><span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">e = *((*unsafe.Pointer)(e))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"assignment to entry in nil map"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapassign)</span><br><span class="line">racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line"><span class="comment">// in which case we have not actually done a write.</span></span><br><span class="line">h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">bucket := hash &amp; bucketMask(h.B)</span><br><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">top := tophash(hash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inserti *<span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line"><span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">inserti = &amp;b.tophash[i]</span><br><span class="line">insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// already have a mapping for key. Update it.</span></span><br><span class="line"><span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">typedmemmove(t.key, k, key)</span><br><span class="line">&#125;</span><br><span class="line">elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line"><span class="keyword">goto</span> done</span><br><span class="line">&#125;</span><br><span class="line">ovf := b.overflow(t)</span><br><span class="line"><span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">b = ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did not find mapping for key. Allocate new cell &amp; add entry.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we're not already in the middle of growing, start growing.</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line"><span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">newb := h.newoverflow(t, b)</span><br><span class="line">inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">elem = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store new key/elem at insert position</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">kmem := newobject(t.key)</span><br><span class="line">*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">insertk = kmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">vmem := newobject(t.elem)</span><br><span class="line">*(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(t.key, insertk, key)</span><br><span class="line">*inserti = top</span><br><span class="line">h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.flags &amp;^= hashWriting</span><br><span class="line"><span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h3><p>下面说一些扩容时的细节：</p><p>扩容不是一次性完成的，还记的我们hmap一开始有一个oldbuckets吗？是先将老数据存到这个里面<br>每次搬运1到2个bucket，当插入或修改、删除key触发<br>扩容之后肯定会影响到get和put，遍历的时候肯定会先从oldbuckets拿，put肯定也要考虑是否要放到新产生的桶里面去</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line"><span class="comment">// If we've hit the load factor, get bigger.</span></span><br><span class="line"><span class="comment">// Otherwise, there are too many overflow buckets,</span></span><br><span class="line"><span class="comment">// so keep the same number of buckets and "grow" laterally.</span></span><br><span class="line">bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">bigger = <span class="number">0</span></span><br><span class="line">h.flags |= sameSizeGrow</span><br><span class="line">&#125;</span><br><span class="line">oldbuckets := h.buckets</span><br><span class="line">newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">flags |= oldIterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// commit the grow (atomic wrt gc)</span></span><br><span class="line">h.B += bigger</span><br><span class="line">h.flags = flags</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line">h.nevacuate = <span class="number">0</span></span><br><span class="line">h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Promote current overflow buckets to the old generation.</span></span><br><span class="line"><span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"oldoverflow is not nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">&#125;</span><br><span class="line">h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the actual copying of the hash table data is done incrementally</span></span><br><span class="line"><span class="comment">// by growWork() and evacuate().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><p>map遍历是无序的，golang是通过随机数来决定从哪个元素开始</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapiterinit initializes the hiter struct used for ranging over maps.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机决定起始元素</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator state</span></span><br><span class="line">it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember we have an iterator.</span></span><br><span class="line"><span class="comment">// Can run concurrently with another mapiterinit().</span></span><br><span class="line"><span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    mapiternext(it)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang strings.TrimLeft的坑</title>
      <link href="2019/11/21/go-trim/"/>
      <url>2019/11/21/go-trim/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个偶尔出现的bug，查看代码却看不出来任何问题。经过反复查看日志后定位到问题出现在 <code>strings.TrimLeft</code>这个函数上。</p><a id="more"></a><p><code>TrimLeft</code>这个函数名称表面上是删除字符串左侧的字符，实际上却不是这样工作的。它的源码注释上也非常清楚的说明了这一点。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TrimLeft returns a slice of the string s with all leading</span></span><br><span class="line"><span class="comment">// Unicode code points contained in cutset removed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To remove a prefix, use TrimPrefix instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">""</span> || cutset == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TrimLeftFunc(s, makeCutsetFunc(cutset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文档所说，查看<code>strings.TrimPrefix</code>源码如下，这个函数功能才是真正需要的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TrimPrefix returns s without the provided leading prefix string.</span></span><br><span class="line"><span class="comment">// If s doesn't start with prefix, s is returned unchanged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> HasPrefix(s, prefix) &#123;</span><br><span class="line"><span class="keyword">return</span> s[<span class="built_in">len</span>(prefix):]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下来，还是单元测试覆盖不够，少量的测试用例下，两个函数表现完全一致，而实际是有本质差别的。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(8)——time.Time分析</title>
      <link href="2019/11/19/date-2019-11-19/"/>
      <url>2019/11/19/date-2019-11-19/</url>
      
        <content type="html"><![CDATA[<p>最近帮解服务上的bug，发现小兄弟在golang里用<code>int</code>用来表示时间, 思考了一下，用<code>int</code>表示时间戳似乎也没什么毛病。。但是，如果这样，golang又为何提供<code>time.Time</code>类型？</p><a id="more"></a><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><ol><li><code>time.Time</code>定义</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">wall <span class="keyword">uint64</span>   <span class="comment">//  表示从公元1年1月1日00:00:00UTC到要表示的整数秒数</span></span><br><span class="line">ext  <span class="keyword">int64</span>    <span class="comment">//  表示的纳秒数</span></span><br><span class="line">loc *Location  <span class="comment">// 时区，用于处理偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>time.Now()</code></li></ol><p>time.Now()默认使用本地时间, time.Local即本地时区, 取决于运行的系统环境设置, 优先取<code>TZ</code>这个环境变量, 然后取<code>/etc/localtime</code>, 如果这些都取不到就用<code>UTC</code>时间.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now returns the current local time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">sec, nsec, mono := now()</span><br><span class="line">mono -= startNano</span><br><span class="line">sec += unixToInternal - minWall</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(sec)&gt;&gt;<span class="number">33</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Time&#123;<span class="keyword">uint64</span>(nsec), sec + minWall, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Time&#123;hasMonotonic | <span class="keyword">uint64</span>(sec)&lt;&lt;nsecShift | <span class="keyword">uint64</span>(nsec), mono, Local&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unixToInternal</code>计算算法非常简洁</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secondsPerDay    = <span class="number">24</span> * secondsPerHour </span><br><span class="line"><span class="comment">// UNIX系统认为1970年1月1日0点时间纪元，需要计算1969年之前的总秒数</span></span><br><span class="line">unixToInternal <span class="keyword">int64</span> = (<span class="number">1969</span>*<span class="number">365</span> + <span class="number">1969</span>/<span class="number">4</span> - <span class="number">1969</span>/<span class="number">100</span> + <span class="number">1969</span>/<span class="number">400</span>) * secondsPerDay</span><br></pre></td></tr></table></figure><ol start="3"><li><p>时区<code>time.Location</code>定义</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Location maps time instants to the zone in use at that time.</span></span><br><span class="line"><span class="comment">// Typically, the Location represents the collection of time offsets</span></span><br><span class="line"><span class="comment">// in use in a geographical area, such as CEST and CET for central Europe.</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">zone []zone</span><br><span class="line">tx   []zoneTrans</span><br><span class="line"></span><br><span class="line"><span class="comment">// to lookup.</span></span><br><span class="line">cacheStart <span class="keyword">int64</span></span><br><span class="line">cacheEnd   <span class="keyword">int64</span></span><br><span class="line">    cacheZone  *zone</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A zone represents a single time zone such as CEST or CET.</span></span><br><span class="line"><span class="keyword">type</span> zone <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span> <span class="comment">// abbreviated name, "CET"</span></span><br><span class="line">offset <span class="keyword">int</span>    <span class="comment">// seconds east of UTC</span></span><br><span class="line">isDST  <span class="keyword">bool</span>   <span class="comment">// is this zone Daylight Savings Time?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A zoneTrans represents a single time zone transition.</span></span><br><span class="line"><span class="keyword">type</span> zoneTrans <span class="keyword">struct</span> &#123;</span><br><span class="line">when         <span class="keyword">int64</span> <span class="comment">// transition time, in seconds since 1970 GMT</span></span><br><span class="line">index        <span class="keyword">uint8</span> <span class="comment">// the index of the zone that goes into effect at that time</span></span><br><span class="line">isstd, isutc <span class="keyword">bool</span>  <span class="comment">// ignored - no idea what these mean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>time.Parse</code> 实现</p></li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_                        = <span class="literal">iota</span></span><br><span class="line">stdLongMonth             = <span class="literal">iota</span> + stdNeedDate  <span class="comment">// "January"</span></span><br><span class="line">stdMonth                                       <span class="comment">// "Jan"</span></span><br><span class="line">stdNumMonth                                    <span class="comment">// "1"</span></span><br><span class="line">stdZeroMonth                                   <span class="comment">// "01"</span></span><br><span class="line">stdLongWeekDay                                 <span class="comment">// "Monday"</span></span><br><span class="line">stdWeekDay                                     <span class="comment">// "Mon"</span></span><br><span class="line">stdDay                                         <span class="comment">// "2"</span></span><br><span class="line">stdUnderDay                                    <span class="comment">// "_2"</span></span><br><span class="line">stdZeroDay                                     <span class="comment">// "02"</span></span><br><span class="line">stdUnderYearDay                                <span class="comment">// "__2"</span></span><br><span class="line">stdZeroYearDay                                 <span class="comment">// "002"</span></span><br><span class="line">stdHour                  = <span class="literal">iota</span> + stdNeedClock <span class="comment">// "15"</span></span><br><span class="line">stdHour12                                      <span class="comment">// "3"</span></span><br><span class="line">stdZeroHour12                                  <span class="comment">// "03"</span></span><br><span class="line">stdMinute                                      <span class="comment">// "4"</span></span><br><span class="line">stdZeroMinute                                  <span class="comment">// "04"</span></span><br><span class="line">stdSecond                                      <span class="comment">// "5"</span></span><br><span class="line">stdZeroSecond                                  <span class="comment">// "05"</span></span><br><span class="line">stdLongYear              = <span class="literal">iota</span> + stdNeedDate  <span class="comment">// "2006"</span></span><br><span class="line">stdYear                                        <span class="comment">// "06"</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppendFormat is like Format but appends the textual</span></span><br><span class="line"><span class="comment">// representation to b and returns the extended buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AppendFormat</span><span class="params">(b []<span class="keyword">byte</span>, layout <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> std &amp; stdMask &#123;</span><br><span class="line"><span class="keyword">case</span> stdYear:</span><br><span class="line">y := year</span><br><span class="line"><span class="keyword">if</span> y &lt; <span class="number">0</span> &#123;</span><br><span class="line">y = -y</span><br><span class="line">&#125;</span><br><span class="line">b = appendInt(b, y%<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> stdLongYear:</span><br><span class="line">b = appendInt(b, year, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">case</span> stdMonth:</span><br><span class="line">b = <span class="built_in">append</span>(b, month.String()[:<span class="number">3</span>]...)</span><br><span class="line"><span class="keyword">case</span> stdLongMonth:</span><br><span class="line">m := month.String()</span><br><span class="line">b = <span class="built_in">append</span>(b, m...)</span><br><span class="line"><span class="keyword">case</span> stdNumMonth:</span><br><span class="line">            b = appendInt(b, <span class="keyword">int</span>(month), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>time.Time</code>JSON序列化<br></li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RFC3339     = <span class="string">"2006-01-02T15:04:05Z07:00"</span></span><br><span class="line">RFC3339Nano = <span class="string">"2006-01-02T15:04:05.999999999Z07:00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MarshalJSON implements the json.Marshaler interface.</span></span><br><span class="line"><span class="comment">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> y := t.Year(); y &lt; <span class="number">0</span> || y &gt;= <span class="number">10000</span> &#123;</span><br><span class="line"><span class="comment">// RFC 3339 is clear that years are 4 digits exactly.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/4556#c15 for more discussion.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Time.MarshalJSON: year outside of range [0,9999]"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(RFC3339Nano)+<span class="number">2</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">b = t.AppendFormat(b, RFC3339Nano)</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmarshalJSON implements the json.Unmarshaler interface.</span></span><br><span class="line"><span class="comment">// The time is expected to be a quoted string in RFC 3339 format.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Ignore null, like in the main JSON package.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(data) == <span class="string">"null"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fractional seconds are handled implicitly by Parse.</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">*t, err = Parse(<span class="string">`"`</span>+RFC3339+<span class="string">`"`</span>, <span class="keyword">string</span>(data))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>时区计算</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">los, _ := time.LoadLocation(<span class="string">"America/Los_Angeles"</span>)</span><br><span class="line">timeFormat := <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line">time1 := time.Unix(<span class="number">1578796676</span>, <span class="number">517932</span>)</span><br><span class="line">time2, _ := time.ParseInLocation(timeFormat, <span class="string">"2020-01-11  18:37:56"</span>, los) <span class="comment">//洛杉矶时间</span></span><br><span class="line">fmt.Println(time1.In(los).Format(timeFormat))</span><br><span class="line">fmt.Println(time2.In(los).Format(timeFormat))</span><br><span class="line">chinaLocal, _ := time.LoadLocation(<span class="string">"Asia/Shanghai"</span>) <span class="comment">// 指定时区</span></span><br><span class="line">fmt.Println(time2.In(chinaLocal).Format(timeFormat)) <span class="comment">// 转换时区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 2020-01-11 18:37:56</span></span><br><span class="line"><span class="comment">// 2020-01-11 18:37:56</span></span><br><span class="line"><span class="comment">// 2020-01-12 10:37:56</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS配置ssh免密登录</title>
      <link href="2019/11/13/ssh/"/>
      <url>2019/11/13/ssh/</url>
      
        <content type="html"><![CDATA[<p>最近双十一买了新购了一台促销服务器，配置环境的时候，在配置<code>ssh</code>公钥免密登录的地方小小踩了一下坑…</p><a id="more"></a><ol><li><p>在客户端上生成密钥对并复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-gen</span><br><span class="line">cd ~/.ssh </span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>服务端配置SSH，打开密钥登录功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config # 编辑文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> add 如下配置</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure></li><li><p>服务器配置登录公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh </span><br><span class="line"><span class="meta">#</span><span class="bash"> or 不存在此文件夹</span></span><br><span class="line">mkdir ~/.ssh</span><br><span class="line"></span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> add 前面生成的公钥</span></span><br></pre></td></tr></table></figure></li><li><p>重启服务器SSH服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></li></ol><p>完成之后，尝试下发现还是无法登录，检查无果。。没办法，只能查日志</p><p><img src="/2019/11/13/ssh/ssh-login-error.jpg" alt="avatar"></p><p>恍然大悟这里还有个小坑，文件夹权限不匹配也是无法登录的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~&#x2F;.ssh</span><br><span class="line">chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys</span><br><span class="line">chown $(whoami):$(whoami) .ssh</span><br><span class="line">chown $(whoami):$(whoami) ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>如果尝试登录还是需要密码，可以通过服务器ssh日志错误一一排查下~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/log</span><br><span class="line">sudo tail -f /var/log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透教程</title>
      <link href="2019/11/10/frpc/"/>
      <url>2019/11/10/frpc/</url>
      
        <content type="html"><![CDATA[<p>移动互联网应用的开发在很多场景下需要我们的内网服务能够在公网被访问，通常需要用到内网穿透工具。FRP就是这样一款开源、免费、跨平台的内网穿透工具。FRP 全名：Fast Reverse Proxy。FRP 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>公网服务器<br>我们需要一台公网服务器作为中转节点。推荐选择国外云商选AWS的Amazon EC2的T2实例，T2实例主要考虑到一些客户无需满负荷运转CPU，但偶尔可能也会有突发性高CPU性能需求, 开发场景下这种服务器性价比非常高。国内阿里云也有这种突发性能的型号可以选择。</p></li><li><p>下载frp软件<br>frp在<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">github</a>上开源，打开软件的<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">release页面</a>, 下载对应平台的软件并解压</p></li></ol><h2 id="通过ssh访问"><a href="#通过ssh访问" class="headerlink" title="通过ssh访问"></a>通过ssh访问</h2><ol><li><p>将<code>frps</code>和<code>frps.ini</code>放到公网服务器上, 修改<code>frps.ini</code>配置如下，其中         <code>bind_port</code>是<code>frp</code>服务所监听端口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure></li><li><p>启动服务, 启动成功会打印出<code>Start frps success</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure></li><li><p>在本地客户端修改<code>frpc.ini</code>文件，将<code>server_port</code>修改为公网服务器ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x # 公网ip</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure></li><li><p>启动客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure></li></ol><h2 id="web服务代理"><a href="#web服务代理" class="headerlink" title="web服务代理"></a>web服务代理</h2><p>经常我们希望内网的web服务能够在公网被访问，而本机通常是没有公网ip的，我们需要配置下frp的http访问端口</p><ol><li><p>修改 <code>frps.ini</code>, <code>vhost_http_port</code>为公网http服务访问端口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">vhost_http_port &#x3D; 8088</span><br></pre></td></tr></table></figure></li><li><p>修改<code>frpc.ini</code>, <code>local_port</code>为本机服务所在端口，而<code>custom_domains</code>为解析到公网ip端口8088上的域名，也可以通过 <code>nginx</code>做一层反向代理</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = www.xxx.com</span><br></pre></td></tr></table></figure></li><li><p>启动服务和客户端，浏览器访问 <code>http://www.xxx.com:8088</code> 即可访问到处于内网机器上的 web 服务</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS安装docker教程</title>
      <link href="2019/11/09/docker%E5%AE%89%E8%A3%85/"/>
      <url>2019/11/09/docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。这里只介绍 Docker CE 在 CentOS下的安装。</p><a id="more"></a><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ol><li><p>yum安装docker依赖包</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>配置 docker-ce 仓库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装 docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>配置docker开机启动并启动docker服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker.service</span><br><span class="line">sudo systemctl start docker.service</span><br></pre></td></tr></table></figure></li><li><p>此时docker已经启动，我们需要将当前用户添加至 <code>docker</code>用户组，这样就可以免<code>sudo</code></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $(whoami)</span><br></pre></td></tr></table></figure></li><li><p>使用执行完成后执行 <code>cat /etc/group</code> 检查下创建是否有效</p></li><li><p>退出当前用户重新登录以便权限配置生效，或者重启 <code>docker-daemon</code></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>如果出现提示<code>dial unix /var/run/docker.sock: connect: permission denied</code> ，说明需要对当前用户授权</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h2><ol><li><p>安装社区企业Linux附加包 <code>epel</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>pip</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y python-pip</span><br></pre></td></tr></table></figure></li><li><p>更新<code>python</code>环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum upgrade python*</span><br></pre></td></tr></table></figure></li><li><p>通过<code>pip</code>安装docker-compose, 安装成功后<code>docker-compose version</code>查看版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(7)——sql连接池源码分析</title>
      <link href="2019/11/08/sync-pool-2019-11-08/"/>
      <url>2019/11/08/sync-pool-2019-11-08/</url>
      
        <content type="html"><![CDATA[<p>使用<code>gorm</code>的时候，连接池配置上出现了些问题，查看源码发现，其连接池部分直接用的标准库<code>database/sql</code>中的连接池实现。花了些时间好好研究了一下它的源码实现。</p><a id="more"></a><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB is a database handle representing a pool of zero or more</span></span><br><span class="line"><span class="comment">// underlying connections. It's safe for concurrent use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The sql package creates and frees connections automatically; it</span></span><br><span class="line"><span class="comment">// also maintains a free pool of idle connections. If the database has</span></span><br><span class="line"><span class="comment">// a concept of per-connection state, such state can be reliably observed</span></span><br><span class="line"><span class="comment">// within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the</span></span><br><span class="line"><span class="comment">// returned Tx is bound to a single connection. Once Commit or</span></span><br><span class="line"><span class="comment">// Rollback is called on the transaction, that transaction's</span></span><br><span class="line"><span class="comment">// connection is returned to DB's idle connection pool. The pool size</span></span><br><span class="line"><span class="comment">// can be controlled with SetMaxIdleConns.</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Atomic access only. At top of struct to prevent mis-alignment</span></span><br><span class="line"><span class="comment">// on 32-bit platforms. Of type time.Duration.</span></span><br><span class="line">waitDuration <span class="keyword">int64</span> <span class="comment">// Total time waited for new connections.</span></span><br><span class="line"></span><br><span class="line">connector driver.Connector</span><br><span class="line"><span class="comment">// numClosed is an atomic counter which represents a total number of</span></span><br><span class="line"><span class="comment">// closed connections. Stmt.openStmt checks it before cleaning closed</span></span><br><span class="line"><span class="comment">// connections in Stmt.css.</span></span><br><span class="line">numClosed <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">mu           sync.Mutex  </span><br><span class="line">freeConn     []*driverConn    <span class="comment">// 空闲连接连接池</span></span><br><span class="line">connRequests <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">chan</span> connRequest <span class="comment">// 连接等待channel</span></span><br><span class="line">nextRequest  <span class="keyword">uint64</span>                      <span class="comment">// Next key to use in connRequests.</span></span><br><span class="line">numOpen      <span class="keyword">int</span>                         <span class="comment">// 连接打开数量</span></span><br><span class="line">openerCh          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">resetterCh        <span class="keyword">chan</span> *driverConn</span><br><span class="line">closed            <span class="keyword">bool</span></span><br><span class="line">dep               <span class="keyword">map</span>[finalCloser]depSet</span><br><span class="line">lastPut           <span class="keyword">map</span>[*driverConn]<span class="keyword">string</span> <span class="comment">// stacktrace of last conn's put; debug only</span></span><br><span class="line">maxIdle           <span class="keyword">int</span>                    <span class="comment">// 最大空闲连接数， &lt;= 0时为默认值defaultMaxIdleConns = 2</span></span><br><span class="line">maxOpen           <span class="keyword">int</span>                    <span class="comment">// 最大连接数， &lt;=0 时为不限制</span></span><br><span class="line">maxLifetime       time.Duration          <span class="comment">// connection最大存活时间</span></span><br><span class="line">cleanerCh         <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">waitCount         <span class="keyword">int64</span>                  <span class="comment">// 连接等待总数</span></span><br><span class="line">maxIdleClosed     <span class="keyword">int64</span>  <span class="comment">// 空闲连接关闭连接总数</span></span><br><span class="line">maxLifetimeClosed <span class="keyword">int64</span>  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">stop <span class="function"><span class="keyword">func</span><span class="params">()</span> // <span class="title">stop</span> <span class="title">cancels</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">opener</span> <span class="title">and</span> <span class="title">the</span> <span class="title">session</span> <span class="title">resetter</span>.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DB这个数据结构有两个非常重要的参数，<code>maxOpen</code>和<code>maxLifetime</code>。<code>maxOpen</code>表示连接池的大小，<code>maxLifetime</code>表示连接最长连接时间。这两个参数需要比MySQL设置的<code>max_connections</code>和<code>wait_timeout</code>值小。</p><h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open one new connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">openNewConnection</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// maybeOpenNewConnctions has already executed db.numOpen++ before it sent</span></span><br><span class="line"><span class="comment">// on db.openerCh. This function must execute db.numOpen-- if the</span></span><br><span class="line"><span class="comment">// connection fails or is closed before returning.</span></span><br><span class="line">ci, err := db.connector.Connect(ctx)</span><br><span class="line">db.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> db.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> db.closed &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">ci.Close()</span><br><span class="line">&#125;</span><br><span class="line">db.numOpen--</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.numOpen--</span><br><span class="line">db.putConnDBLocked(<span class="literal">nil</span>, err)</span><br><span class="line">db.maybeOpenNewConnections()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">dc := &amp;driverConn&#123;</span><br><span class="line">db:        db,</span><br><span class="line">createdAt: nowFunc(),</span><br><span class="line">ci:        ci,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> db.putConnDBLocked(dc, err) &#123;</span><br><span class="line">db.addDepLocked(dc, dc)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.numOpen--</span><br><span class="line">ci.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放置连接"><a href="#放置连接" class="headerlink" title="放置连接"></a>放置连接</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putConn adds a connection to the db's free pool.</span></span><br><span class="line"><span class="comment">// err is optionally the last error that occurred on this connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">putConn</span><span class="params">(dc *driverConn, err error, resetSession <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">db.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> !dc.inUse &#123;</span><br><span class="line"><span class="keyword">if</span> debugGetPut &#123;</span><br><span class="line">fmt.Printf(<span class="string">"putConn(%v) DUPLICATE was: %s\n\nPREVIOUS was: %s"</span>, dc, stack(), db.lastPut[dc])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sql: connection returned that was never out"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debugGetPut &#123;</span><br><span class="line">db.lastPut[dc] = stack()</span><br><span class="line">&#125;</span><br><span class="line">dc.inUse = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, fn := <span class="keyword">range</span> dc.onPut &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line">dc.onPut = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == driver.ErrBadConn &#123;</span><br><span class="line"><span class="comment">// Don't reuse bad connections.</span></span><br><span class="line"><span class="comment">// Since the conn is considered bad and is being discarded, treat it</span></span><br><span class="line"><span class="comment">// as closed. Don't decrement the open count here, finalClose will</span></span><br><span class="line"><span class="comment">// take care of that.</span></span><br><span class="line">db.maybeOpenNewConnections()</span><br><span class="line">db.mu.Unlock()</span><br><span class="line">dc.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> putConnHook != <span class="literal">nil</span> &#123;</span><br><span class="line">putConnHook(db, dc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> db.closed &#123;</span><br><span class="line"><span class="comment">// Connections do not need to be reset if they will be closed.</span></span><br><span class="line"><span class="comment">// Prevents writing to resetterCh after the DB has closed.</span></span><br><span class="line">resetSession = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resetSession &#123;</span><br><span class="line"><span class="keyword">if</span> _, resetSession = dc.ci.(driver.SessionResetter); resetSession &#123;</span><br><span class="line"><span class="comment">// Lock the driverConn here so it isn't released until</span></span><br><span class="line"><span class="comment">// the connection is reset.</span></span><br><span class="line"><span class="comment">// The lock must be taken before the connection is put into</span></span><br><span class="line"><span class="comment">// the pool to prevent it from being taken out before it is reset.</span></span><br><span class="line">dc.Lock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">added := db.putConnDBLocked(dc, <span class="literal">nil</span>)</span><br><span class="line">db.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !added &#123;</span><br><span class="line"><span class="keyword">if</span> resetSession &#123;</span><br><span class="line">dc.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">dc.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !resetSession &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// If the resetterCh is blocking then mark the connection</span></span><br><span class="line"><span class="comment">// as bad and continue on.</span></span><br><span class="line">dc.lastErr = driver.ErrBadConn</span><br><span class="line">dc.Unlock()</span><br><span class="line"><span class="keyword">case</span> db.resetterCh &lt;- dc:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="等待连接"><a href="#等待连接" class="headerlink" title="等待连接"></a>等待连接</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">conn</span><span class="params">(ctx context.Context, strategy connReuseStrategy)</span> <span class="params">(*driverConn, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out of free connections or we were asked not to use one. If we're not</span></span><br><span class="line"><span class="comment">// allowed to open any more connections, make a request and wait.</span></span><br><span class="line"><span class="keyword">if</span> db.maxOpen &gt; <span class="number">0</span> &amp;&amp; db.numOpen &gt;= db.maxOpen &#123;</span><br><span class="line"><span class="comment">// Make the connRequest channel. It's buffered so that the</span></span><br><span class="line"><span class="comment">// connectionOpener doesn't block while waiting for the req to be read.</span></span><br><span class="line">req := <span class="built_in">make</span>(<span class="keyword">chan</span> connRequest, <span class="number">1</span>)</span><br><span class="line">reqKey := db.nextRequestKeyLocked()</span><br><span class="line">db.connRequests[reqKey] = req</span><br><span class="line">db.waitCount++</span><br><span class="line">db.mu.Unlock()</span><br><span class="line"></span><br><span class="line">waitStart := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timeout the connection request with the context.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// Remove the connection request and ensure no value has been sent</span></span><br><span class="line"><span class="comment">// on it after removing.</span></span><br><span class="line">db.mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(db.connRequests, reqKey)</span><br><span class="line">db.mu.Unlock()</span><br><span class="line"></span><br><span class="line">atomic.AddInt64(&amp;db.waitDuration, <span class="keyword">int64</span>(time.Since(waitStart)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> ret, ok := &lt;-req:</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; ret.conn != <span class="literal">nil</span> &#123;</span><br><span class="line">db.putConn(ret.conn, ret.err, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line"><span class="keyword">case</span> ret, ok := &lt;-req:</span><br><span class="line">atomic.AddInt64(&amp;db.waitDuration, <span class="keyword">int64</span>(time.Since(waitStart)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errDBClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret.err == <span class="literal">nil</span> &amp;&amp; ret.conn.expired(lifetime) &#123;</span><br><span class="line">ret.conn.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret.conn == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ret.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lock around reading lastErr to ensure the session resetter finished.</span></span><br><span class="line">ret.conn.Lock()</span><br><span class="line">err := ret.conn.lastErr</span><br><span class="line">ret.conn.Unlock()</span><br><span class="line"><span class="keyword">if</span> err == driver.ErrBadConn &#123;</span><br><span class="line">ret.conn.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret.conn, ret.err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接清理"><a href="#连接清理" class="headerlink" title="连接清理"></a>连接清理</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">connectionCleaner</span><span class="params">(d time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> minInterval = time.Second</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d &lt; minInterval &#123;</span><br><span class="line">d = minInterval</span><br><span class="line">&#125;</span><br><span class="line">t := time.NewTimer(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line"><span class="keyword">case</span> &lt;-db.cleanerCh: <span class="comment">// maxLifetime was changed or db was closed.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.mu.Lock()</span><br><span class="line">d = db.maxLifetime</span><br><span class="line"><span class="keyword">if</span> db.closed || db.numOpen == <span class="number">0</span> || d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">db.cleanerCh = <span class="literal">nil</span></span><br><span class="line">db.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expiredSince := nowFunc().Add(-d)</span><br><span class="line"><span class="keyword">var</span> closing []*driverConn</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(db.freeConn); i++ &#123;</span><br><span class="line">c := db.freeConn[i]</span><br><span class="line"><span class="keyword">if</span> c.createdAt.Before(expiredSince) &#123;</span><br><span class="line">closing = <span class="built_in">append</span>(closing, c)</span><br><span class="line">last := <span class="built_in">len</span>(db.freeConn) - <span class="number">1</span></span><br><span class="line">db.freeConn[i] = db.freeConn[last]</span><br><span class="line">db.freeConn[last] = <span class="literal">nil</span></span><br><span class="line">db.freeConn = db.freeConn[:last]</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">db.maxLifetimeClosed += <span class="keyword">int64</span>(<span class="built_in">len</span>(closing))</span><br><span class="line">db.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> closing &#123;</span><br><span class="line">c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d &lt; minInterval &#123;</span><br><span class="line">d = minInterval</span><br><span class="line">&#125;</span><br><span class="line">t.Reset(d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(6)——byte操作</title>
      <link href="2019/11/01/byte-2019-11-01/"/>
      <url>2019/11/01/byte-2019-11-01/</url>
      
        <content type="html"><![CDATA[<p>[]byte和string 在 golang 里是非常重要的数据结构，虽然我们通常把它当成一个整体进行操作，实际上它在内存是一片连续的字符数组，并且golang里<code>string</code>是只读的。</p><a id="more"></a><h2 id="byte与string"><a href="#byte与string" class="headerlink" title="[]byte与string"></a>[]byte与string</h2><p>查看源码发现<code>string</code>底层结构与<code>slice</code>非常相似</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> stringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">str unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>string</code>和<code>[]byte</code>互转</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">"abc"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(b)</span><br><span class="line">b = <span class="keyword">string</span>(c)</span><br></pre></td></tr></table></figure><p>当我们进行文件读写、json序列化等操作时候经常会用到<code>[]byte</code>和<code>string</code>的转换，当然类型转换的开销并没有想象的那么小，我们经常会看到 runtime.slicebytetostring 等函数出现在火焰图1中，成为程序的性能热点，源码如下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte to string</span></span><br><span class="line"><span class="comment">// Buf is a fixed-size buffer for the result,</span></span><br><span class="line"><span class="comment">// it is not nil if the result does not escape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="keyword">byte</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">l := <span class="built_in">len</span>(b)</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Turns out to be a relatively common case.</span></span><br><span class="line"><span class="comment">// Consider that you want to parse out data between parens in "foo()bar",</span></span><br><span class="line"><span class="comment">// you find the indices and convert the subslice to string.</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line"><span class="keyword">uintptr</span>(l),</span><br><span class="line">getcallerpc(),</span><br><span class="line">funcPC(slicebytetostring))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="keyword">uintptr</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">p = unsafe.Pointer(buf)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = mallocgc(<span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">stringStructOf(&amp;str).str = p</span><br><span class="line">stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string to []byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">*buf = tmpBuf&#123;&#125;</span><br><span class="line">b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(b, s)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="byte和int互转"><a href="#byte和int互转" class="headerlink" title="byte和int互转"></a>byte和int互转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bytes&quot;</span><br><span class="line">    &quot;encoding&#x2F;binary&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func IntToBytes(n int) []byte &#123;</span><br><span class="line">    data :&#x3D; int64(n)</span><br><span class="line">    bytebuf :&#x3D; bytes.NewBuffer([]byte&#123;&#125;)</span><br><span class="line">    binary.Write(bytebuf, binary.BigEndian, data)</span><br><span class="line">    return bytebuf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BytesToInt(bys []byte) int &#123;</span><br><span class="line">    bytebuff :&#x3D; bytes.NewBuffer(bys)</span><br><span class="line">    var data int64</span><br><span class="line">    binary.Read(bytebuff, binary.BigEndian, &amp;data)</span><br><span class="line">    return int(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(5)——slice切片</title>
      <link href="2019/10/11/slice-2019-10-11/"/>
      <url>2019/10/11/slice-2019-10-11/</url>
      
        <content type="html"><![CDATA[<p>golang的切片跟python的list一样几乎是用的最多的数据结构了，如果要用它真的很不容易。这篇文件是对工作中slice的使用和遇到坑的总结。</p><a id="more"></a><p>slice使用起来很像是一个会自动扩容的数组，通过源码可以看到它的本质。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">// 数组容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，<code>slice</code>有3个属性，指针、长度、容量，也就是说实际的元素还是以数组的形式存储。</p><h2 id="append-扩容"><a href="#append-扩容" class="headerlink" title="append 扩容"></a>append 扩容</h2><p>slice作为变长的数组，它的扩容是怎么实现的呢。我们来看一下<code>slice append</code> 方法的源码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于1024的时候，容量翻倍</span></span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于1024，每次扩容1/4</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line"><span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line"><span class="comment">// Only shade the pointers in old.array since we know the destination slice p</span></span><br><span class="line"><span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    memmove(p, old.array, lenmem)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，1024字节以下，每次容量翻倍，1024字节以上，每次增加1/4，然后返回一个新的切片。也就是扩容需要重新生成一个新的底层数组，频繁的扩容必然会带来性能损耗。</p><h2 id="创建Slice"><a href="#创建Slice" class="headerlink" title="创建Slice"></a>创建Slice</h2><p>golang提供了创建多种切片方式，需要注意的是通过切片操作创建的新<code>slice</code>与旧<code>slice</code>是共享底层数组的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var s1 []int            &#x2F;&#x2F; 直接声明</span><br><span class="line">s2 :&#x3D; []int&#123;1, 2, 3&#125;    &#x2F;&#x2F; 赋值</span><br><span class="line">s3 :&#x3D; *new([]int)       &#x2F;&#x2F; new</span><br><span class="line">s4 :&#x3D; make([]int, 3, 5) &#x2F;&#x2F; make</span><br><span class="line">s5 :&#x3D; s4[:2]            &#x2F;&#x2F; 切片</span><br><span class="line">fmt.Printf(&quot;s1: len &#x3D; %d, cap &#x3D; %d\n&quot;, len(s1), cap(s1))</span><br><span class="line">fmt.Printf(&quot;s2: len &#x3D; %d, cap &#x3D; %d\n&quot;, len(s2), cap(s2))</span><br><span class="line">fmt.Printf(&quot;s3: len &#x3D; %d, cap &#x3D; %d\n&quot;, len(s3), cap(s3))</span><br><span class="line">fmt.Printf(&quot;s4: len &#x3D; %d, cap &#x3D; %d\n&quot;, len(s4), cap(s4))</span><br><span class="line">fmt.Printf(&quot;s5: len &#x3D; %d, cap &#x3D; %d\n&quot;, len(s5), cap(s5))</span><br><span class="line">    fmt.Println(s1 &#x3D;&#x3D; nil)</span><br><span class="line">fmt.Println(s2 &#x3D;&#x3D; nil)</span><br><span class="line">    s5[0] &#x3D; 15</span><br><span class="line">fmt.Println(s4)</span><br><span class="line">fmt.Println(s5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">s1: len &#x3D; 0, cap &#x3D; 0</span><br><span class="line">s2: len &#x3D; 3, cap &#x3D; 3</span><br><span class="line">s3: len &#x3D; 0, cap &#x3D; 0</span><br><span class="line">s4: len &#x3D; 3, cap &#x3D; 5</span><br><span class="line">s5: len &#x3D; 2, cap &#x3D; 5</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">[15 0 0] &#x2F;&#x2F; 因为s4,s5共享底层数组，s5改变之后，s4也被改变了</span><br><span class="line">[15 0]</span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p>slice并没有像<code>python list</code>提供那么多丰富的api，但是通过<code>append</code>方法可以实现很多常用的操作</p><p>元素插入</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fvar a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br></pre></td></tr></table></figure><p>可以用copy和append组合可以避免创建中间的临时切片，同样是完成添加元素的操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>)     <span class="comment">// 切片扩展1个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[<span class="number">1</span>:]...) <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[N:]...) <span class="comment">// 删除开头N个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...) <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:]...) <span class="comment">// 删除中间N个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-N]   <span class="comment">// 删除尾部N个元素</span></span><br></pre></td></tr></table></figure><p>比如下面的TrimSpace函数用于删除[]byte中的空格。函数实现利用了0长切片的特性，实现高效而且简洁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b := s[:<span class="number">0</span>]  <span class="comment">// 利用 s 的底层数组，无需额外分配空间</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> x != <span class="string">' '</span> &#123;</span><br><span class="line">            b = <span class="built_in">append</span>(b, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(4)——协程调度</title>
      <link href="2019/09/30/golang-GMP/"/>
      <url>2019/09/30/golang-GMP/</url>
      
        <content type="html"><![CDATA[<p>golang最大的特色就是随处可见的goroutine，一个<code>go</code>关键字就可以实现原生的并发，main函数本身也是一个gouroutine。无需关心其实现，就可以轻松实现一个高并发的程序。但是，如果能够理解goroutine的调度，对于写出高质量的程序帮助很大。</p><a id="more"></a><h2 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h2><p>通常用三种线程调度模型，用户级，内核级和两级</p><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与内核线程是多对1（N:1) 的映射，优点：调度是在用户程序层面实现的，调度开销非常轻量，缺点：用户线程被阻塞会导致进程内所有线程都被堵塞，因此无法实现真正的并发</p><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与内核线程是一对一（1：1）的映射，优点：是借助操作系统内核调度，实现线程创建、切换、销毁，从而实现真正的并发，缺点：由于内核线程调度开销大，性能损耗很大</p><h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3><p>用户线程与内核线程是多对多 (M:N) 的映射，这种混合型的线程模型集合前面两种线程模型的优势，既能减少调度开发，也能实现真正的并发</p><h2 id="golang-GMP模型"><a href="#golang-GMP模型" class="headerlink" title="golang GMP模型"></a>golang GMP模型</h2><p>golang <code>GMP</code>模型在两级线程模型<code>GM</code>的基础上加入了中间层<code>P</code></p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><code>G, Goroutine</code>，这个就是通过<code>go</code>关键字创建出来<code>goroutine</code>，相对于内核线程<code>2M</code>的固定栈内存，<code>goroutine</code>采取动态扩容的方式，初始分配<code>2KB</code>内存，随着任务的运行64系统最大<code>1GB</code>。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p><code>M，Machine</code>, 对应系统线程，代表着真正执行计算的资源，在绑定有效的 <code>P</code>后，进入 schedule 循环</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p><code>P, Process</code>, 表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。</p><h2 id="GMP调度"><a href="#GMP调度" class="headerlink" title="GMP调度"></a>GMP调度</h2><h3 id="正常运行"><a href="#正常运行" class="headerlink" title="正常运行"></a>正常运行</h3><p>所有的goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。</p><h3 id="线程堵塞"><a href="#线程堵塞" class="headerlink" title="线程堵塞"></a>线程堵塞</h3><p>当正在运行的goroutine（G0）阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1)，当前的M0线程放弃了它的Processor（P），P转到新的线程中去运行。</p><p><img src="/2019/09/30/golang-GMP/%E5%A0%B5%E5%A1%9E.png" alt="线程堵塞"></p><h3 id="Process-runqueue执行完"><a href="#Process-runqueue执行完" class="headerlink" title="Process runqueue执行完"></a>Process runqueue执行完</h3><p>当其中一个Processor的runqueue为空，没有goroutine可以调度，它会从另外一个上下文偷取一半的goroutine。</p><p>![获取任务]](golang-GMP/获取.png)</p><h2 id="goroutine插入顺序"><a href="#goroutine插入顺序" class="headerlink" title="goroutine插入顺序"></a>goroutine插入顺序</h2><p>先说结论，不考虑调度器影响，<code>goroutine</code> 队列是类似栈的数据结构，后进先出的（头部插入，头部取出）</p><p>写个测试程序，设置Process数量为1，后创建的<code>goroutine func1</code>先执行，程序堵塞，<code>func2</code>无法输出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单Process调度</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">func1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程2 先执行</span></span><br><span class="line"><span class="comment">// 成功输出: hello world</span></span><br><span class="line"><span class="keyword">go</span> func2()</span><br><span class="line"><span class="keyword">go</span> func1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>调换一下顺序，后创建的<code>goroutine func2</code>先执行，成功输出<code>hello world</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">func1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程2 先执行</span></span><br><span class="line"><span class="comment">// 成功输出: hello world</span></span><br><span class="line"><span class="keyword">go</span> func1()</span><br><span class="line"><span class="keyword">go</span> func2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(3)——struct tags</title>
      <link href="2019/09/16/golang-tag/"/>
      <url>2019/09/16/golang-tag/</url>
      
        <content type="html"><![CDATA[<p>golang tag的语法是非常具有语言特色的，当然对于新手来说，也是非常懵逼。今天来总结一下tags的用法。<br>对于tag,官方定义如下。简单说就是tag是字段可选的声明，除非通过反射获取，不然会被忽略。</p><blockquote><p>A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. The tags are made visible through a reflection interface but are otherwise ignored.</p></blockquote><a id="more"></a><p>首先tag最常见的用法就是定义<code>json序列化的字段名</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">FirstName  <span class="keyword">string</span></span><br><span class="line">SecondName  <span class="keyword">string</span></span><br><span class="line">Age   <span class="keyword">int</span></span><br><span class="line">Grade <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := Student&#123;</span><br><span class="line">FirstName:  <span class="string">"Xiao"</span>,</span><br><span class="line">SecondName:  <span class="string">"Ming"</span>,</span><br><span class="line">Age:   <span class="number">18</span>,</span><br><span class="line">Grade: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">j, _ := json.Marshal(s)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(j))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： &#123;"FirstName":"Xiao","SecondName":"Ming","Age":18,"Grade":10&#125;</span></span><br></pre></td></tr></table></figure><p>我们会发现这样序列化出来的字段名是驼峰的，而通常<code>json</code>更习惯于蛇形命名。我们可以通过添加字段tag实现这个。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">FirstName  <span class="keyword">string</span> <span class="string">`json:"first_name"`</span></span><br><span class="line">SecondName  <span class="keyword">string</span> <span class="string">`json:"second_name"`</span></span><br><span class="line">Age   <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">Grade <span class="keyword">int</span> <span class="string">`json:"grade"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出： &#123;"first_name":"Xiao","second_name":"Ming","age":18,"grade":10&#125;</span></span><br></pre></td></tr></table></figure><p>前面说到，tag可以用反射获取，参考<code>reflect</code>文档。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st := reflect.TypeOf(s)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; st.NumField(); i++ &#123;</span><br><span class="line">    f := st.Field(i)</span><br><span class="line">    t := f.Tag.Get(<span class="string">"json"</span>)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// first_name</span></span><br><span class="line"><span class="comment">// second_name</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"><span class="comment">// grade</span></span><br></pre></td></tr></table></figure><p>使用 <code>Tag.Get</code> 当字段不存在的时候，会返回空字符串，reflect包还提供了一个<code>Tag.Lookup</code>可以更好的判断这种情况。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    FirstName  <span class="keyword">string</span> <span class="string">`json:"first_name"`</span></span><br><span class="line">    SecondName  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Grade <span class="keyword">int</span> <span class="string">`json:"grade"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := Student&#123;</span><br><span class="line">    FirstName:  <span class="string">"Xiao"</span>,</span><br><span class="line">    SecondName:  <span class="string">"Ming"</span>,</span><br><span class="line">    Age:   <span class="number">18</span>,</span><br><span class="line">    Grade: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st := reflect.TypeOf(s)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; st.NumField(); i++ &#123;</span><br><span class="line">    f := st.Field(i)</span><br><span class="line">    <span class="keyword">if</span> t, ok := f.Tag.Lookup(<span class="string">"json"</span>); ok &#123;</span><br><span class="line">        fmt.Println(t)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"no json tag"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// first_name</span></span><br><span class="line"><span class="comment">// no json tag</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"><span class="comment">// grade</span></span><br></pre></td></tr></table></figure><p>我们也可以自定义一些字段，通过<code>key</code>访问到，从而实现一些逻辑处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">FirstName  <span class="keyword">string</span> <span class="string">`json:"first_name" print:"姓"`</span></span><br><span class="line">SecondName  <span class="keyword">string</span> <span class="string">`json:"second_name" print:"名"`</span></span><br><span class="line">Age   <span class="keyword">int</span> <span class="string">`json:"age" print:"年龄"`</span></span><br><span class="line">Grade <span class="keyword">int</span> <span class="string">`json:"grade" print:"年级"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := Student&#123;</span><br><span class="line">    FirstName:  <span class="string">"Xiao"</span>,</span><br><span class="line">    SecondName:  <span class="string">"Ming"</span>,</span><br><span class="line">    Age:   <span class="number">18</span>,</span><br><span class="line">    Grade: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st := reflect.TypeOf(s)</span><br><span class="line">vt := reflect.ValueOf(s)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; st.NumField(); i++ &#123;</span><br><span class="line">    f := st.Field(i)</span><br><span class="line">    v := vt.Field(i)</span><br><span class="line">    t := f.Tag.Get(<span class="string">"print"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%s是%v\n"</span>, t, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 姓是Xiao</span></span><br><span class="line"><span class="comment">// 名是Ming</span></span><br><span class="line"><span class="comment">// 年龄是18</span></span><br><span class="line"><span class="comment">// 年级是10</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(2)——strings包</title>
      <link href="2019/09/09/strings/"/>
      <url>2019/09/09/strings/</url>
      
        <content type="html"><![CDATA[<p>golang的官方库strings库非常的强大，用了很久感觉需要整理一下相关api才能更好的掌握。</p><a id="more"></a><h2 id="中文处理"><a href="#中文处理" class="headerlink" title="中文处理"></a>中文处理</h2><p>首先，需要分清楚 <code>rune</code>和<code>byte</code>, 查看源码，我们可以知道，<code>byte</code>其实是单字节，而<code>rune</code>是4个字节，很明显，<code>rune</code>其实就是<code>unicode</code>码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>我们遍历一个中文字符串看看会是什么结果输出。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cnStr := <span class="string">"中文abc"</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> cnStr &#123;</span><br><span class="line">fmt.Println(x, <span class="string">" "</span>, <span class="keyword">string</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 20013   中</span></span><br><span class="line"><span class="comment">// 25991   文</span></span><br><span class="line"><span class="comment">// 97   a</span></span><br><span class="line"><span class="comment">// 98   b</span></span><br><span class="line"><span class="comment">// 99   c</span></span><br></pre></td></tr></table></figure><p>这个遍历结果跟将<code>string</code>转成<code>[]rune</code>遍历结果一致。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cnStr := <span class="string">"中文abc"</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> []<span class="keyword">rune</span>(cnStr) &#123;</span><br><span class="line">fmt.Println(x, <span class="string">" "</span>, <span class="keyword">string</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 20013   中</span></span><br><span class="line"><span class="comment">// 25991   文</span></span><br><span class="line"><span class="comment">// 97   a</span></span><br><span class="line"><span class="comment">// 98   b</span></span><br><span class="line"><span class="comment">// 99   c</span></span><br></pre></td></tr></table></figure><p>然后我们把这个字符串按<code>[]byte</code>遍历看看。不出所料出现了乱码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cnStr := <span class="string">"中文abc"</span></span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> []<span class="keyword">byte</span>(cnStr) &#123;</span><br><span class="line">fmt.Println(x, <span class="string">" "</span>, <span class="keyword">string</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 228   ä</span></span><br><span class="line"><span class="comment">// 184   ¸</span></span><br><span class="line"><span class="comment">// 173   ­</span></span><br><span class="line"><span class="comment">// 230   æ</span></span><br><span class="line"><span class="comment">// 150   </span></span><br><span class="line"><span class="comment">// 135   </span></span><br><span class="line"><span class="comment">// 97   a</span></span><br><span class="line"><span class="comment">// 98   b</span></span><br><span class="line"><span class="comment">// 99   c</span></span><br></pre></td></tr></table></figure><h2 id="子串检查"><a href="#子串检查" class="headerlink" title="子串检查"></a>子串检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 子串 substr 在 s 中，返回 true</span><br><span class="line">func Contains(s, substr string) bool</span><br><span class="line">&#x2F;&#x2F; chars 中任何一个 Unicode 代码点在 s 中，返回 true</span><br><span class="line">func ContainsAny(s, chars string) bool</span><br><span class="line">&#x2F;&#x2F; Unicode 代码点 r 在 s 中，返回 true</span><br><span class="line">func ContainsRune(s string, r rune) bool</span><br></pre></td></tr></table></figure><p>需要注意的是空字符串, <code>strings.Contains</code>和<code>strings.ContainsAny</code>判断结果不一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b1 := strings.Contains("abc", "a")</span><br><span class="line">b2 := strings.Contains("abc", "")</span><br><span class="line">b3 := strings.ContainsAny("abc", "a")</span><br><span class="line">b4 := strings.ContainsAny("abc", "")</span><br><span class="line">b5 := strings.ContainsRune("中国", '中')</span><br><span class="line">fmt.Println("b1 =", b1)</span><br><span class="line">fmt.Println("b2 =", b2)</span><br><span class="line">fmt.Println("b3 =", b3)</span><br><span class="line">fmt.Println("b4 =", b4)</span><br><span class="line">fmt.Println("b5 =", b5)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">b1 = true</span><br><span class="line">b2 = true</span><br><span class="line">b3 = true</span><br><span class="line">b4 = false</span><br><span class="line">b5 = true</span><br></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>字符串分割应该是最常见的使用了，strings包提供了这6个方法：Fields 和 FieldsFunc、Split 和 SplitAfter、SplitN 和 SplitAfterN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Fields(s string) []string</span><br><span class="line">func FieldsFunc(s string, f func(rune) bool) []string</span><br><span class="line">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</span><br><span class="line">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</span><br><span class="line">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</span><br><span class="line">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep, len(sep), n) &#125;</span><br></pre></td></tr></table></figure><p>方法使用示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s1 :&#x3D; &quot;abc def hig lmn pgo&quot;</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Fields(s1))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.FieldsFunc(s1, func(r rune) bool &#123;</span><br><span class="line">if r &#x3D;&#x3D; &#39; &#39; &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(s1, &quot; &quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitN(s1, &quot; &quot;, 2)) &#x2F;&#x2F; 最多N个子串</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(s1, &quot; &quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitAfterN(s1, &quot; &quot;, 2))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">[abc def hig lmn pgo]</span><br><span class="line">[abc def hig lmn pgo]</span><br><span class="line">[abc def hig lmn pgo]</span><br><span class="line">[&quot;abc&quot; &quot;def hig lmn pgo&quot;]</span><br><span class="line">[&quot;abc &quot; &quot;def &quot; &quot;hig &quot; &quot;lmn &quot; &quot;pgo&quot;]</span><br><span class="line">[&quot;abc &quot; &quot;def hig lmn pgo&quot;]</span><br></pre></td></tr></table></figure><h2 id="字符串index"><a href="#字符串index" class="headerlink" title="字符串index"></a>字符串index</h2><p><code>strings.Index</code>这个函数使用也很简单, 注意查找中文字符应该用<code>strings.IndexRune</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 :&#x3D; &quot;abc中国!&quot;</span><br><span class="line">fmt.Println(strings.Index(s1, &quot;a&quot;))</span><br><span class="line">fmt.Println(strings.Index(s1, &quot;&quot;))</span><br><span class="line">fmt.Println(strings.Index(s1, &quot;!&quot;))</span><br><span class="line">fmt.Println(strings.Index(s1, &quot;中&quot;))</span><br><span class="line">fmt.Println(strings.Index(s1, &quot;z&quot;))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.IndexRune(s1, &#39;中&#39;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang系列(1)——pprof性能分析</title>
      <link href="2019/09/01/pprof/"/>
      <url>2019/09/01/pprof/</url>
      
        <content type="html"><![CDATA[<p>pprof是golang runtime内置的性能分析工具。</p><a id="more"></a><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>pprof的使用只需要引入pprof包，然后在任意端口上启动http服务。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span> <span class="comment">// pprof debug</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>) <span class="comment">// debug</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动后，我们在浏览器上打开<code>http://localhost:8080/debug/pprof/</code>, 可以看到如下界面说明pprof正常启动。</p><p><img src="/2019/09/01/pprof/pprof-web.png" alt="pprof界面"></p><h2 id="CPU分析"><a href="#CPU分析" class="headerlink" title="CPU分析"></a>CPU分析</h2><p>首先采集 cpu 信息，有两种方式，web上点击<code>profile</code>链接获得profile文件，或者用 <code>go tool pprof</code>采集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开profile文件</span></span><br><span class="line">go tool pprof /profile/file/path</span><br><span class="line"><span class="meta">#</span><span class="bash">  采集30秒cpu信息</span></span><br><span class="line">go tool pprof 'http://localhost:8080/debug/pprof/profile?seconds=30'</span><br></pre></td></tr></table></figure><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>浏览器打开<code>http://localhost:8080/debug/pprof/heap?debug=1</code>，可以看到 golang 程序实时的内存信息。从图第一行可以看出当前使用内存6KB。</p><p><img src="/2019/09/01/pprof/pprof-mem.png" alt="goroutine界面"></p><p>我们可以使用 <code>go tool pprof</code> 查看更多信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 已经分配的内存</span></span><br><span class="line">go tool pprof -alloc_space http://localhost:8080/debug/pprof/heap</span><br><span class="line"><span class="meta">#</span><span class="bash"> 正在使用的内存</span></span><br><span class="line">go tool pprof -inuse_space http://localhost:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure><p><img src="/2019/09/01/pprof/pprof-mem2.png" alt="内存使用"></p><h2 id="goroutine分析"><a href="#goroutine分析" class="headerlink" title="goroutine分析"></a>goroutine分析</h2><p>浏览器打开<code>http://localhost:8080/debug/pprof/goroutine?debug=1</code>，可以看到 golang 程序实时的goroutine数量和调用信息。</p><p><img src="/2019/09/01/pprof/pprof-goroutine.png" alt="goroutine界面"></p><p>打开<code>http://localhost:8080/debug/pprof/goroutine?debug=2</code>，可以看到<code>goroutine</code>更详细的信息。</p><p><img src="/2019/09/01/pprof/pprof-goroutine2.png" alt="goroutine界面"></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
